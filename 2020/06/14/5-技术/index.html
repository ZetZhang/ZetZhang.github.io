<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("https://zetzhang.github.io/"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="条款25：将constructor和non-member functions虚化 将Non-Member Functions的行为虚化   条款26：限制某个class所能产生的对象数量 允许零个或一个对象 不同的对象构造状态 允许对象生生灭灭 一个用来计算对象个数的Base Class   条款27：要求（或禁止）对象产生于heap之中 要求对象产生于heap之中(Heap-Based O">
<meta property="og:type" content="article">
<meta property="og:title" content="5 技术">
<meta property="og:url" content="http://example.com/2020/06/14/5-%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content=".27t_lBZ4oZgg_">
<meta property="og:description" content="条款25：将constructor和non-member functions虚化 将Non-Member Functions的行为虚化   条款26：限制某个class所能产生的对象数量 允许零个或一个对象 不同的对象构造状态 允许对象生生灭灭 一个用来计算对象个数的Base Class   条款27：要求（或禁止）对象产生于heap之中 要求对象产生于heap之中(Heap-Based O">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-14T05:52:07.000Z">
<meta property="article:modified_time" content="2021-09-09T08:26:07.597Z">
<meta property="article:author" content="Ichheit">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="More Effecive C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/06/14/5-%E6%8A%80%E6%9C%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>5 技术 | .27t_lBZ4oZgg_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">.27t_lBZ4oZgg_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/5-%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          5 技术
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:52:07" itemprop="dateCreated datePublished" datetime="2020-06-14T13:52:07+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-03/" itemprop="url" rel="index"><span itemprop="name">2019.03</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E5%B0%86constructor%E5%92%8Cnon-member-functions%E8%99%9A%E5%8C%96">条款25：将constructor和non-member functions虚化</a><ul>
<li><a href="#%E5%B0%86non-member-functions%E7%9A%84%E8%A1%8C%E4%B8%BA%E8%99%9A%E5%8C%96">将Non-Member Functions的行为虚化</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAclass%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F">条款26：限制某个class所能产生的对象数量</a><ul>
<li><a href="#%E5%85%81%E8%AE%B8%E9%9B%B6%E4%B8%AA%E6%88%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">允许零个或一个对象</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E7%8A%B6%E6%80%81">不同的对象构造状态</a></li>
<li><a href="#%E5%85%81%E8%AE%B8%E5%AF%B9%E8%B1%A1%E7%94%9F%E7%94%9F%E7%81%AD%E7%81%AD">允许对象生生灭灭</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0%E7%9A%84base-class">一个用来计算对象个数的Base Class</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E8%A6%81%E6%B1%82%EF%BC%88%E6%88%96%E7%A6%81%E6%AD%A2%EF%BC%89%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD">条款27：要求（或禁止）对象产生于heap之中</a><ul>
<li><a href="#%E8%A6%81%E6%B1%82%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD%EF%BC%88heap-based-objects%EF%BC%89">要求对象产生于heap之中(Heap-Based Objects)</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%BD%8D%E4%BA%8Eheap%E5%86%85">判断某个对象是否位于heap内</a></li>
<li><a href="#%E7%A6%81%E6%AD%A2%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD">禁止对象产生于heap之中</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9Asmart-pointers%EF%BC%88%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%89">条款28：Smart Pointers（智能指针）</a><ul>
<li><a href="#smart-pointers%E7%9A%84%E6%9E%84%E9%80%A0%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9E%90%E6%9E%84">Smart Pointers的构造、复制、析构</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0dereferencing-operators%EF%BC%88%E8%A7%A3%E5%BC%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">实现Dereferencing Operators（解引操作符）</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95smart-pointers%E6%98%AF%E5%90%A6%E4%B8%BAnull">测试Smart Pointers是否为NULL</a></li>
<li><a href="#%E5%B0%86smart-pointers%E8%BD%AC%E6%8D%A2%E4%B8%BAdumb-pointers">将Smart Pointers转换为Dumb Pointers</a></li>
<li><a href="#smart-pointers%E5%92%8C%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9C%89%E5%85%B3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Smart Pointers和与继承有关的类型转换</a><ul>
<li><a href="#smart-pointers%E4%B8%8Econst">Smart Pointers与const</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9Areference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89">条款29：Reference counting（引用计数）</a><ul>
<li><a href="#reference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0">Reference Counting（引用计数）的实现</a></li>
<li><a href="#copy-on-write%EF%BC%88%E5%86%99%E6%97%B6%E6%89%8D%E5%A4%8D%E5%88%B6%EF%BC%89">Copy-on-Write（写时才复制）</a></li>
<li><a href="#pointers,references,%E4%BB%A5%E5%8F%8Acopy-on-write">Pointers,References,以及Copy-on-Write</a></li>
<li><a href="#%E4%B8%80%E4%B8%AAreference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89%E5%9F%BA%E7%B1%BB">一个Reference-Counting（引用计数)基类</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9Creference-count%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89">自动操作Reference Count（引用计数）</a></li>
<li><a href="#%E6%8A%8A%E6%89%80%E6%9C%89%E5%8A%AA%E5%8A%9B%E6%94%BE%E5%88%B0%E8%BF%99%E9%87%8C">把所有努力放到这里</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9Aproxy-classes%EF%BC%88%E6%9B%BF%E8%BA%AB%E7%B1%BB%E3%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%89">条款30：Proxy classes（替身类、代理类）</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%99%9A%E5%8C%96">条款31：让函数根据一个以上的对象类型来决定如何虚化</a><ul>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0-+-rtti%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%EF%BC%89">虚函数 + RTTI（运行时期类型识别）</a></li>
<li><a href="#%E5%8F%AA%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0">只使用虚函数</a></li>
<li><a href="#%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%EF%BC%88virtual-function-tables%EF%BC%89">自行仿真虚函数表格（Virtual Function Tables）</a></li>
<li><a href="#%E5%B0%86%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%EF%BC%88virtual-function-tables%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96">将自行仿真的虚函数表格（Virtual Function Tables）初始化</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E2%80%9D%E9%9D%9E%E6%88%90%E5%91%98%EF%BC%88non-member%EF%BC%89%E5%87%BD%E6%95%B0%E2%80%9C%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">使用”非成员（Non-Member）函数“的碰撞处理函数</a></li>
<li><a href="#%E2%80%9D%E7%BB%A7%E6%89%BF%E2%80%9C-+-%E2%80%9D%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%E2%80%9C">”继承“ + ”自行仿真的虚函数表格“</a></li>
<li><a href="#%E5%B0%86%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%86%8D%E5%BA%A6%E8%AE%A8%E8%AE%BA%EF%BC%89">将自行仿真的虚函数表格初始化（再度讨论）</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<p>设计C++软件时，有一些问题会不断重复出现。例如，如何让constructors及nonmember<br>functions像虚函数一样地作用？如何限制class实体个数？如何阻止对象产生于heap内？如何保证对象产生于heap内？如何能够产生某种对象，使它再某些class的member<br>functions被调用时，自动执行某些动作？如何令不同的对象共享同一份数据结构，却让用户错以为每个对象各自有一份数据？如何区分operator[]的读写用途？如何产生一个虚函数，使其行为视多个对象的动态类型而定？  </p>
<h4 id="条款25：将constructor和non-member-functions虚化"><a href="#条款25：将constructor和non-member-functions虚化" class="headerlink" title="条款25：将constructor和non-member functions虚化"></a>条款25：将constructor和non-member functions虚化</h4><ol>
<li>当你手上有一个对象的pointer或reference，而你不知道该对象的真正类型是什么的时候，你会调用<font color=red>virtual function</font>（<font color=green>虚函数</font>）以完成因类型而异的行为。当你尚未获得对象，但已经知道需要什么类型的时候，你会调用constructor以构造对象。那么virtual constructors是什么？假如设计一个软件，用来处理时事新闻，内容由文字和图形构成。组织如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，时事消息的组件（components），至少一个纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Graphic* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsLetter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewsLetter</span>(istream &amp;str);</span><br><span class="line">    <span class="built_in">NewsLetter</span>(<span class="keyword">const</span> NewsLetter &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent*&gt; components;</span><br><span class="line">    <span class="comment">// 从str读取下一个NLComponent的数据，产生组件并返回一个指向它的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NLComponent* <span class="title">readComponent</span><span class="params">(istream &amp;str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(istream &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (str)</span><br><span class="line">    &#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(<span class="keyword">const</span> NewsLetter &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 迭代遍历rhs的list，运用每个元素的virtual copy constructor，将元素复制</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;NLComponent*&gt;::const_iteraotr it = rhs.components.<span class="built_in">begin</span>();</span><br><span class="line">        it != rhs.components.<span class="built_in">end</span>();</span><br><span class="line">        ++it)</span><br><span class="line">        <span class="comment">// 调用it当前指向rhs.components的元素，然后调用该元素的clone取得副本加到本对象的list尾端</span></span><br><span class="line">        components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <code>readComponent</code>产生了一个崭新的对象，是TextBlock是Graphic视读入的数据而定。由于它产生了新对象，行为仿若constructor，但它能产生不同类型的对象，所以它是一个<font color=red>virtual constructor</font>。<strong>所谓virtual constructor是某种函数，它获得输入，可产生不同类型的对象</strong>。  </li>
<li>有一种特别的virtual constructor——所谓<font color=red>virtual copy constructor</font>。它返回一个指针，指向其调用者的一个新副本。virtual copy constructors通常以copySelf或cloneSelf命名：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLCommponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual copy constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual copy constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Graphic* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  class的virtual copy constructor只是调用真正的copy constructor而已。真正的copy constructor执行的是<font color=red>浅拷贝</font>（<font color=green>shallow copy</font>），virtual copy constructor一样，如果真正的copy constructor执行的是<font color=red>深复制</font>（<font color=green>deep copy</font>），virtual copy constructor亦然。<br>  上述实现手法是利用“虚函数之返回类型”规则中的一个宽松点，它是晚些才被接纳的规则。<font color=red><strong>当derived class重新定义其base class的虚函数时，不再需要得声明与其原本相同的返回类型</strong></font>。<h5 id="将Non-Member-Functions的行为虚化"><a href="#将Non-Member-Functions的行为虚化" class="headerlink" title="将Non-Member Functions的行为虚化"></a>将Non-Member Functions的行为虚化</h5></li>
<li>像constructors无法真正被虚化一样，non-member functions也是。让output操作符虚化（operator&lt;&lt;），获得一个ostream&amp;作为其左端自变量，因此它不可能成为member function（其实可以，但会发生）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;str) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;str) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;str) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line">TextBlock t;</span><br><span class="line">Graphic g;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 此些语法与传统不符，Clients必须把stream对象放在&lt;&lt;左侧</span></span><br><span class="line">t &lt;&lt; cout;</span><br><span class="line">g &lt;&lt; cout;</span><br></pre></td></tr></table></figure>
 如果我们用虚函数（如print）来作为打印，就跟其他类型对象语法不一致了，很不自然。我们需要的是名为<strong>operator&lt;&lt;的non-member function</strong>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;s)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;s, <span class="keyword">const</span> NLComponent &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款26：限制某个class所能产生的对象数量"><a href="#条款26：限制某个class所能产生的对象数量" class="headerlink" title="条款26：限制某个class所能产生的对象数量"></a>条款26：限制某个class所能产生的对象数量</h4><h5 id="允许零个或一个对象"><a href="#允许零个或一个对象" class="headerlink" title="允许零个或一个对象"></a>允许零个或一个对象</h5><ol>
<li>没当产生一个对象，会有constructor被调用。阻止某个对象被产出的方法是将constructor声明为private： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintJob</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob &amp;job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="keyword">const</span> Printer &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintJob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintJob</span>(<span class="keyword">const</span> string &amp;whatToPrint);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">string buffer;</span><br><span class="line">..</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure>
 这个设计由三个成分。第一，Printer class的constructor的属性为private，可以压制对象诞生；第二，全局函数thePrinter被声明为class的一个friend，使thePrinter不受private constructors的约束；第三，thePrinter内含一个static Printer对象，意指只有一个Printer对象被产出。<br> 在此thePrinter的实现代码中，有两个精细的地方值得探讨。<font color=red>第一个细微点</font>是，形成唯一的Printer对象，是<font color=red><strong>函数中的static对象而非class中的staic对象</strong></font>。“class拥有一个static对象意思是：即使从未被用过，它也会被构造（及析构）。相反”函数拥有一个static对象“指的是，此对象在函数第一次被调用才产生。让打印机成为<font color=red>class static</font>而非一个<font color=red>function static</font>有个缺点，那就是不知道它的初始化时机，而function static的初始化实际是确切知道的。<br> <font color=red>第二个细微点</font>是<font color=red><strong>函数的”static对象与inlining的互动“</strong></font>。这个函数未被声明为inline。因为声明static意味着只需要唯一一个对象，但对于inline non-member function其中内含local static对象，意味着你这个函数有内部连接（internal linkage）。你的程序可能会拥有多份该static对象的副本。（新版编译期这个问题已经消除）</li>
</ol>
<h5 id="不同的对象构造状态"><a href="#不同的对象构造状态" class="headerlink" title="不同的对象构造状态"></a>不同的对象构造状态</h5><ol start="2">
<li>或许有人认为使用计数器来限制对象数量更简单。甚至是更一般化，可以使对象的最大数量可以设定为1以外的值。但这策略有问题。当其他对象继承Printer对象或者包含Printer时，就会抛出TooManyObjects exception。除非避免具体类继承其他具体类。问题出在Printer对象可在3种不同状态下生存：（1）<strong>它自己</strong>，（2）<strong>派生物的base class成分</strong>，（3）<strong>内嵌于较大对象之中</strong>。通常你只对上述（1）感兴趣。如果采用原先的策略，很容易达成。因为constructor是private的，如果没有声明任何friend的话，是不能被用来当作base classes的，也不能内嵌于其他对象内。</li>
</ol>
<h5 id="允许对象生生灭灭"><a href="#允许对象生生灭灭" class="headerlink" title="允许对象生生灭灭"></a>允许对象生生灭灭</h5><ol start="3">
<li>知道了对象的constructor可于3种情况下被调用，知道了令constructors成为private可以混淆的对象计数。虽然用thePrinter函数封装起来，虽然限制了Printer对象的个数为1，但也限制了每次执行程序只能有唯一一个Printer对象（？？？），因此不能写出一下代码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create Printer object p1;</span><br><span class="line">use p1;</span><br><span class="line">destroy p1;</span><br><span class="line">create Printer object p2;</span><br><span class="line">use p2;</span><br><span class="line">destroy p2;</span><br></pre></td></tr></table></figure>
 唯一的做法是将稍早的对象计数（object-counting）码和先前所见的伪构造函数(pseudo-constructors）结合起来： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="comment">// pseudo-constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer &amp;rhs)</span></span>;</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob &amp;job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> Printer::maxObjects = <span class="number">10</span>; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="comment">// 不允许拷贝 E27</span></span><br><span class="line">    <span class="built_in">Printer</span>(<span class="keyword">const</span> Printer &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class static</span></span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Printer::maxObjects;</span><br><span class="line"></span><br><span class="line">Printer::<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObjects)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObject</span>();</span><br><span class="line">    proceed with normal object construction here;</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PrinterPrinter</span>(<span class="keyword">const</span> Printer &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObejcts)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer* <span class="title">Printer::makePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Printer; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer* <span class="title">Printer::makePrinter</span><span class="params">(<span class="keyword">const</span> Printer &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Printer</span>(rhs); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// old</span></span><br><span class="line">Printer p1; <span class="comment">// error, default ctor is private</span></span><br><span class="line">Printer *p2 = Printer::<span class="built_in">makePrinter</span>();   <span class="comment">// ok</span></span><br><span class="line">Printer p3 = *p2;   <span class="comment">// error</span></span><br><span class="line">p2-&gt;<span class="built_in">performSelfTest</span>();  <span class="comment">//</span></span><br><span class="line">p2-&gt;<span class="built_in">reset</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p2;  <span class="comment">// 如果p2是smart pointer就不用</span></span><br></pre></td></tr></table></figure>
 这就被泛化伪任意个数（不限一个）的对象，它将原本的常量1改为class专属的一个数值。</li>
</ol>
<h5 id="一个用来计算对象个数的Base-Class"><a href="#一个用来计算对象个数的Base-Class" class="headerlink" title="一个用来计算对象个数的Base Class"></a>一个用来计算对象个数的Base Class</h5><ol start="4">
<li>我们可以轻易完成一个base class，用来当作对象计数来使用，并让Printer之类的classes继承它。确保计算对象的每个class都有各自的计数器。设计一个class template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counted</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObject</span> &#123;</span>&#125;; <span class="comment">// 可能抛出exceptions</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">objectCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numObjects;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Counted</span>();</span><br><span class="line">    <span class="built_in">Counted</span>(<span class="keyword">const</span> Counted &amp;rhs);</span><br><span class="line">    ~<span class="built_in">Counted</span>() &#123; --numObjects; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;    <span class="comment">// 避免ctor重复出现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>()</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>(<span class="keyword">const</span> Counted&lt;BeingCounted&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Counted&lt;BeingCounted&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 修改Printer class，让它运用Counted template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> :</span> <span class="keyword">private</span> Counted&lt;Printer&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// pseudo-constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer &amp;rhs)</span></span>;</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob &amp;job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="keyword">const</span> Printer &amp;rhs);ss</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 Counted的大部分作为都隐藏起来不让Printer的用户知道，但用户可能希望知道有多少个Printer对象存在。Counted template提供了objectCount函数，提供信息。然而该函数在Printer中变成了private访问层级，因为上面用的是private inheritance，<strong>为了恢复public访问层级，采用了using表达式</strong>。关于Counted内的statics义务性定义，只要将： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> Counted&lt;BeingCounted&gt;::numObjects;  <span class="comment">// 定义并自动初始化为0</span></span><br></pre></td></tr></table></figure>
 放进某个Counted的某个实现文件就可以了。而maxObjects则放在Printer作者的某个实现文件中就可以了： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Counted&lt;Printer&gt;::maxObjects = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款27：要求（或禁止）对象产生于heap之中"><a href="#条款27：要求（或禁止）对象产生于heap之中" class="headerlink" title="条款27：要求（或禁止）对象产生于heap之中"></a>条款27：要求（或禁止）对象产生于heap之中</h4><h5 id="要求对象产生于heap之中（Heap-Based-Objects）"><a href="#要求对象产生于heap之中（Heap-Based-Objects）" class="headerlink" title="要求对象产生于heap之中（Heap-Based Objects）"></a>要求对象产生于heap之中（Heap-Based Objects）</h5><ol>
<li>阻止clients不得使用new以外的方法产生对象,这很容易办到,只要让那些被隐式调用的构造动作和析构动作不合法就可以了。把constructors和destructor声明为private就太过了，那么只<strong>将destructors成为private</strong>就可以了。而用一个pseudo destructor函数来调用真正的destructor： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPNumber</span>();</span><br><span class="line">    <span class="built_in">UPNumber</span>(<span class="keyword">int</span> initValue);</span><br><span class="line">    <span class="built_in">UPNumber</span>(<span class="keyword">double</span> initValue);</span><br><span class="line">    <span class="built_in">UPNumber</span>(<span class="keyword">const</span> UPNumber &amp;rhs);</span><br><span class="line">    <span class="comment">// pseudo destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">UPNumber</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UPNumber n; <span class="comment">// error</span></span><br><span class="line">UPNumber *p = <span class="keyword">new</span> UPNumber; <span class="comment">// ok</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// error</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 把constructors声明为private的缺点是，必须记住每一个constructor都声明为private。只要限制destructor或constructors的运用，就可以阻止non-heap objects的诞生，但是，它妨碍了<strong>继承（inheritance）</strong>和<strong>内含（containment）</strong>。这个困难可以克服，只需要将UPNumber的destructor成为protected就可以解决： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonNegativeUPNumber</span> :</span> <span class="keyword">public</span> UPNumber &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Asset</span>(<span class="keyword">int</span> initValue);</span><br><span class="line">    ~<span class="built_in">Asset</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber *value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Asset::<span class="built_in">Asset</span>(<span class="keyword">int</span> initValue) : <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">UPNumber</span>(initValue)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Asset::~<span class="built_in">Asset</span>()</span><br><span class="line">&#123; value-&gt;<span class="built_in">destroy</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断某个对象是否位于heap内"><a href="#判断某个对象是否位于heap内" class="headerlink" title="判断某个对象是否位于heap内"></a>判断某个对象是否位于heap内</h5></li>
<li>没有办法侦测出一个construcotr是不是在heap内。或许可以通过设置标志位，但对于operator new[]来说，设置标志位却只有一次机会设立标志信息，而第二次就会exception。或者是利用系统的一个特点：<strong>stack（栈）高地址往低地址成长，heap（堆）由低地址往高地址成长</strong>。但是这是不可移植的。这个函数的观念很有趣。一个临时stack是个局部变量，它会被放在stack的顶端，而stack向低地址成长，所以这个stack的地址一定比任何一个位于stack中的变量（或对象）更低。因此，如果一个位于heap的对象，其地址一定比临时stack的地址更低。但这个想法不完善，很多系统把static对象放置在heap的底下。<br> 如果真实目的只是为了想知道对象调用delete是否安全，那就跟判断对象是否在heap是两回事了： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">getMemory</span>(size);</span><br><span class="line">    <span class="comment">// add p to the collection of allocated addresses;</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">releaseMemory</span>(ptr); <span class="comment">// free store</span></span><br><span class="line">    <span class="comment">// remove ptr from the collection of allocated addresses;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafeToDelete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return whether address is in collection of allocated addresses</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 operator new负责把一些条目（entires）加到一个由“动态分配而得的地址”所形成的集合中，operator delete负责把这些条目移除；isSafeToDelete负责查找集合，看看地址是否在其中。这些operator new和operator delete函数都在全局范围内，这应该堆所有类型都管用（甚至内置类型）。但这不是我们想要的——当对象存在多重继承或虚拟继承时，可能拥有多地址，这就是<font color=red>非自然多态</font>（<font color=green>unnatural polymorphism</font>）。<br> 我们需要的是一个提供函数机能，但不符带全局命名空间的污染问题、额外的义务性负担，以及正确性的疑惑。那么<font color=green>abstract mixin base class</font>（<font color=red>抽象混合式基类</font>）可以满足需求。抽象基类不能被实例化，因为它至少有一个纯虚函数。mix in class则提供了一组定义好的能力，能与derived class兼容： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapTracked</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">class <span class="title">MissingAddress</span><span class="params">()</span></span>; <span class="comment">// exception class</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HeapTracked</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">void</span> *RawAddress;</span><br><span class="line">    <span class="keyword">static</span> list&lt;RawAddress&gt; addresses;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static class member的义务性定义</span></span><br><span class="line">list&lt;RawAddress&gt; HeapTracked::addresses;</span><br><span class="line"></span><br><span class="line">HeapTracked::~<span class="built_in">HeapTracked</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* HeapTracked::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *memPtr = ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);    <span class="comment">// 取得内存</span></span><br><span class="line">    addresses.<span class="built_in">push_front</span>(memPtr); <span class="comment">// 将地址放到list头部</span></span><br><span class="line">    <span class="keyword">return</span> memPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> HeapTracked::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    list&lt;RawAddress&gt;::iterator it = <span class="built_in">find</span>(address.<span class="built_in">begin</span>(), address.<span class="built_in">end</span>(), ptr);</span><br><span class="line">    <span class="keyword">if</span> (it != address.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        addresses.<span class="built_in">erase</span>(it);</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">MissingAddress</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HeapTracked::isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *rawAddress = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    list&lt;RawAddress&gt;::iterator it = <span class="built_in">find</span>(address.<span class="built_in">begin</span>(), address.<span class="built_in">end</span>(), rawAddress);</span><br><span class="line">    <span class="keyword">return</span> it != addresses.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> :</span> <span class="keyword">public</span> HeapTracked</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inventoryAsset</span><span class="params">(<span class="keyword">const</span> Asset *ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ap-&gt;<span class="built_in">isOnHeap</span>())</span><br><span class="line">        ap is a heap-based asset -- inventory it as such;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        ssap is a non-heap-based asset -- record it that way;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 凡涉及“多重或虚拟基类”的对象，会拥有多个地址，如果写在全局函数就会很复杂，但是isOnHeap只施行于HeapTracked对象身上，所以只要简单的将指针<strong>dynamic_cast</strong>为**void*<strong>（或</strong>const void*<strong>或</strong>volatile void*<strong>或</strong>const volatile void***），就会获得一个指针，指向原指针所指对象的内存起始处。不过dynamic_cast只适用于有至少一个虚函数的指针身上。之所以前面的isSafeToDelete撰写很复杂，就是因为它可以对任何类型起作用，因此dynamic_cast无法帮助它。isOnHeap有所选择（只针对HeapTracked对象的指针）。这个技术有移植性，只要编译器支持dynamic_cast。</li>
</ol>
<h5 id="禁止对象产生于heap之中"><a href="#禁止对象产生于heap之中" class="headerlink" title="禁止对象产生于heap之中"></a>禁止对象产生于heap之中</h5><ol start="3">
<li>一般有3种情况：<ul>
<li> 对象被直接实例化</li>
<li> 对象被实例化为derived class objects内的base class成分</li>
<li>对象被内嵌于其他对象之中。<br>阻止clients直接将对象实例化于heap之中，很容易，只需要将operator new和operator delete声明为private就可以了，如果想禁止对象所组成的数组，可以将operator new[]和operator delete声明为private。</li>
</ul>
</li>
</ol>
<h4 id="条款28：Smart-Pointers（智能指针）"><a href="#条款28：Smart-Pointers（智能指针）" class="headerlink" title="条款28：Smart Pointers（智能指针）"></a>条款28：Smart Pointers（智能指针）</h4><ol>
<li>Smart poinnters是一种像内建指针，却提供了更多机能的对象。当以smart pointers取代C++的内建指针（<strong>dumb pointer</strong>），你会获得各种指针行为的控制权：<ul>
<li><font color=red>构造和析构</font>（<font color=green>Construction and Destruction</font>）。你可以决定smart pointer被产生以及被构造时发生什么事。通常给smart pointers一个默认值0，以避免指针未获初始化。</li>
<li><font color=red>复制和复制</font>（<font color=green>Copying and Assignment</font>）。当一个smart pointer被复制或涉及复制动作时，可以控制发生什么事。</li>
<li><font color=red>解引</font>（<font color=green>Dereferencing</font>）。当client解引（取用）smart pointer所指的对象时，有权决定发生什么事情。<br>Smart pointers由templates产生出来。由于像内建指针一样，所以它必须由强烈的<font color=red>类型性</font>（<font color=green>strongly teyped</font>）。</li>
</ul>
</li>
</ol>
<h5 id="Smart-Pointers的构造、复制、析构"><a href="#Smart-Pointers的构造、复制、析构" class="headerlink" title="Smart Pointers的构造、复制、析构"></a>Smart Pointers的构造、复制、析构</h5><ol start="2">
<li>auto_ptr template可能实现如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_tpr</span>(T *ptr = <span class="number">0</span>) : <span class="built_in">pointee</span>(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 在同一个对象只可被一个auto_ptr拥有的前提下，上述做法有效运转。但一旦auto_ptr被复制或被赋值，会发生什么？会导致两个auto_ptrs指向同一对象。这当在销毁对象时，可能会删除两次，往往会导致未定义。<br> 另一个做法是<strong>以new操作符为所指对象产生一个新副本</strong>。而auto_ptr<T>不得指向一个类型为T的对象，可以指向一个T派生类型的对象。auto_ptr采用了一个富弹性的解法：当auto_ptr被复制或被赋值，其对象拥有权会转移： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt; &amp;rhs); <span class="comment">// copy constructor</span></span><br><span class="line">    auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(auto_ptr&lt;T&gt; &amp;rhs);  <span class="comment">// assignment operator</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">auto_ptr&lt;T&gt;::<span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt; &amp;rhs);</span><br><span class="line">&#123;</span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::<span class="keyword">operator</span>=(auto_ptr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pointee; <span class="comment">// 删除原有的对象</span></span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 由于auto_ptr的copy constructor被调用时，对象拥有权转移了，所以以by value方式转递auto_ptrs往往是个糟糕的主意： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTreeNode</span><span class="params">(ostream &amp;s, auto_ptr&lt;TreeNode&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123; s &lt;&lt; *p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;TreeNode&gt; <span class="title">ptn</span><span class="params">(ew TreeNode)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">printTreeNode</span>(cout, ptn);   <span class="comment">// 以by value传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 当printTreeNode的参数被p初始化（通过auto_ptr的copy constructor），ptn所指的对象拥有权被转移至p。当printTreeNode结束，p离开生存空间，destructor被调用。然而ptn不再指向任何东西，这将产生未定义行为。所以Pass-by-reference-to-const才是适当的途径： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTreeNode</span><span class="params">(ostream &amp;s, <span class="keyword">const</span> auto_ptr&lt;TreeNode&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123; s &lt;&lt; *p; &#125;</span><br></pre></td></tr></table></figure>
 在此函数中，p是个referene而不是对象。所以不会由constructor被用来为p设定初值，ptn将保留拥有权。</li>
</ol>
<h5 id="实现Dereferencing-Operators（解引操作符）"><a href="#实现Dereferencing-Operators（解引操作符）" class="headerlink" title="实现Dereferencing Operators（解引操作符）"></a>实现Dereferencing Operators（解引操作符）</h5><ol start="3">
<li>现在注意力放在smart pointers的核心：operator*和operator-&gt;函数身上： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个函数首先做任何必要的初始化动作或是让pointee获得有效值的任何动作。<br> 检验operator-&gt;前，看一下此函数的不寻常意义： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产生smart ptrs，用来指向分布式数据库（DB）内的对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DBPtr</span>(T *realPtr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DBPtr</span>(DataBaseID id);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来表现数据库中的一笔数据（tuples）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayEditDialog</span><span class="params">()</span></span>;   <span class="comment">// 呈现图形式对话框，供输入tuple</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 检验*this是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class template，用来在T对象被修改时，完成运转记录（log entires）。</span></span><br><span class="line"><span class="keyword">template</span>&lt;classs T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogEntry</span>(<span class="keyword">const</span> T &amp;objectToBeModified);</span><br><span class="line">    ~<span class="built_in">LogEntry</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">editTuple</span><span class="params">(DBPtr&lt;Tuple &amp;pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">LogEntry&lt;Tuple&gt; <span class="title">entry</span><span class="params">(*pt)</span></span>;</span><br><span class="line">    <span class="comment">// 反复显示编辑对话框，知道获得有效值为止</span></span><br><span class="line">    <span class="keyword">do</span> pt-&gt;<span class="built_in">displayEditDialog</span>();</span><br><span class="line">    <span class="keyword">while</span> (pt-&gt;<span class="built_in">isValid</span>() == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中<code>pt-&gt;displayEditDialog();</code>会被编译器解释为：<code>(pt.operator-&gt;())-&gt;displayEditDialog();</code>这个意味着，<strong>不论operator-&gt;返回什么，在该回传值身上施行-&gt;操作符都是合法的</strong>。因此operator-&gt;只能返回两个东西：一个dumb pointer或是一个smart pointer： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">    <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="测试Smart-Pointers是否为NULL"><a href="#测试Smart-Pointers是否为NULL" class="headerlink" title="测试Smart Pointers是否为NULL"></a>测试Smart Pointers是否为NULL</h5><ol start="4">
<li>我们可以产生、销毁、赋值、复制、解引smart pointers。但有一件事没办法做，就是判断是否为NULL： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...        <span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (!ptn) ...       <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 为我们smart pointer class添加一个isNULL很容易，但不自然。另一个做法是，提供一个隐式转换操作符，允许上述测试动作通过编译。<font color=red>这个转换的传统目标是void*</font>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">void</span>*();   <span class="comment">// 如果dumb ptr是null，返回0，否则是非0值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...   <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...        <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">if</span> (!ptn) ...       <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 <strong>这个做法的缺点是，它竟然可以用来对完全不同类型的对象比较</strong>（我好像没出现这样的情况……）！这个问题无法解决，但有个差强人意的做法，允许提供测试nullness的合理语法，并能够将意外引起不同类型之smart pointers相互比较的机会降到最低，那就是将!操作符重载，并在其调用者是null的情况下，返回true： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!ptn) ...   <span class="comment">// ok ptn is null</span></span><br><span class="line"><span class="keyword">else</span> ...        <span class="comment">// ptn is not null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...        <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Apple&gt; pa;</span><br><span class="line">SmartPtr&lt;Orange&gt; po;    </span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!pa == !po) ... <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>
 这个有风险的做法的原因是很少有程序员这么个写法。在C++标准程序库中，隐式转换为void*已被隐式转换为bool取代，而operator bool总是返回operator!的反相。</li>
</ol>
<h5 id="将Smart-Pointers转换为Dumb-Pointers"><a href="#将Smart-Pointers转换为Dumb-Pointers" class="headerlink" title="将Smart Pointers转换为Dumb Pointers"></a>将Smart Pointers转换为Dumb Pointers</h5><ol start="5">
<li>有时候你希望将smart pointers加入已使用的dumb pointers应用软件中， <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(Tuple *pt)</span></span>;  <span class="comment">// by dumb pointer</span></span><br><span class="line"></span><br><span class="line">DBPtr&lt;Tuple&gt; pt;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">normaize</span>(pt);   <span class="comment">// error</span></span><br><span class="line"><span class="built_in">normalize</span>(&amp;*pt);<span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 那个转换动作很难看，如果为smart pointer-to-T template加上隐式类型转换操作符，使之转换为<font color=red>dumb pointer-to-T</font>，先前的调用就能成功。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">operator</span> T*() &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBPtr&lt;Tuple&gt; pt;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">normalize</span>(pt);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 上述函数一加上，nullness测试问题也一并解决了。不过这样的转换也有阴暗面，它式clients得以轻易地直接对dumb pointers做动作，因而回避了smart pointer的最初目的。允许直接适用dumb pointers有灾难，它导致class的计数簿记工作方面的错误。造成引用计数所用的数据结构崩溃。<br> 即使提供了一个隐式转换操作符，smart pointer还是无法完全取代dumb pointer。因为从smart pointer转换为dumb pointer是一种用户定制的转换行为，而<font color=red><strong>编译器禁止一次施行一次以上这类转换</strong></font>。举个例子，有个class，考虑一个函数用来整合两个TupleAccessors对象的信息： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TupleAccessors</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TupleAccessors</span>(<span class="keyword">const</span> Tuple *pt);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TupleAccessors <span class="title">merge</span><span class="params">(<span class="keyword">const</span> TupleAccessors &amp;ta1, <span class="keyword">const</span> TupleAccessors &amp;ta2)</span></span>;</span><br><span class="line"></span><br><span class="line">Tuple *pt1, *pt2;</span><br><span class="line"><span class="built_in">merge</span>(pt1, pt2);    <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">DBPtr&lt;Tuple&gt; pt1, pt2;</span><br><span class="line"><span class="built_in">merge</span>(pt1, pt2);    <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 这是因为从DBPtr<Tuple>转换为TupleAccessors需要两个用户定制转换，而着C++不允许，所以第一个将DBPtr<Tuple>转换为Tuple*，而第二个将需要将Tuple*转环为TupleAccessors）。所以不要提供对dumb pointers的隐式转换操作符，除非不得已。</li>
</ol>
<h5 id="Smart-Pointers和与继承有关的类型转换"><a href="#Smart-Pointers和与继承有关的类型转换" class="headerlink" title="Smart Pointers和与继承有关的类型转换"></a>Smart Pointers和与继承有关的类型转换</h5><ol start="6">
<li>假设有一个public inheritance继承体系，构建出消费性音乐产品： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicProduct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MusicProduct</span>(<span class="keyword">const</span> string &amp;title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cassette</span> :</span> <span class="keyword">public</span> MusicProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cassette</span>(<span class="keyword">const</span> string &amp;title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span> :</span> <span class="keyword">public</span> MusicProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CD</span>(<span class="keyword">const</span> string &amp;title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displalyTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> MusicProduct *pmp, <span class="keyword">int</span> numTimes)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numTimes; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pmp-&gt;<span class="built_in">displayTitle</span>();</span><br><span class="line">        pmp-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dumb pointers的方式没问题，smart pointer取代之则另一种情况了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;MusicProduct&gt; &amp;pmp, <span class="keyword">int</span> numTimes)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;Cassette&gt; <span class="title">funMusic</span><span class="params">(<span class="keyword">new</span> Cassette(<span class="string">&quot;Alapalooza&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CD&gt; <span class="title">nightmareMusic</span><span class="params">(<span class="keyword">new</span> CD(<span class="string">&quot;Disco Hits of the 70s&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">displayAndPlay</span>(funMusic, <span class="number">10</span>);       <span class="comment">// error</span></span><br><span class="line"><span class="built_in">displayAndPlay</span>(nightmareMusic, <span class="number">0</span>);  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 之所以无法通过编译，是因为编译器所看见的是3个互不相干的classs。有个办法可以绕弯解除这一束缚：<strong>令每个smart pointer class有个隐式类型转换操作符，用来转换至另一个smart pointer class</strong>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;</span>Cassette&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()</span><br><span class="line">    &#123; <span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cassette *pointee;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;</span>CD&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()</span><br><span class="line">    &#123; <span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CD *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个做法有两个缺点。第一，必须为每一个“SmartPtr class实例”加入上述例子；第二，需要加上很多这样的转换操作符，因为所指的对象位于继承体系的底层，必须为对象直接继承或间接继承的每个base class提供一个转换函数。由于编译器禁止一次执行一个以上的用户定制类型转换函数，所以无法将<font color=red>smart pointer-to-T</font>转换为一个<font color=red>smart pointer-to-indirect-base-class-of-T</font>。刚好有个语言扩充性质，它可以将nonvirtual member function声明为template，可以用它来产生smart pointer的转换函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template class，用于smart pointer-to-T对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T *realPtr = <span class="number">0</span>);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// template function，用于隐式转换操作符</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">newType</span>&gt;</span></span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;newType&gt;()</span><br><span class="line">    &#123; <span class="keyword">return</span> SmartPtr&lt;newType&gt;(pointee); &#125;</span><br><span class="line">    ,,,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 funMusic对象属于SmartPtr<Cassette>类型，而displayAndPlay函数期望得到一个SmartPtr<MusicProduct>对象。编译器发现类型不吻合，于是企图将funMusic转换其期望的对象。编译器在SmartPtr<MusicProduct> class内企图找一个”单一变量之construcotr“，其自变量类型为SmartPtr<Cassette>，但没有找到；于是企图在SmartPtr<Cassette> class内找一个隐式类型转换操作符，希望产出已给SmartPtr<MusicProduct> class，但也失败了；接下来再试图寻找一个”可实例化以导出合宜转换函数“的member function template。它在SmartPtr<Cassette>找到一个东西，当它被实例化并令newType绑定MusicProduct时，编译器将之实例化，可得： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;Cassette&gt;::<span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;() </span><br><span class="line">&#123; <span class="keyword">return</span> SmartPTr&lt;MusicProduct&gt;(pointee); &#125;</span><br></pre></td></tr></table></figure>
 这其中涵盖的技术不简单，它包括：（1）函数调用的自变量匹配规则、（2）隐式类型转换函数、（3）template functions的暗自实例化、（4）member function templates等技术。</li>
</ol>
<h6 id="Smart-Pointers与const"><a href="#Smart-Pointers与const" class="headerlink" title="Smart Pointers与const"></a>Smart Pointers与const</h6><ol start="7">
<li>const可以修饰被指的东西 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CD <span class="title">goodCD</span><span class="params">(<span class="string">&quot;Flood&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> CD *p;    <span class="comment">// p时non-const指针，指向const CD object</span></span><br><span class="line">CD *<span class="keyword">const</span> p = &amp;goodCD;  <span class="comment">// p是哟个const指针，指向non-const CD object，必须有初值</span></span><br><span class="line"><span class="keyword">const</span> CD *<span class="keyword">const</span> p = &amp;goodCD;    <span class="comment">//p是一个const指针，指向一个const CD object</span></span><br></pre></td></tr></table></figure>
 很自然，我们想要smart pointers也有同样的弹性。但Smart pointer只能有一个地方放置const，只能施行与指针身上，不能及于所指对象，不过我们可以对const以及non-const的对象及指针，产生4种组合： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; p;</span><br><span class="line">Smart&lt;<span class="keyword">const</span> CD&gt; p;</span><br><span class="line"><span class="keyword">const</span> SmartPtr&lt;CD&gt; p = &amp;goodCD;</span><br><span class="line"><span class="keyword">const</span> SmartPtr&lt;<span class="keyword">const</span> CD&gt; p = &amp;goodCD;</span><br></pre></td></tr></table></figure>
 如果适用dumb pionters，可以non-const指针作为const指针的初值，也可以指向non-const独享的指针作为指向const对象指针的初始值，赋值规则类似： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CD *pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CD *pConstCD = pCD;   <span class="comment">// ok</span></span><br><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> CD&gt; pConstCD = pCD;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 类型转换如果涉及const，便是一条单行道：从non-const到const是安全的，从const到non-const是不安全的。解决上面的方法是，将derived class object转换为base class object，令smart pointer-to-T class公开继承一个对应的smart pointer-to-const-T class： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtrToConst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    functions</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in"><span class="keyword">union</span></span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> T *constPointee;</span><br><span class="line">        T *pointee;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class T&gt;</span><br><span class="line">class SmartPtr : <span class="keyword">public</span> SmartPtrToConst&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 运用这个设计，我们获得了自己希望的行为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line">SmartPtrToConst&lt;CD&gt; pConstCD = pCD; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款29：Reference-counting（引用计数）"><a href="#条款29：Reference-counting（引用计数）" class="headerlink" title="条款29：Reference counting（引用计数）"></a>条款29：Reference counting（引用计数）</h4><ol>
<li>Reference counting这项技术，允许多个等值对象共享同一个实值。Reference counting可以消除记录对象拥有权的负荷，因为当对象用reference counting技术，它拥有它自己，一旦没人使用它，便自动销毁自己。因此，reference counting建构出<font color=red>垃圾回收机制</font>（<font color=green>garbage colection</font>）的一个简单形式。</li>
</ol>
<h5 id="Reference-Counting（引用计数）的实现"><a href="#Reference-Counting（引用计数）的实现" class="headerlink" title="Reference Counting（引用计数）的实现"></a>Reference Counting（引用计数）的实现</h5><ol start="2">
<li>基本设计像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span> ... &#125;; <span class="comment">// 包含引用计数和字符串值</span></span><br><span class="line">    StringValue *value; <span class="comment">// value of this String</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 内嵌的结构体StringValue主要用于存储引用计数和字符串值,并使得引用计数和字符串值相关联.StringValue的实现像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue) : <span class="built_in">refCount</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 StringValue只对String类可见,而对客户不可见,接口由String定义并提供给客户。String的构造函数: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue = <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; rhs);</span><br></pre></td></tr></table></figure>
  第一个构造函数的实现较简单,根据传入的char数组构造StringValue对象,然后使String中的指针指向这个String即可:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue): <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">StringValue</span>(initValue))&#123;&#125;</span><br></pre></td></tr></table></figure>
 但这样的实现导致”分开构造,但拥有相同初值的String对象,并不共享同一个数据结构”,因此像这样的代码:    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;More Effective C++&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;More Effective C++&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
 尽管是s1和s2的值相同,但它们却并不共享同一个块内存,而是各自拥有独立内存。<br> 拷贝构造函数可以使用引用计数,并共享内存,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; rhs): <span class="built_in">value</span>(rhs.value)&#123; ++value-&gt;refCount; &#125;</span><br></pre></td></tr></table></figure>
 析构函数负责在引用计数为0的时候撤销内存: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">delete</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 赋值操作符要注意自身赋值的情况: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == rhs.value) &#123; <span class="comment">//处理自身赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">delete</span> value; </span><br><span class="line">    &#125;</span><br><span class="line">    value = rhs.value; </span><br><span class="line">    ++value-&gt;refCount;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="Copy-on-Write（写时才复制）"><a href="#Copy-on-Write（写时才复制）" class="headerlink" title="Copy-on-Write（写时才复制）"></a>Copy-on-Write（写时才复制）</h5><ol start="3">
<li>对operator[]的重载比较复杂:const版本是只读动作,因而只返回指定字符即可,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>&#123; <span class="keyword">return</span> value-&gt;data[index]; &#125;</span><br></pre></td></tr></table></figure>
 但non-const版本面临着被写入新的值的可能,由于对当前String的修改不应影响到共享内存的其他String对象,因此需要先为当前String分配独立内存并将原值进行拷贝,像这样: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char&amp; String::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (value-&gt;refCount &gt; 1) &#123;</span><br><span class="line">        --value-&gt;refCount; </span><br><span class="line">        value =new StringValue(value-&gt;data); </span><br><span class="line">    &#125;</span><br><span class="line">    return value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 不仅是operator[],其他可能改变String对象的操作也应该采取和non-cons版本operator[]相同的动作.这其实是lazy evaluation的一种应用.</li>
</ol>
<h5 id="Pointers-References-以及Copy-on-Write"><a href="#Pointers-References-以及Copy-on-Write" class="headerlink" title="Pointers,References,以及Copy-on-Write"></a>Pointers,References,以及Copy-on-Write</h5><ol start="4">
<li>3中对operator[]的重载解释并解决了可能的写操作篡改共享内存的问题,但是却无法阻止外部指针或引用对共享内存的篡改,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;s1[<span class="number">1</span>];</span><br><span class="line">String s2 = s1;</span><br></pre></td></tr></table></figure>
 对p所指向的内存的任何写操作都会同时更改s1和s2的值,但是s1却对此一无所知,因为p和s1没有内在联系.解决办法并不难:为每一个StringValue对象加一个标志(flag)变量,用表示是否可以被共享,开始时先将flag设为true(可以共享),一旦non-const operator[]被调用就将该flag设为false,并可能永远不许再更改(除非重新为StringValue分配更大内存而导致指针失效),StringValue的修改版像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">bool</span> shareable; </span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue): <span class="built_in">refCount</span>(<span class="number">1</span>),<span class="built_in">shareable</span>(<span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 String的member function在企图使用共享内存前,就必须测试内存是否允许被共享: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.value-&gt;shareable) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        ++value-&gt;refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(rhs.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
 其他返回引用的member function(对于String只有operator[])都涉及到对flag的修改,而其他可能需要共享内存的member function都涉及到对flag的检测。   条款30的proxy class技术可以将operator[]的读和写用途加以区分,从而降低”需被标记为不可共享”之StringValue对象的个数。</li>
</ol>
<h5 id="一个Reference-Counting（引用计数）基类"><a href="#一个Reference-Counting（引用计数）基类" class="headerlink" title="一个Reference-Counting（引用计数）基类"></a>一个Reference-Counting（引用计数）基类</h5><ol start="5">
<li><p>任何要支持内存共享的class都可以使用reference-counting,因此可以考虑把它抽象为一个类,任何需要reference-counting功能的class只要使用这个类即可。  </p>
<p> 第一步就是产生一个base class RCObject,执行引用计数的功能并标记对象是否可被共享,像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RCObject</span>();</span><br><span class="line">    <span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RCObject</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 由于RCObject的作用只是实现引用计数的辅助功能,然后让StringValue继承它,因此StringValue被设为一个抽象基类——通过将析构函数设为纯虚函数,但仍需要为析构函数提供定义.RCObject的实现像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RCObject::<span class="built_in">RCObject</span>(): <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::<span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject&amp;):<span class="built_in">refCount</span>(<span class="number">0</span>),<span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp;)</span><br><span class="line">&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">RCObject::~<span class="built_in">RCObject</span>() &#123;&#125; <span class="comment">// virtual dtors must always</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; shareable = <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> shareable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p> RCObject的实现非常简单,但是其拷贝构造函数和赋值操作符有些特殊——它们的参数没有名字,也就是说参数没有作用,其拷贝构造函数和赋值操作符都只是形式上的:  </p>
<p> RCObjetc拷贝构造函数与RCObject的作用相对应——RCObject一旦被构造,就说明一个新的对象被产生出来,那么RCObject对象本身的初始值和默认构造函数相同,至于refCount设为0而不是1,这要求对象创建者自行将refCount设为1.  </p>
<p> RCObject的赋值操作符什么也不做,仅仅返回*this,因为它不应该被调用,正如之前的StringValue,如果对String对象赋值,那么或者StringValue被共享,或者拷贝构造一个新的StringValue,实际上StringValue的赋值操作永远不会被调用.即使要对StringValue做赋值操作,像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sv1=sv2;<span class="comment">//sv1和sv2是StringValue型对象</span></span><br></pre></td></tr></table></figure>
<p> 指向sv1和sv2的对象数目实际上并未改变,因此sv1的基类部分RCObject什么也不做仍然是正确的.<br> removeReference的责任不仅在于将refCount减1,实际上还承担了析构函数的作用——在refCount=1的时候delete销毁对象,从这里可以看出RCObject必须被产生于heap中.<br> StringValue要直接使用RCObject,像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> StringValue类public继承自RCObject,因此它继承了RCObject的接口并供String使用,StringValue也必须构造在heap中.</p>
</li>
</ol>
<h5 id="自动操作Reference-Count（引用计数）"><a href="#自动操作Reference-Count（引用计数）" class="headerlink" title="自动操作Reference Count（引用计数）"></a>自动操作Reference Count（引用计数）</h5><ol start="6">
<li>RCObject提供了一定程度的代码复用功能,但还远远不够——String类仍然需要手动调用RCObject的成员函数来对引用计数进行更改.解决方法就是”计算机科学领域中大部分问题得以解决的原理”——在中间加一层,也就是在String和StringValue中间加一层智能指针类对引用计数进行管理,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理引用计数的智能指针类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RCPtr</span>(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    ~<span class="built_in">RCPtr</span>();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>; <span class="comment">//将构造函数中的重复操作提取成一个函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 之前RCPtr是一个类模板,String之前有一个StringValue*成员,现在只要将它替换为RCPtr<StringValue>即可.<br> RCPtr的构造函数像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(T* realPtr): <span class="built_in">pointee</span>(realPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr&amp; rhs): <span class="built_in">pointee</span>(rhs.pointee)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> RCPtr&lt;T&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;<span class="built_in">isShareable</span>() == <span class="literal">false</span>) &#123; </span><br><span class="line">        pointee = <span class="keyword">new</span> <span class="built_in">T</span>(*pointee); </span><br><span class="line">    &#125; </span><br><span class="line">    pointee-&gt;<span class="built_in">addReference</span>();<span class="comment">//引用计数的更改负担转移到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 init中使用了new关键字,它调用T的拷贝构造函数,为防止编译器为StringValue合成的拷贝构造函数执行浅复制,需要为StringValue定义执行深度复制的拷贝构造函数,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> StringValue&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, rhs.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 此外,由于多态性的存在,尽管pointee是T*类型,但它实际可能指向T类型的派生类,在此情况下new调用的却是T的拷贝构造函数,要防止这种现象,可以使用virtual copy constructor(见条款25),这里不再讨论</li>
</ol>
<h5 id="把所有努力放到这里"><a href="#把所有努力放到这里" class="headerlink" title="把所有努力放到这里"></a>把所有努力放到这里</h5><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RCPtr</span>(T *realPtr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr &amp;rhs);</span><br><span class="line">    ~<span class="built_in">RCPtr</span>();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr &amp;rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">void</span> RCPtr&lt;T&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;<span class="built_in">isShareable</span>() == <span class="literal">false</span>)</span><br><span class="line">        pointee = <span class="keyword">new</span> <span class="built_in">T</span>(*pointee);</span><br><span class="line">    pointee-&gt;<span class="built_in">addReference</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(T *realPtr) : <span class="built_in">pointee</span>(realPtr) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr &amp;rhs) : <span class="built_in">pointee</span>(rhs.pointee) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;::~<span class="built_in">RCPtr</span>() &#123; <span class="keyword">if</span> (pointee) pointee-&gt;<span class="built_in">removeReference</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *pointee; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee != rhs.pointee)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointee) pointee-&gt;<span class="built_in">removeReference</span>();</span><br><span class="line">        pointee = rhs.pointee;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">RCObject</span>();</span><br><span class="line">    <span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject &amp;rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject &amp;rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RCObject</span>() = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RCObject::<span class="built_in">RCObject</span>() : <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::<span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject&amp;) : <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp;) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">RCObject::~<span class="built_in">RCObject</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span> </span>&#123; shareable == <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> shareable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> :</span> <span class="keyword">public</span> RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> StringValue &amp;rhs);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span></span>;</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::StringValue::<span class="built_in">init</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue) &#123; <span class="built_in">init</span>(initValue); &#125;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> StringValue&amp; rhs) &#123; <span class="built_in">init</span>(rhs.data); &#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>() &#123; <span class="keyword">delete</span> []data; &#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue) : <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">StringValue</span>(initValue)) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> value-&gt;data[index]; &#125;</span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;<span class="built_in">isShared</span>())</span><br><span class="line">        value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(value-&gt;data);</span><br><span class="line">    value-&gt;<span class="built_in">markUnshareable</span>();</span><br><span class="line">    <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="条款30：Proxy-classes（替身类、代理类）"><a href="#条款30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款30：Proxy classes（替身类、代理类）"></a>条款30：Proxy classes（替身类、代理类）</h4><ol>
<li>通过一个类对象来象征一个其他对象，常被称为<font color=green>proxy objects</font>（<font color=red>替身对象</font>）。它允许我们完成某些十分困难或几乎不可能完成的行为。多维数组是其中之一，左值/右值的区分是其中之二，压抑隐式转换是其中之三。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/reasno/p/4858490.html">https://www.cnblogs.com/reasno/p/4858490.html</a></li>
</ol>
<h4 id="条款31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款31：让函数根据一个以上的对象类型来决定如何虚化</h4><ol>
<li>假设设计一个游戏，根据宇宙飞船、太空站和小行星三者的共同特征，设计为以下情况： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">A[SpaceShip] --&gt; S(GameObject) </span><br><span class="line">B[SpaceStation] --&gt; S</span><br><span class="line">C[Asteroid] --&gt; S</span><br></pre></td></tr></table></figure>
 整个继承体系： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> :</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span> :</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span> :</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
 不同对象相撞要有不同的规则，处理碰撞的函数声明像这样： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkForCollision</span><span class="params">(GameObject &amp;object1, GameObject &amp;object2)</span></span>;</span><br></pre></td></tr></table></figure>
 现在挑战出来了，处理他们之间的碰撞，首先得知道它们的动态类型。人们常把面向对象里虚函数的调用动作称为<font color=green>&gt;message dispatch</font>（<font color=red>消息分派</font>）。然而C++并不直接支持multiple dispatch。</li>
</ol>
<h5 id="虚函数-RTTI（运行时期类型识别）"><a href="#虚函数-RTTI（运行时期类型识别）" class="headerlink" title="虚函数 + RTTI（运行时期类型识别）"></a>虚函数 + RTTI（运行时期类型识别）</h5><ol start="2">
<li>最一般化的double-dispatching实现方法是用<font color=red><strong>if-then-elses</strong></font>来仿真虚函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calss SpaceShip : <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果和一个未知类型对象相撞，就抛出以下exception</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollisionWithUnknownObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollisionWithUnknownObject</span>(GameObject &amp;whatWeHit);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject &amp;otherObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type_info &amp;objectType = <span class="built_in"><span class="keyword">typeid</span></span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span> (objectType == <span class="built_in"><span class="keyword">typeid</span></span>(SpaceShip)) &#123;</span><br><span class="line">        SpaceShip &amp;ss = <span class="keyword">static_cast</span>&lt;SpaceShip&amp;&gt;(otherObject);</span><br><span class="line">        <span class="comment">// process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="built_in"><span class="keyword">typeid</span></span>(SpaceStation)) &#123;</span><br><span class="line">        SpaceStation &amp;ss = <span class="keyword">static_cast</span>&lt;SpaceStation&amp;&gt;(otherObject);</span><br><span class="line">        <span class="comment">// process a SpaceShip-SpaceStation collision;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="built_in"><span class="keyword">typeid</span></span>(Asteroid)) &#123;</span><br><span class="line">        Asteroid &amp;a = <span class="keyword">static_cast</span>&lt;Asteroid&amp;&gt;(otherObject);</span><br><span class="line">        <span class="comment">// sprocess a SpaceShip-Asteroid collision;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">CollisionWithUnknownObject</span>(otherObejct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 我们只需要决定碰撞双方的其中一个类型，因为另一个对象是*this，它的类型被虚函数机制决定下来了，是SpaceShip对象。<br> 这种以类型为行事基准的方法有个缺点：它会造成程序难以维护。这就是虚函数当初被发明出来的原因：把生产维护以类型为行事基准的函数的负担，从程序员转到编译器。但现在如果使用RTTI来实现double-dispatching，等于回到老而糟糕的年代。</li>
</ol>
<h5 id="只使用虚函数"><a href="#只使用虚函数" class="headerlink" title="只使用虚函数"></a>只使用虚函数</h5><ol start="3">
<li>看看如何只以虚函数来解决问题： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>;</span>    <span class="comment">// forward declarations</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObjet &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> :</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObjet &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid &amp;otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 这种方法将double-dispatching以两个分离的虚函数调用实现出来的。这并不是递归调用。第一个虚函数调用动作针对的是接收GameObject&amp;参数的collide函数，有点简单： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    otherObject.<span class="built_in">collide</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(SpaceShip &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(SpaceStation &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// processa SpaceShip-SpaceStation collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SpaceShip:<span class="built_in">collide</span>(Asteroid &amp;otherObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// process SpaceShip-Asteroid collision;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 但这种做法成本太高，每次修改需要在每个class中增添（E34）。但它也有好处，那就是不再因为为止类型而不得不抛出异常。</li>
</ol>
<h5 id="自行仿真虚函数表格（Virtual-Function-Tables）"><a href="#自行仿真虚函数表格（Virtual-Function-Tables）" class="headerlink" title="自行仿真虚函数表格（Virtual Function Tables）"></a>自行仿真虚函数表格（Virtual Function Tables）</h5><ol start="4">
<li>回忆条款24，编译器通过vtbl直接索引取得函数指针，而不必条条框框if-then-else运算。这样一来效率也高，也可以当使用RTTI的时候隔离至一个点：vtbl的初始化处。<br> 先从GameObject继承体系内的函数开始： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> :</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(GameObject &amp;spaceShip)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(GameObject &amp;spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(GameObject &amp;asteroid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">typeef <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;string, HitFunctionPtr&gt; HitMap;</span><br><span class="line">    <span class="comment">// 产生中介函数lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> hitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> GameObject &amp;whaWeHit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;      </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceShip</span><span class="params">(SpaceShip &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SpaceShip &amp;otherShip = <span class="keyword">dynamic_cast</span>&lt;SpaceShip&amp;&gt;(spaceShip);</span><br><span class="line">    <span class="comment">// process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceStation</span><span class="params">(SpaceStation &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SpaceStation &amp;station = <span class="keyword">dynamic_cast</span>&lt;SpaceStation&amp;&gt;(spaceStation);</span><br><span class="line">    <span class="comment">// process a SpaceShip-SpaceStation collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitAsteroid</span><span class="params">(Asteroid &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Asteroid &amp;theAsteroid = <span class="keyword">dynamic_cast</span>&lt;Asteroid&amp;&gt;(asteroid);</span><br><span class="line">    <span class="comment">// process a SpaceShip-Asteroid collision;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出调用的函数</span></span><br><span class="line">    HitFunctionPtr hfp = <span class="built_in">lookup</span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span> (hfp) (<span class="keyword">this</span>-&gt;*hfp)(otherObject);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">CollisionWithUnknownObject</span>(otherObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SpaceShip::HitMap* <span class="title">SpaceShip::initializeCollisionMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">    (*phm)[<span class="string">&quot;SpaceShip&quot;</span>] = &amp;hitSapceShip;</span><br><span class="line">    (*phm)[<span class="string">&quot;SpaceStation&quot;</span>] = &amp;hitSpaceStation;</span><br><span class="line">    (*phm)[<span class="string">&quot;Asteroid&quot;</span>] = &amp;hitAsteroid;</span><br><span class="line">    <span class="keyword">return</span> phm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SpaceShip::HitFunctionPtr <span class="title">SpaceShip::lookup</span><span class="params">(<span class="keyword">const</span> GameObject &amp;whatWeHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> auto_ptr&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">    HitMap::iterator mapEntry = collisionMap.<span class="built_in">find</span>(<span class="built_in"><span class="keyword">typeid</span></span>(whatWeHit).<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">if</span> (mapEntry == collisionMap.<span class="built_in">end</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 跟一开始说的RTTI解法一样，GameObject class只含有一个碰撞处理函数，这个函数执行两个必要的<strong>single-dispatches</strong>中的第一个。而其他互动函数不再使用同一个collide名称，放弃了重载。<br> 这里我们需要交付给一个中介函数lookup一个GameObject，它会返回一个指向”当和GameObject相撞时“必须调用的函数的指针（<font  color=red>函数指针</font>）。为了能够动态映射某个member function指针，一个简单的方法是产生一个关系型（associative）数组，只要获得class名字，导出member function指针（key-value？)。</li>
</ol>
<h5 id="将自行仿真的虚函数表格（Virtual-Function-Tables）初始化"><a href="#将自行仿真的虚函数表格（Virtual-Function-Tables）初始化" class="headerlink" title="将自行仿真的虚函数表格（Virtual Function Tables）初始化"></a>将自行仿真的虚函数表格（Virtual Function Tables）初始化</h5><ol start="5">
<li>对于collisionMap的初始化问题，只需要写一个private static member function，名为initializeCollisionMap，用来初始化，然后返回值作为初值就可以了。然而返回值Map按值传递意味着构造和析构成本，如果返回指针，又要苦恼map对象的delete时宜，那么用smart pointer吧(见上面完整实现)。</li>
</ol>
<h5 id="使用”非成员（Non-Member）函数“的碰撞处理函数"><a href="#使用”非成员（Non-Member）函数“的碰撞处理函数" class="headerlink" title="使用”非成员（Non-Member）函数“的碰撞处理函数"></a>使用”非成员（Non-Member）函数“的碰撞处理函数</h5><ol start="6">
<li>当有新的class加入时,继承体系的每个类都需要添加处理新型碰撞的代码.这是因为此前的策略都是将处理碰撞的任务交由碰撞的某一方来执行,仿真虚函数表策略也不例外——每个class内含一个仿真的虚函数表,内含的指针也都指向成员函数。将碰撞处理函数设为non-member,就可以使得class定义式不包含碰撞处理函数,当需要添加碰撞处理函数时也就不需要修改class定义。将碰撞处理函数移出class外，成为中立的第三者处理，则构筑processCollision函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SpaceShip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SpaceStation.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Asteroid.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名namespace具有文件内部static的功效</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要的碰撞处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject &amp;spaceShip, GameObject &amp;asteroid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shipStation</span><span class="params">(GameObject &amp;spaceShip, GameObject &amp;spaceStation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">asteroidStation</span><span class="params">(GameObject &amp;asteroid, GameObject &amp;spaceStation)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 次要的碰撞处理函数，只是为了实现对称性</span></span><br><span class="line"><span class="comment">// 对调参数位置，然后调用主要的碰撞处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">asteroidShip</span><span class="params">(GameObject &amp;asteroid, GameObject &amp;spaceShip)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">shipAsteroid</span>(spaceShip, asteroid); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stationShip</span><span class="params">(GameObject &amp;spaceStation, GameObject &amp;spaceShip)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">shipStation</span>(spaceShip, spaceStation); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stationAsteroid</span><span class="params">(GameObject &amp;spaceStation, GameObject &amp;asetroid)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">asteroidStation</span>(asteroid, spaceSation); &#125;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// types/functions</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> map&lt; pair&lt;string, string&gt;, HitFunctionPtr &gt; HitMap;</span><br><span class="line"><span class="comment">// 以两个char*字面常量产生一个pair&lt;string, string&gt;对象</span></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">makeStringPair</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> pair&lt;string, string&gt;(s1, s2); &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">    (*phm)[<span class="built_in">makeStringPair</span>(<span class="string">&quot;SpaceShip&quot;</span>, <span class="string">&quot;Asteroid&quot;</span>)] = &amp;shipAsteroid;</span><br><span class="line">    (*phm)[<span class="built_in">makeStringPair</span>(<span class="string">&quot;SpaceShip&quot;</span>, <span class="string">&quot;SpaceStation&quot;</span>)] = &amp;shipStation;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> phm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须修改，以便接纳pair&lt;string, string&gt;对象</span></span><br><span class="line"><span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> string class1, <span class="keyword">const</span> string &amp;class2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> auto_ptr&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">    HitMap::iterator mapEntry = collisionMap-&gt;<span class="built_in">find</span>(<span class="built_in">make_pair</span>(class1, class2));</span><br><span class="line">    <span class="keyword">if</span> (mapEntry == collisionMap-&gt;<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processCollision</span><span class="params">(GameObject &amp;object1, GameObject &amp;object2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitFunctinoPtr phf = <span class="built_in">lookup</span>(<span class="built_in"><span class="keyword">typeid</span></span>(object1).<span class="built_in">name</span>(), <span class="built_in"><span class="keyword">typeid</span></span>(object2).<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">if</span> (phf) <span class="built_in">phf</span>(object1, object2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">UnknownCollision</span>(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这份实现和先前的member functions版相同，但略有差异：<ul>
<li><font color=red>HitFunctionPtr</font>如今是一个指向non-member function的指针。</li>
<li><font color=red>exception class CollsionWithUnknownObject</font>已经被重新命名为UnknownCollision并改为取得两个对象。</li>
<li><font color=red>lookup</font>需要接收两个类型名称，并执行double-dispatch的完整两半。</li>
</ul>
 这意味着collision map需要持有三份信息：<strong>两个类型名称和一个HitFunctionPtr</strong>。<br> 由于makeStringPair，initializationCollisionMap，lookup都声明于匿名namespace内，因此它们必须实现于相同的namesapce中，使得<strong>链接器能够正确的将定义和声明关联起来</strong>。<br> <strong>通过将碰撞处理函数从类中分离,实现了即使新的GameObject被添加,原有的class也不需要重新编译,只需要在initializeCollisionMap中增加对应的键-值对,并在processCollision所在的匿名命名空间中申明一个新的碰撞处理函数即可</strong>。</li>
</ol>
<h5 id="”继承“-”自行仿真的虚函数表格“"><a href="#”继承“-”自行仿真的虚函数表格“" class="headerlink" title="”继承“ + ”自行仿真的虚函数表格“"></a>”继承“ + ”自行仿真的虚函数表格“</h5><ol start="7">
<li>目前所做的每一件事都可以有效运作——只要在调用碰撞处理函数时不发生<font color=red><strong>inheritance-based类型转换</strong></font>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">A[SpaceStation] --&gt; G</span><br><span class="line">S(SpaceShip) --&gt; G(GameObject)</span><br><span class="line">B[Asteroid] --&gt; G</span><br><span class="line">C[CommercialShip] --&gt; S</span><br><span class="line">D[MilitaryShip] --&gt; S</span><br></pre></td></tr></table></figure>
 如果MilitaryShip和一个Asteroid碰撞，希望调用的时： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject &amp;spaceShip, GameObject &amp;asteroid)</span></span>;</span><br></pre></td></tr></table></figure>
 然而事非如此，而是抛出一个<font color=red>UnknownCollision exception</font>。虽然MilitaryShip对象可视为一个SpaceShip对象，但lookup并不知道。<br> 如果想要实现double-dispatching而且需要支持inheritance-based参数转换，那么唯一可用的资源是<strong>”双虚函数调用“机制</strong>。</li>
</ol>
<h5 id="将自行仿真的虚函数表格初始化（再度讨论）"><a href="#将自行仿真的虚函数表格初始化（再度讨论）" class="headerlink" title="将自行仿真的虚函数表格初始化（再度讨论）"></a>将自行仿真的虚函数表格初始化（再度讨论）</h5><ol start="8">
<li></li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/More-Effecive-C/" rel="tag"># More Effecive C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/14/4-%E6%95%88%E7%8E%87/" rel="prev" title="4 效率">
      <i class="fa fa-chevron-left"></i> 4 效率
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/14/6-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/" rel="next" title="6 杂项讨论">
      6 杂项讨论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E5%B0%86constructor%E5%92%8Cnon-member-functions%E8%99%9A%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">条款25：将constructor和non-member functions虚化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86Non-Member-Functions%E7%9A%84%E8%A1%8C%E4%B8%BA%E8%99%9A%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">将Non-Member Functions的行为虚化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAclass%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">条款26：限制某个class所能产生的对象数量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E9%9B%B6%E4%B8%AA%E6%88%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.</span> <span class="nav-text">允许零个或一个对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E7%8A%B6%E6%80%81"><span class="nav-number">2.2.</span> <span class="nav-text">不同的对象构造状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E5%AF%B9%E8%B1%A1%E7%94%9F%E7%94%9F%E7%81%AD%E7%81%AD"><span class="nav-number">2.3.</span> <span class="nav-text">允许对象生生灭灭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0%E7%9A%84Base-Class"><span class="nav-number">2.4.</span> <span class="nav-text">一个用来计算对象个数的Base Class</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E8%A6%81%E6%B1%82%EF%BC%88%E6%88%96%E7%A6%81%E6%AD%A2%EF%BC%89%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD"><span class="nav-number">3.</span> <span class="nav-text">条款27：要求（或禁止）对象产生于heap之中</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%81%E6%B1%82%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD%EF%BC%88Heap-Based-Objects%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">要求对象产生于heap之中（Heap-Based Objects）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%BD%8D%E4%BA%8Eheap%E5%86%85"><span class="nav-number">3.2.</span> <span class="nav-text">判断某个对象是否位于heap内</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD"><span class="nav-number">3.3.</span> <span class="nav-text">禁止对象产生于heap之中</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9ASmart-Pointers%EF%BC%88%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">条款28：Smart Pointers（智能指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Smart-Pointers%E7%9A%84%E6%9E%84%E9%80%A0%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9E%90%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">Smart Pointers的构造、复制、析构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Dereferencing-Operators%EF%BC%88%E8%A7%A3%E5%BC%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">实现Dereferencing Operators（解引操作符）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95Smart-Pointers%E6%98%AF%E5%90%A6%E4%B8%BANULL"><span class="nav-number">4.3.</span> <span class="nav-text">测试Smart Pointers是否为NULL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86Smart-Pointers%E8%BD%AC%E6%8D%A2%E4%B8%BADumb-Pointers"><span class="nav-number">4.4.</span> <span class="nav-text">将Smart Pointers转换为Dumb Pointers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Smart-Pointers%E5%92%8C%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9C%89%E5%85%B3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.5.</span> <span class="nav-text">Smart Pointers和与继承有关的类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Smart-Pointers%E4%B8%8Econst"><span class="nav-number">4.5.1.</span> <span class="nav-text">Smart Pointers与const</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9AReference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">条款29：Reference counting（引用计数）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Reference-Counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text">Reference Counting（引用计数）的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Copy-on-Write%EF%BC%88%E5%86%99%E6%97%B6%E6%89%8D%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">Copy-on-Write（写时才复制）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pointers-References-%E4%BB%A5%E5%8F%8ACopy-on-Write"><span class="nav-number">5.3.</span> <span class="nav-text">Pointers,References,以及Copy-on-Write</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E4%B8%AAReference-Counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89%E5%9F%BA%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">一个Reference-Counting（引用计数）基类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9CReference-Count%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89"><span class="nav-number">5.5.</span> <span class="nav-text">自动操作Reference Count（引用计数）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%8A%E6%89%80%E6%9C%89%E5%8A%AA%E5%8A%9B%E6%94%BE%E5%88%B0%E8%BF%99%E9%87%8C"><span class="nav-number">5.6.</span> <span class="nav-text">把所有努力放到这里</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9AProxy-classes%EF%BC%88%E6%9B%BF%E8%BA%AB%E7%B1%BB%E3%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">条款30：Proxy classes（替身类、代理类）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%99%9A%E5%8C%96"><span class="nav-number">7.</span> <span class="nav-text">条款31：让函数根据一个以上的对象类型来决定如何虚化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-RTTI%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">虚函数 + RTTI（运行时期类型识别）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AA%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">只使用虚函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%EF%BC%88Virtual-Function-Tables%EF%BC%89"><span class="nav-number">7.3.</span> <span class="nav-text">自行仿真虚函数表格（Virtual Function Tables）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%EF%BC%88Virtual-Function-Tables%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.4.</span> <span class="nav-text">将自行仿真的虚函数表格（Virtual Function Tables）初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E2%80%9D%E9%9D%9E%E6%88%90%E5%91%98%EF%BC%88Non-Member%EF%BC%89%E5%87%BD%E6%95%B0%E2%80%9C%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">7.5.</span> <span class="nav-text">使用”非成员（Non-Member）函数“的碰撞处理函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%80%9D%E7%BB%A7%E6%89%BF%E2%80%9C-%E2%80%9D%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%E2%80%9C"><span class="nav-number">7.6.</span> <span class="nav-text">”继承“ + ”自行仿真的虚函数表格“</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%86%8D%E5%BA%A6%E8%AE%A8%E8%AE%BA%EF%BC%89"><span class="nav-number">7.7.</span> <span class="nav-text">将自行仿真的虚函数表格初始化（再度讨论）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ichheit</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ichheit</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
