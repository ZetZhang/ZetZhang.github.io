<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="纯虚函数的存在（Presence of a Pure Virtal Function） 纯虚函数的存在(Presence of a Pure Virtual Function) 虚拟规格的存在（Presence of a Virtual Specification） 虚拟规格中const的存在 重新考虑class的声明 5.1 ”无继承”情况下的对象构造 抽象数据类型（Abstract Da">
<meta property="og:type" content="article">
<meta property="og:title" content="第五章 构造、析构、拷贝语意学">
<meta property="og:url" content="http://example.com/2020/06/12/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/index.html">
<meta property="og:site_name" content=".27t_lBZ4oZgg_">
<meta property="og:description" content="纯虚函数的存在（Presence of a Pure Virtal Function） 纯虚函数的存在(Presence of a Pure Virtual Function) 虚拟规格的存在（Presence of a Virtual Specification） 虚拟规格中const的存在 重新考虑class的声明 5.1 ”无继承”情况下的对象构造 抽象数据类型（Abstract Da">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-12T14:59:07.000Z">
<meta property="article:modified_time" content="2021-09-09T07:12:12.701Z">
<meta property="article:author" content="Ichheit">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++对象模型">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/06/12/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第五章 构造、析构、拷贝语意学 | .27t_lBZ4oZgg_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">.27t_lBZ4oZgg_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第五章 构造、析构、拷贝语意学
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-12 22:59:07" itemprop="dateCreated datePublished" datetime="2020-06-12T22:59:07+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 15:12:12" itemprop="dateModified" datetime="2021-09-09T15:12:12+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-06/" itemprop="url" rel="index"><span itemprop="name">2019.06</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%88presence-of-a-pure-virtal-function%EF%BC%89">纯虚函数的存在（Presence of a Pure Virtal Function）</a></li>
<li><a href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%9C%A8(presence-of-a-pure-virtual-function)">纯虚函数的存在(Presence of a Pure Virtual Function)</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E8%A7%84%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%88presence-of-a-virtual-specification%EF%BC%89">虚拟规格的存在（Presence of a Virtual Specification）</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E8%A7%84%E6%A0%BC%E4%B8%ADconst%E7%9A%84%E5%AD%98%E5%9C%A8">虚拟规格中const的存在</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E8%80%83%E8%99%91class%E7%9A%84%E5%A3%B0%E6%98%8E">重新考虑class的声明</a></li>
<li><a href="#5.1-%E2%80%9D%E6%97%A0%E7%BB%A7%E6%89%BF%E2%80%9D%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">5.1 ”无继承”情况下的对象构造</a><ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88abstract-data-type%EF%BC%89">抽象数据类型（Abstract Data Type）</a></li>
<li><a href="#%E4%B8%BA%E7%BB%A7%E6%89%BF%E5%81%9A%E5%87%86%E5%A4%87">为继承做准备</a></li>
</ul>
</li>
<li><a href="#5.2-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">5.2 继承体系下的对象构造</a><ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%88virtual-inheritance%EF%BC%89">虚拟继承（Virtual Inheritance）</a></li>
<li><a href="#vptr%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88the-semantics-of-the-vptr-initialization%EF%BC%89">vptr初始化语意学（The Semantics of the vptr Initialization）</a></li>
</ul>
</li>
<li><a href="#5.3-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88object-copy-semantics%EF%BC%89">5.3 对象复制语意学（Object Copy Semantics）</a></li>
<li><a href="#5.4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%88%E8%83%BD%EF%BC%88object-efficiency%EF%BC%89">5.4 对象的效能（Object Efficiency）</a></li>
<li><a href="#5.5-%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88semantics-of-destruction%EF%BC%89">5.5 析构语意学（Semantics of Destruction）</a></li>
</ul>
<!-- vim-markdown-toc -->
<h5 id="纯虚函数的存在（Presence-of-a-Pure-Virtal-Function）"><a href="#纯虚函数的存在（Presence-of-a-Pure-Virtal-Function）" class="headerlink" title="纯虚函数的存在（Presence of a Pure Virtal Function）"></a>纯虚函数的存在（Presence of a Pure Virtal Function）</h5><ul>
<li>考虑abstract base class声明:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Abstract_base</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _mumble; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这个class被设计为一个抽象的base class(其中有pure virtual function,使得Abstract_base不可能有实例),但需要一个显式的构造函数以初始化data member _mumble。如果没有初始化操作，derived class的局部性对象_mumble及那个无法决定初值。</li>
</ul>
<h5 id="纯虚函数的存在-Presence-of-a-Pure-Virtual-Function"><a href="#纯虚函数的存在-Presence-of-a-Pure-Virtual-Function" class="headerlink" title="纯虚函数的存在(Presence of a Pure Virtual Function)"></a>纯虚函数的存在(Presence of a Pure Virtual Function)</h5><ul>
<li>pure virtual function只能被<font color=red>静态地调用</font>（<font  color=green>invoked statically</font>），不能经由虚拟机制调用。<strong>而pure virtual destructor，class设计者一定得定义它。因为每个derived class class以及base class destructor。只要缺乏定义，就会导致链接失败</strong>。</li>
</ul>
<h5 id="虚拟规格的存在（Presence-of-a-Virtual-Specification）"><a href="#虚拟规格的存在（Presence-of-a-Virtual-Specification）" class="headerlink" title="虚拟规格的存在（Presence of a Virtual Specification）"></a>虚拟规格的存在（Presence of a Virtual Specification）</h5><ul>
<li>如果决定把Abstract_base::mumble()设计为virtual function，那是糟糕的选择，因为其函数定义内容并不与类型有关，因而几乎不会被后继的derived class改写。</li>
</ul>
<h5 id="虚拟规格中const的存在"><a href="#虚拟规格中const的存在" class="headerlink" title="虚拟规格中const的存在"></a>虚拟规格中const的存在</h5><ul>
<li>决定要给virtual function是否需要const，是一件繁琐的事情。如果声明为const，意味着subclass实例可能被无穷次数地使用。不把函数声明为const，意味和函数不能获得一个const reference或const pointer。头大的是，声明函数为const，才发现derived instance必须修改某一data member。解决办法就是不再用const就是了。</li>
</ul>
<h5 id="重新考虑class的声明"><a href="#重新考虑class的声明" class="headerlink" title="重新考虑class的声明"></a>重新考虑class的声明</h5><ul>
<li>综上所述，这才是比较适当的一种设计：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Abstract_base</span>();   <span class="comment">// nonpure virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">// nonconst</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _mumble; &#125; <span class="comment">// nonvirtual</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Abstract_base</span>(<span class="keyword">char</span> *pc =ss <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-1-”无继承”情况下的对象构造"><a href="#5-1-”无继承”情况下的对象构造" class="headerlink" title="5.1 ”无继承”情况下的对象构造"></a>5.1 ”无继承”情况下的对象构造</h4><ul>
<li><p>考虑程序片段：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Point global;                   <span class="comment">//1</span></span><br><span class="line">                                <span class="comment">//2</span></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span>                  <span class="comment">//3</span></span></span><br><span class="line"><span class="function"></span>&#123;                               <span class="comment">//4</span></span><br><span class="line">    Point local;                <span class="comment">//5</span></span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;    <span class="comment">//6</span></span><br><span class="line">    *heap = local;              <span class="comment">//7 </span></span><br><span class="line">    <span class="comment">// ... stuff ...            //8</span></span><br><span class="line">    <span class="keyword">delete</span> heap;                <span class="comment">//9</span></span><br><span class="line">    <span class="keyword">return</span> local;               <span class="comment">//10</span></span><br><span class="line">&#125;                               <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
<p>  L1、L5、L6分别为：<strong>global内存配置</strong>、<strong>local内存配置</strong>和<strong>heap内存配置</strong>。一个object的声明，是该object的一个执行期属性。local object的生命从L5定义开始，L10为止。global object的生命和这个程序的生命相同。heap object的生命从被new运算符配置出来开始，到delete运算符摧毁结束。<br>  下面是Point的第一次声明，写成C程序。这是一种Plain OI’ Data声明形式：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">    Point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果用C++来编译这代码，<strong>编译器会为Point声明一个trivial default constructor、一个trivial destructor、一个trivial copy constructor，以及一个trivial copy assignment operator</strong>。但实际上，编译器会分析这个声明，并<font color=red>贴上POD标签</font>。</p>
</li>
<li><p>当编译器遇到这样的定义：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global;                   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>  观念上Point的trival constructor和destructor会被产生并调用，constructor在程序起始（<font color=red>startup</font>）被调用，而destructor在程序的<font color=red>exit()</font>处被调用。然而事实上trivial members要么没定义，要么没被调用。<br>  在C中，global被视为一个<font color=red>临时性的定义</font>，因为它没有显式的初始化操作。它可以在程序中发生多次。实例<strong>会被折叠起来，只留下一个，放在程序data segment中</strong>。这块空间称为<font color=red><strong>BSS</strong></font>，这是Block Started by Symbol缩写。<br>  C++并不支持临时性定义。虽然它可以判断class object或是POD。global在C++中被视为完全定义（会阻止多个定义）。C和C++的差异是，BSS data segment在C++中相对不重要。<font color=red><strong>所有的全局变量都被以“初始化过的数据”来对待</strong></font>。<br>  至于foobar()函数的L5，既没有构造也没有被析构，不过可能没有经过初始化就会成BUG（L7）。至于heap object：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point *heap = <span class="keyword">new</span> Point;    <span class="comment">//6</span></span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line">Point *heap = __new(<span class="built_in"><span class="keyword">sizeof</span></span>(Point));</span><br><span class="line"><span class="comment">// 有初始化过就没问题</span></span><br><span class="line">*heap = local;              <span class="comment">//7 </span></span><br></pre></td></tr></table></figure>
<p>  事实上L7会产生编译警告，观念上，这样的指定操作会触发trivial copy assignment operator做拷贝搬运操作。而实际上object是POD，所以assignment只是像C那样纯粹bitwise搬运。</p>
</li>
</ul>
<h5 id="抽象数据类型（Abstract-Data-Type）"><a href="#抽象数据类型（Abstract-Data-Type）" class="headerlink" title="抽象数据类型（Abstract Data Type）"></a>抽象数据类型（Abstract Data Type）</h5><ul>
<li>以下是Point声明，提供了完整封装性，但没有提供virtual function：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>) : _x(x), _y(y), _z(z) &#123;&#125;</span><br><span class="line">    <span class="comment">// no copy constructor, copy operator</span></span><br><span class="line">    <span class="comment">// or destructor defined ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这里还是三个连续的float，不论private或public存取层或是member function都不会占用额外的对象空间。没有定义copy constructor或copy operator，因为有<strong>default bitwise semantics</strong>足够了，也不需要destructor。对于实例：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global; <span class="comment">// Point::Point(0.0, o.0, 0.0);</span></span><br></pre></td></tr></table></figure>
  有了default constructor，global被定义在全局范畴，初始化操作将延迟到程序启动（startup）。<br>  如果要将class中的所有成员设定常量初值，给予一个<font color=red>explicit initialization list</font>会比较有效率（相比constructor的inline expansion而言）。但它有三项缺点：<ol>
<li>只有当class members都是public，才会奏效。</li>
<li>只能指定常量，因为在编译器就能评估求值。</li>
<li>由于编译器并不自动施行，初始化行为可能性很高。</li>
</ol>
</li>
</ul>
<h5 id="为继承做准备"><a href="#为继承做准备" class="headerlink" title="为继承做准备"></a>为继承做准备</h5><ul>
<li>第三个Point声明，为继承性质和某些操作的<font color=red>动态决议</font>（<font color=green>dynamic resolution</font>）做准备，目前限制z成员做存取操作：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// no destructor, copy constructor, or</span></span><br><span class="line">    <span class="comment">// copy operator defined ... </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  virtual functions的导入在这里附带一个virtual destructor的声明在这个例子里，并无好处。除此之外，每个class object多负担一个vptr之外，virtual function的导入也引发编译器对Point class产生的膨胀作用：<ul>
<li><strong>定义的constructor附带了一些代码，以便vptr初始化</strong>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="function">Point* <span class="title">Point::Point</span><span class="params">(Point *<span class="keyword">this</span>, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> : _x(x), _y(y)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="comment">// 设定object的vptr</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point = __vtbl__Point;</span><br><span class="line">    <span class="comment">// 扩展member initialization list</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_y = y;</span><br><span class="line">    <span class="comment">// 传回this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>合成一个copy constructor和copy assignment operator，而且操作不是trivial（implicit destructor仍然是）</strong>。如果Point object被初始化或以derived class object赋值，那么以为基础（bitwise）的操作可能对vptr带来非法设定：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="comment">// copy constructor 内部合成</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point* <span class="title">Point::Point</span><span class="params">(Point*<span class="keyword">this</span>, <span class="keyword">const</span> Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// object的vptr</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point = __vtbl__Point;</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器在优化状态会把object内容连续拷贝到另一个object，而不是精准memberwise。<strong>L7的memberwise赋值操作可能出发copy assignment operator的合成，及调用<font color=red>inline expansion</font>（行内扩张）：以this取代heap，以rhs取代local</strong>。<br>戏剧性的冲击在L10。由于copy constructor的出现，foobar()可能转化为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    local.Point::<span class="built_in">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// heap</span></span><br><span class="line">    <span class="comment">// copy constructor</span></span><br><span class="line">    __result.Point::<span class="built_in">Point</span>(local);</span><br><span class="line">    <span class="comment">// local destructor</span></span><br><span class="line">    <span class="comment">// Point::derstructor</span></span><br><span class="line">    <span class="comment">// local.Point::~Point();</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果NRV优化，转化为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __result.Point::<span class="built_in">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// heap</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a>5.2 继承体系下的对象构造</h4><ul>
<li><p>当定义一个object：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T object;</span><br></pre></td></tr></table></figure>
<p>  如果T有constructor，它会被调用。除此之外，constructor调用伴随了什么？constructor可能内含大量隐藏码，因为<font color=red><strong>编译器会扩充每个constructor</strong></font>：</p>
<ol>
<li>在member initialization list中的data members初始化操作会被放进constructor函数本体，以声明顺序为顺序。</li>
<li>如果member没有在member initialization list中，但这个member有default constructor，那么被调用。</li>
<li>在那之前，如果class object有vptr，必须被设定初值指向适当vtbls。</li>
<li>在那之前，base class constructors必须被调用，以base class声明顺序为顺序。<ul>
<li><strong>如果base class被列入member initialization list中，那么任何显式参数都传递进去</strong>。</li>
<li><strong>如果base class没有被列入member initialization list中，而它有default constructor（或default memberwie copy constructor），那么调用它</strong>。</li>
<li><strong>如果base class是多层继承下的第二或后继base class，那么调整this指针</strong>。</li>
</ul>
</li>
<li>在那之前，所有virtual base class constructors必须被调用，从左到右，从深到浅：<ul>
<li><strong>如果class被列入member initialization list中，那么任何显式指定的参数，都传递进去。如果没有列入list中，而class有default constructor，调用它</strong>。</li>
<li><strong>class中的每个virtual base class subobject的偏移地址（offset）必须在执行期可被存取</strong>。</li>
<li><strong>如果class object是最底层（most-derived）的class，其constructors可能被调用；用以支持者行为的机制必须放出来</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p>以Point为例，探讨constructors扩充的必要性：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp;);            <span class="comment">// copy constructor</span></span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;); <span class="comment">// copy assignment operator</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();               <span class="comment">// virtual derstructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point _begin, _end;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Point&amp;);</span><br><span class="line">    <span class="built_in">draw</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  。。。。。。。。</p>
</li>
</ul>
<h5 id="虚拟继承（Virtual-Inheritance）"><a href="#虚拟继承（Virtual-Inheritance）" class="headerlink" title="虚拟继承（Virtual Inheritance）"></a>虚拟继承（Virtual Inheritance）</h5><ul>
<li>考虑下面虚拟继承，继承自Point：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>) : <span class="built_in">Point</span>(x, y), _z(z) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">const</span> Point3d &amp;rhs) : <span class="built_in">Point</span>(rhs), _z(rhs._z) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Point3</span>();</span><br><span class="line">    Point3d&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point3d&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _z; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  传统的constructor扩充并没有用，因为virtual base class的共享性之故：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="function">Point3d* <span class="title">Point3d::Point3d</span><span class="params">(Point3d *<span class="keyword">this</span>, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Piont3d = __vtbl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d__Point = __vtbl_Point3d_Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  看出什么错误了吗？  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Point3d -- virtual --- Point</span><br><span class="line">Vertex -- virtual --- Point</span><br><span class="line">Vertex3d -- public --- Point3d</span><br><span class="line">Vertex3d -- public --- Vertex</span><br><span class="line">pVertex -- public --- Vertex3d</span><br></pre></td></tr></table></figure>
  Vertex的constructor必须调用Point constrcutor。然而当Point3d和Vertex为Vertex3d的subobjects时，则调用操作不一定发生。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point3d的constructor扩充内容</span></span><br><span class="line"><span class="function">Point3d* <span class="title">Point3d::Point3d</span><span class="params">(Point3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__most_derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d = __vtbl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d__Point = __vtbl_Point3d__Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_Z = ths._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  Vertex3d调用Point3d和Vertex的constructor时，会把__most_derived参数设为false，于是就压制了对两个constructors中对Point constructor的调用操作。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vertex3d* <span class="title">Vertex3d::Vertex3d</span><span class="params">(Vertex3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__most_derived != <span class="literal">false</span>) </span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point3d::<span class="built_in">Point3d</span>(<span class="literal">false</span>, x, y, z);</span><br><span class="line">        <span class="keyword">this</span>-&gt;Vertex::<span class="built_in">Vertex</span>(<span class="literal">false</span>, x, y);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  这个策略得以保持语义正确。当定义一个<strong>Point3d</strong>时，Point3d constructor可以正确调用Point virtual base class subobject。当定义<strong>Vertex3d时</strong>时，Vertex3d constructor正确调用Point constructor。Point3d和Vertex的constructor不会对Point调用。这种把一个constructor分裂为二的做法，可以带来速度的提升。？？</li>
</ul>
<h5 id="vptr初始化语意学（The-Semantics-of-the-vptr-Initialization）"><a href="#vptr初始化语意学（The-Semantics-of-the-vptr-Initialization）" class="headerlink" title="vptr初始化语意学（The Semantics of the vptr Initialization）"></a>vptr初始化语意学（The Semantics of the vptr Initialization）</h5><ul>
<li>当我们定义PVertex object时，constructors的调用顺序是：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>(x, y);</span><br><span class="line"><span class="built_in">Point3d</span>(x, y, z);</span><br><span class="line"><span class="built_in">Vertex</span>(x, y, z);</span><br><span class="line"><span class="built_in">Vertex3d</span>(x, y, z);</span><br><span class="line"><span class="built_in">PVertex</span>(x, y, z);</span><br></pre></td></tr></table></figure>
</li>
<li>假设继承体系中每个class都定义一个virtual function size()，返回class的大小。而这个继承体系中的每个constructors内含调用操作：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point3d::<span class="built_in">Point3d</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) : _x(x), _y(y), _z(z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (spyOn)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Within Point3d::Piont3d()&quot;</span> &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; <span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <strong>在一个class的constructor（和destructor）中，经由构造中的对象来调用virtual function，其函数实例是在此class中有作用的那个</strong>。如果调用操作限制必须在constructor（或destructor）中直接调用，那么答案十分明显；将每个调用以静态方式决议它，不要用到虚拟机制。如果是在Point3d constructor中，就显式调用Point3d::size()。  </li>
<li>如果size()之中又调用一个virtual function，这个调用也必须决议为Point3d的函数实例。因此在执行constructor时，必须限制一组virtual functions候选名单。为了控制class中有所作用的函数，编译系统需要控制住vptr的初始化和设定操作，vptr初始化操作怎么处理，得视vptr在constructor中应该在什么时候被初始化而定。 <strong>在base class constructors调用操作之后，在member iniaialization list中members初始化操作前</strong>。它解决了class中限制一组virtual functions名单的问题。如果每个constructor都一直等待其base class constructors执行完毕之后才设定对象的vptr，那么每次都能调用正确的virtual function实例。<br><font color=red>constructor的执行算法</font>通常如下：<ol>
<li><strong>在derived class constructor中，所有virtual base classes及上层base class的constructors会被调用</strong>。</li>
<li>**对象的vptr(s)会被初始化，指向相关virtual table(s)**。</li>
<li><strong>如果有member initialization list，将在constructor内扩展开来</strong>。这在vptr被设定之后才做，以免virtual member function被调用。</li>
<li><strong>最后才执行程序员所提供的代码</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PVertex::<span class="built_in">PVertex</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) : _next(<span class="number">0</span>), <span class="built_in">Vertex3d</span>(x, y, z), <span class="built_in">Point</span>(x, y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (spyOn)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Within PVertex::PVertex()&quot;</span> &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; <span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="function">PVertex* <span class="title">PVertex::PVertex</span><span class="params">(PVertex *<span class="keyword">this</span>, <span class="keyword">bool</span> __most__derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 条件式地调用virtual base constructor</span></span><br><span class="line">    <span class="keyword">if</span> (__most__derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 无条件调用上一层base</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex3d::<span class="built_in">Vertex3d</span>(x, y, z);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将相关的vptr初始化</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_PVertex = __vtbl_PVertex;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point__PVertex = __vtbl_Point__PVertex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 程序员缩写的代码</span></span><br><span class="line">    <span class="keyword">if</span> (spyOn)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Within PVertex::PVertex()&quot;</span> </span><br><span class="line">            &lt;&lt; <span class="string">&quot;size: &quot;</span></span><br><span class="line">            <span class="comment">// 经由虚拟机制调用</span></span><br><span class="line">            &lt;&lt; (*<span class="keyword">this</span>-&gt;__vptr__PVertex[<span class="number">3</span>].faddr)(<span class="keyword">this</span>)</span><br><span class="line">            &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 传回被构造的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>下面是vptr必须被设定的两种情况：<ol>
<li>当一个完整的对象被构造起来时。如果我们声明一个Point对象，则Point constructor必须设定其vptr。</li>
<li>当一个subobject constructor调用一个virtual function（不论是直接调用还是间接调用）时。<br>p218</li>
</ol>
</li>
</ul>
<h4 id="5-3-对象复制语意学（Object-Copy-Semantics）"><a href="#5-3-对象复制语意学（Object-Copy-Semantics）" class="headerlink" title="5.3 对象复制语意学（Object Copy Semantics）"></a>5.3 对象复制语意学（Object Copy Semantics）</h4><ul>
<li><p>当我们设计一个class，并以一个class object指定给另一个class object时，我们有三种<font color=red>选择</font>：</p>
<ol>
<li><strong>什么都不做，施行默认行为</strong>。</li>
<li><strong>提供一个explicit copy assignment operator</strong>。</li>
<li><strong>显式地拒绝把一个class object指定给另一个class object</strong>。</li>
</ol>
<p>  当选择不准将一个class object指定给另一个class object时，只要<strong>把copy assignment operator声明为priavte，并且不提供其定义</strong>就可以了。设为private，就不再允许于任何地点（除了在<font color=red>member functions</font>以及该<font color=red>class的friends之中</font>）做<font color=red>赋值</font>（<font color=green>assign</font>）操作。</p>
</li>
<li><p>需要验证copy assignment operator的语意，利用Point class来帮助讨论：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Piont</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// ... 没有virtual function</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对于默认行为是否足够，如果要支持的只是一个简单的拷贝操作，那么默认行为不但足够而且有效率，而且没有理由再自己提供一个copy assignment operator。<br>  如果不对Point供应一个copy assignment operator，光是以来memberwise copy，编译器不会产生实例。编译器不会产生出一个实例，因为<strong>class有了bitwise copy语义，所以implicit copy assignment operator被视为毫无用处，也不会被合成出来</strong>。copy assignment operators并不表示bitwisecopy semantics是nontrivial，只有nontrivial instances才会被合成出来。因此，对于Point class，这样的赋值操作：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point a, b;</span><br><span class="line">...</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>
<p>  由bitwise copy完成，期间并没有copy assignment oeprator被调用。注意，我们还是可能提供一个copy constructor，为的是把<font color=green>name return value</font>（<font color=red>NRV</font>）优化打开。copy constructor的出现不意味着也也要提供一个copy assignment operator。</p>
</li>
<li><p>如果该operator在继承之下呢？</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point&amp; Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    _x = p._x;</span><br><span class="line">    _y = p._y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚拟继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果没有定义copy assignmnet operator，根据合成规则的第二项和第四项。合成的东西看起来这样：</span></span><br><span class="line"><span class="keyword">inline</span> Point3d&amp; Point3d::<span class="keyword">operator</span>=(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Piont3d &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// call base class</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// memberwise copy the derived class members</span></span><br><span class="line">    _z = p._z;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  它缺乏一个member assignment list（平行于member initialization list的东西）。缺少copy assignment list，看起来是小事，但如果没有它，编译器一般就没有办法压抑上一层base class的copy operators被调用。例如Vertex copy operator，Vertex虚拟继承自Point：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Vertex : virtual public Point</span></span><br><span class="line"><span class="keyword">inline</span> Vertex&amp; Vertex::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    _next = v._next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从Point3d和Vertex派生Vertex3d，下面是其copy assignment operator</span></span><br><span class="line"><span class="keyword">inline</span> Vertex3d&amp; Vertex3d::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex3d &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::oeprator=(v);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  编译器怎么能在Point3d和Vertex的copy assignment operators中压抑Point的copy assignment operators呢？有一种方法可以保证most-derived class会（完成）virtual base class subobject的copy行为，就是在derived class的copy assignment operator函数实例的最后，显式调用oeprator：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex3d&amp; Vertex3d::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex3d &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::oeprator=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::oeprator=(v);</span><br><span class="line">    <span class="comment">// must place this last if your compiler does</span></span><br><span class="line">    <span class="comment">// not suppress intermediate class invocations</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  它不能够省略subobjects的多重拷贝，但可以保证语意。建议尽可能不要允许一个virtual base class的拷贝操作，甚至一个比较奇怪的建议：不要在任何virtual base class中声明数据。</p>
</li>
</ul>
<h4 id="5-4-对象的效能（Object-Efficiency）"><a href="#5-4-对象的效能（Object-Efficiency）" class="headerlink" title="5.4 对象的效能（Object Efficiency）"></a>5.4 对象的效能（Object Efficiency）</h4><ul>
<li>测试。</li>
</ul>
<h4 id="5-5-析构语意学（Semantics-of-Destruction）"><a href="#5-5-析构语意学（Semantics-of-Destruction）" class="headerlink" title="5.5 析构语意学（Semantics of Destruction）"></a>5.5 析构语意学（Semantics of Destruction）</h4><ul>
<li><p>如果class没有定义destructor，那么只有在class内含的member object（抑或是class的base class）拥有destructor的情况下，编译器才会自动合成一个来。当从父类派生子类（即使是一种虚拟派生关系）时，如果没有声明一个estructor，编译器就没有必要合成一个destructor。没有任何理由说在delete一个对象之前得先讲内容清除干净。在一个对象的生命之前，没有任何class使用层面的程序操作是必要的，因此也就不需要要给destructor。  </p>
</li>
<li><p>一个由程序员定义的<font color=red><strong>destructor被扩展的方式类似constructors被扩展的方式</strong></font>，但顺序相反：</p>
<ol>
<li><strong>destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设（reset）</strong>。</li>
<li><strong>如果class拥有member classs objects，而后者会拥有destructors，那么它们会以生命顺序的相反顺序被调用</strong>。</li>
<li><strong>如果object内含一个vptr，那么首先重设（reset）相关的vtbl。指向适当的base class的vtbl</strong>。</li>
<li><strong>如果由任何直接的（上一层）nonvirtual base classes拥有destrucotr，它们会以其声明顺序的相反顺序被调用</strong>。</li>
<li><strong>如果有任何virtual base classes拥有destructor，那么也会以原来的构造顺序的相反顺序被调用</strong>。</li>
</ol>
</li>
<li><p>跟constructor一样，对destructor的一种最佳实现策略就是维护两份destrucotr实例：</p>
<ol>
<li>一个complete object实例，先设定好vptr(s)，并调用virtual base classes destructors。</li>
<li>一个base class subobject实例：除非在destructor函数中调用一个virtual function，否则不会调用virtual base class destructors并设定vptr。</li>
</ol>
</li>
<li><p><font color=red>一个object的声明结束于其destructor开始执行之时</font>。    </p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/" rel="tag"># C++对象模型</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6/" rel="prev" title="第四章 Function语意学">
      <i class="fa fa-chevron-left"></i> 第四章 Function语意学
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/12/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/" rel="next" title="第六章 执行期语意学">
      第六章 执行期语意学 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%88Presence-of-a-Pure-Virtal-Function%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">纯虚函数的存在（Presence of a Pure Virtal Function）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%9C%A8-Presence-of-a-Pure-Virtual-Function"><span class="nav-number">2.</span> <span class="nav-text">纯虚函数的存在(Presence of a Pure Virtual Function)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%A7%84%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%88Presence-of-a-Virtual-Specification%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">虚拟规格的存在（Presence of a Virtual Specification）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%A7%84%E6%A0%BC%E4%B8%ADconst%E7%9A%84%E5%AD%98%E5%9C%A8"><span class="nav-number">4.</span> <span class="nav-text">虚拟规格中const的存在</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E8%80%83%E8%99%91class%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">5.</span> <span class="nav-text">重新考虑class的声明</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E2%80%9D%E6%97%A0%E7%BB%A7%E6%89%BF%E2%80%9D%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="nav-number"></span> <span class="nav-text">5.1 ”无继承”情况下的对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Abstract-Data-Type%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">抽象数据类型（Abstract Data Type）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E7%BB%A7%E6%89%BF%E5%81%9A%E5%87%86%E5%A4%87"><span class="nav-number">2.</span> <span class="nav-text">为继承做准备</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="nav-number"></span> <span class="nav-text">5.2 继承体系下的对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%88Virtual-Inheritance%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">虚拟继承（Virtual Inheritance）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#vptr%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88The-Semantics-of-the-vptr-Initialization%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">vptr初始化语意学（The Semantics of the vptr Initialization）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88Object-Copy-Semantics%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">5.3 对象复制语意学（Object Copy Semantics）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%88%E8%83%BD%EF%BC%88Object-Efficiency%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">5.4 对象的效能（Object Efficiency）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88Semantics-of-Destruction%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">5.5 析构语意学（Semantics of Destruction）</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ichheit</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ichheit</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
