<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("https://zetzhang.github.io/"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content=".27t_lBZ4oZgg_">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content=".27t_lBZ4oZgg_">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ichheit">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>.27t_lBZ4oZgg_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">.27t_lBZ4oZgg_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/5-%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/5-%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">5 技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:52:07" itemprop="dateCreated datePublished" datetime="2020-06-14T13:52:07+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-03/" itemprop="url" rel="index"><span itemprop="name">2019.03</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E5%B0%86constructor%E5%92%8Cnon-member-functions%E8%99%9A%E5%8C%96">条款25：将constructor和non-member functions虚化</a><ul>
<li><a href="#%E5%B0%86non-member-functions%E7%9A%84%E8%A1%8C%E4%B8%BA%E8%99%9A%E5%8C%96">将Non-Member Functions的行为虚化</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E9%99%90%E5%88%B6%E6%9F%90%E4%B8%AAclass%E6%89%80%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%95%B0%E9%87%8F">条款26：限制某个class所能产生的对象数量</a><ul>
<li><a href="#%E5%85%81%E8%AE%B8%E9%9B%B6%E4%B8%AA%E6%88%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">允许零个或一个对象</a></li>
<li><a href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E7%8A%B6%E6%80%81">不同的对象构造状态</a></li>
<li><a href="#%E5%85%81%E8%AE%B8%E5%AF%B9%E8%B1%A1%E7%94%9F%E7%94%9F%E7%81%AD%E7%81%AD">允许对象生生灭灭</a></li>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%94%A8%E6%9D%A5%E8%AE%A1%E7%AE%97%E5%AF%B9%E8%B1%A1%E4%B8%AA%E6%95%B0%E7%9A%84base-class">一个用来计算对象个数的Base Class</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E8%A6%81%E6%B1%82%EF%BC%88%E6%88%96%E7%A6%81%E6%AD%A2%EF%BC%89%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD">条款27：要求（或禁止）对象产生于heap之中</a><ul>
<li><a href="#%E8%A6%81%E6%B1%82%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD%EF%BC%88heap-based-objects%EF%BC%89">要求对象产生于heap之中(Heap-Based Objects)</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%BD%8D%E4%BA%8Eheap%E5%86%85">判断某个对象是否位于heap内</a></li>
<li><a href="#%E7%A6%81%E6%AD%A2%E5%AF%B9%E8%B1%A1%E4%BA%A7%E7%94%9F%E4%BA%8Eheap%E4%B9%8B%E4%B8%AD">禁止对象产生于heap之中</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9Asmart-pointers%EF%BC%88%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%89">条款28：Smart Pointers（智能指针）</a><ul>
<li><a href="#smart-pointers%E7%9A%84%E6%9E%84%E9%80%A0%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E6%9E%90%E6%9E%84">Smart Pointers的构造、复制、析构</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0dereferencing-operators%EF%BC%88%E8%A7%A3%E5%BC%95%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89">实现Dereferencing Operators（解引操作符）</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95smart-pointers%E6%98%AF%E5%90%A6%E4%B8%BAnull">测试Smart Pointers是否为NULL</a></li>
<li><a href="#%E5%B0%86smart-pointers%E8%BD%AC%E6%8D%A2%E4%B8%BAdumb-pointers">将Smart Pointers转换为Dumb Pointers</a></li>
<li><a href="#smart-pointers%E5%92%8C%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9C%89%E5%85%B3%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Smart Pointers和与继承有关的类型转换</a><ul>
<li><a href="#smart-pointers%E4%B8%8Econst">Smart Pointers与const</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9Areference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89">条款29：Reference counting（引用计数）</a><ul>
<li><a href="#reference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0">Reference Counting（引用计数）的实现</a></li>
<li><a href="#copy-on-write%EF%BC%88%E5%86%99%E6%97%B6%E6%89%8D%E5%A4%8D%E5%88%B6%EF%BC%89">Copy-on-Write（写时才复制）</a></li>
<li><a href="#pointers,references,%E4%BB%A5%E5%8F%8Acopy-on-write">Pointers,References,以及Copy-on-Write</a></li>
<li><a href="#%E4%B8%80%E4%B8%AAreference-counting%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89%E5%9F%BA%E7%B1%BB">一个Reference-Counting（引用计数)基类</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E6%93%8D%E4%BD%9Creference-count%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%EF%BC%89">自动操作Reference Count（引用计数）</a></li>
<li><a href="#%E6%8A%8A%E6%89%80%E6%9C%89%E5%8A%AA%E5%8A%9B%E6%94%BE%E5%88%B0%E8%BF%99%E9%87%8C">把所有努力放到这里</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9Aproxy-classes%EF%BC%88%E6%9B%BF%E8%BA%AB%E7%B1%BB%E3%80%81%E4%BB%A3%E7%90%86%E7%B1%BB%EF%BC%89">条款30：Proxy classes（替身类、代理类）</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E8%AE%A9%E5%87%BD%E6%95%B0%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E4%BB%A5%E4%B8%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%E5%A6%82%E4%BD%95%E8%99%9A%E5%8C%96">条款31：让函数根据一个以上的对象类型来决定如何虚化</a><ul>
<li><a href="#%E8%99%9A%E5%87%BD%E6%95%B0-+-rtti%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%EF%BC%89">虚函数 + RTTI（运行时期类型识别）</a></li>
<li><a href="#%E5%8F%AA%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0">只使用虚函数</a></li>
<li><a href="#%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%EF%BC%88virtual-function-tables%EF%BC%89">自行仿真虚函数表格（Virtual Function Tables）</a></li>
<li><a href="#%E5%B0%86%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%EF%BC%88virtual-function-tables%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96">将自行仿真的虚函数表格（Virtual Function Tables）初始化</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E2%80%9D%E9%9D%9E%E6%88%90%E5%91%98%EF%BC%88non-member%EF%BC%89%E5%87%BD%E6%95%B0%E2%80%9C%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">使用”非成员（Non-Member）函数“的碰撞处理函数</a></li>
<li><a href="#%E2%80%9D%E7%BB%A7%E6%89%BF%E2%80%9C-+-%E2%80%9D%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%E2%80%9C">”继承“ + ”自行仿真的虚函数表格“</a></li>
<li><a href="#%E5%B0%86%E8%87%AA%E8%A1%8C%E4%BB%BF%E7%9C%9F%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%A0%BC%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E5%86%8D%E5%BA%A6%E8%AE%A8%E8%AE%BA%EF%BC%89">将自行仿真的虚函数表格初始化（再度讨论）</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<p>设计C++软件时，有一些问题会不断重复出现。例如，如何让constructors及nonmember<br>functions像虚函数一样地作用？如何限制class实体个数？如何阻止对象产生于heap内？如何保证对象产生于heap内？如何能够产生某种对象，使它再某些class的member<br>functions被调用时，自动执行某些动作？如何令不同的对象共享同一份数据结构，却让用户错以为每个对象各自有一份数据？如何区分operator[]的读写用途？如何产生一个虚函数，使其行为视多个对象的动态类型而定？  </p>
<h4 id="条款25：将constructor和non-member-functions虚化"><a href="#条款25：将constructor和non-member-functions虚化" class="headerlink" title="条款25：将constructor和non-member functions虚化"></a>条款25：将constructor和non-member functions虚化</h4><ol>
<li>当你手上有一个对象的pointer或reference，而你不知道该对象的真正类型是什么的时候，你会调用<font color=red>virtual function</font>（<font color=green>虚函数</font>）以完成因类型而异的行为。当你尚未获得对象，但已经知道需要什么类型的时候，你会调用constructor以构造对象。那么virtual constructors是什么？假如设计一个软件，用来处理时事新闻，内容由文字和图形构成。组织如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类，时事消息的组件（components），至少一个纯虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Graphic* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsLetter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewsLetter</span>(istream &amp;str);</span><br><span class="line">    <span class="built_in">NewsLetter</span>(<span class="keyword">const</span> NewsLetter &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    list&lt;NLComponent*&gt; components;</span><br><span class="line">    <span class="comment">// 从str读取下一个NLComponent的数据，产生组件并返回一个指向它的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> NLComponent* <span class="title">readComponent</span><span class="params">(istream &amp;str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(istream &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (str)</span><br><span class="line">    &#123;</span><br><span class="line">        components.<span class="built_in">push_back</span>(<span class="built_in">readComponent</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NewsLetter::<span class="built_in">NewsLetter</span>(<span class="keyword">const</span> NewsLetter &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 迭代遍历rhs的list，运用每个元素的virtual copy constructor，将元素复制</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;NLComponent*&gt;::const_iteraotr it = rhs.components.<span class="built_in">begin</span>();</span><br><span class="line">        it != rhs.components.<span class="built_in">end</span>();</span><br><span class="line">        ++it)</span><br><span class="line">        <span class="comment">// 调用it当前指向rhs.components的元素，然后调用该元素的clone取得副本加到本对象的list尾端</span></span><br><span class="line">        components.<span class="built_in">push_back</span>((*it)-&gt;<span class="built_in">clone</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <code>readComponent</code>产生了一个崭新的对象，是TextBlock是Graphic视读入的数据而定。由于它产生了新对象，行为仿若constructor，但它能产生不同类型的对象，所以它是一个<font color=red>virtual constructor</font>。<strong>所谓virtual constructor是某种函数，它获得输入，可产生不同类型的对象</strong>。  </li>
<li>有一种特别的virtual constructor——所谓<font color=red>virtual copy constructor</font>。它返回一个指针，指向其调用者的一个新副本。virtual copy constructors通常以copySelf或cloneSelf命名：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> NLComponent* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLCommponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual copy constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TextBlock* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TextBlock</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// virtual copy constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Graphic* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Graphic</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  class的virtual copy constructor只是调用真正的copy constructor而已。真正的copy constructor执行的是<font color=red>浅拷贝</font>（<font color=green>shallow copy</font>），virtual copy constructor一样，如果真正的copy constructor执行的是<font color=red>深复制</font>（<font color=green>deep copy</font>），virtual copy constructor亦然。<br>  上述实现手法是利用“虚函数之返回类型”规则中的一个宽松点，它是晚些才被接纳的规则。<font color=red><strong>当derived class重新定义其base class的虚函数时，不再需要得声明与其原本相同的返回类型</strong></font>。<h5 id="将Non-Member-Functions的行为虚化"><a href="#将Non-Member-Functions的行为虚化" class="headerlink" title="将Non-Member Functions的行为虚化"></a>将Non-Member Functions的行为虚化</h5></li>
<li>像constructors无法真正被虚化一样，non-member functions也是。让output操作符虚化（operator&lt;&lt;），获得一个ostream&amp;作为其左端自变量，因此它不可能成为member function（其实可以，但会发生）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;str) <span class="keyword">const</span> = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;str) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;str) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line">TextBlock t;</span><br><span class="line">Graphic g;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 此些语法与传统不符，Clients必须把stream对象放在&lt;&lt;左侧</span></span><br><span class="line">t &lt;&lt; cout;</span><br><span class="line">g &lt;&lt; cout;</span><br></pre></td></tr></table></figure>
 如果我们用虚函数（如print）来作为打印，就跟其他类型对象语法不一致了，很不自然。我们需要的是名为<strong>operator&lt;&lt;的non-member function</strong>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;s)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span> :</span> <span class="keyword">public</span> NLComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;s, <span class="keyword">const</span> NLComponent &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">print</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款26：限制某个class所能产生的对象数量"><a href="#条款26：限制某个class所能产生的对象数量" class="headerlink" title="条款26：限制某个class所能产生的对象数量"></a>条款26：限制某个class所能产生的对象数量</h4><h5 id="允许零个或一个对象"><a href="#允许零个或一个对象" class="headerlink" title="允许零个或一个对象"></a>允许零个或一个对象</h5><ol>
<li>没当产生一个对象，会有constructor被调用。阻止某个对象被产出的方法是将constructor声明为private： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintJob</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob &amp;job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="keyword">const</span> Printer &amp;rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer&amp; <span class="title">thePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Printer p;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintJob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintJob</span>(<span class="keyword">const</span> string &amp;whatToPrint);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">string buffer;</span><br><span class="line">..</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">reset</span>();</span><br><span class="line"><span class="built_in">thePrinter</span>().<span class="built_in">submitJob</span>(buffer);</span><br></pre></td></tr></table></figure>
 这个设计由三个成分。第一，Printer class的constructor的属性为private，可以压制对象诞生；第二，全局函数thePrinter被声明为class的一个friend，使thePrinter不受private constructors的约束；第三，thePrinter内含一个static Printer对象，意指只有一个Printer对象被产出。<br> 在此thePrinter的实现代码中，有两个精细的地方值得探讨。<font color=red>第一个细微点</font>是，形成唯一的Printer对象，是<font color=red><strong>函数中的static对象而非class中的staic对象</strong></font>。“class拥有一个static对象意思是：即使从未被用过，它也会被构造（及析构）。相反”函数拥有一个static对象“指的是，此对象在函数第一次被调用才产生。让打印机成为<font color=red>class static</font>而非一个<font color=red>function static</font>有个缺点，那就是不知道它的初始化时机，而function static的初始化实际是确切知道的。<br> <font color=red>第二个细微点</font>是<font color=red><strong>函数的”static对象与inlining的互动“</strong></font>。这个函数未被声明为inline。因为声明static意味着只需要唯一一个对象，但对于inline non-member function其中内含local static对象，意味着你这个函数有内部连接（internal linkage）。你的程序可能会拥有多份该static对象的副本。（新版编译期这个问题已经消除）</li>
</ol>
<h5 id="不同的对象构造状态"><a href="#不同的对象构造状态" class="headerlink" title="不同的对象构造状态"></a>不同的对象构造状态</h5><ol start="2">
<li>或许有人认为使用计数器来限制对象数量更简单。甚至是更一般化，可以使对象的最大数量可以设定为1以外的值。但这策略有问题。当其他对象继承Printer对象或者包含Printer时，就会抛出TooManyObjects exception。除非避免具体类继承其他具体类。问题出在Printer对象可在3种不同状态下生存：（1）<strong>它自己</strong>，（2）<strong>派生物的base class成分</strong>，（3）<strong>内嵌于较大对象之中</strong>。通常你只对上述（1）感兴趣。如果采用原先的策略，很容易达成。因为constructor是private的，如果没有声明任何friend的话，是不能被用来当作base classes的，也不能内嵌于其他对象内。</li>
</ol>
<h5 id="允许对象生生灭灭"><a href="#允许对象生生灭灭" class="headerlink" title="允许对象生生灭灭"></a>允许对象生生灭灭</h5><ol start="3">
<li>知道了对象的constructor可于3种情况下被调用，知道了令constructors成为private可以混淆的对象计数。虽然用thePrinter函数封装起来，虽然限制了Printer对象的个数为1，但也限制了每次执行程序只能有唯一一个Printer对象（？？？），因此不能写出一下代码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create Printer object p1;</span><br><span class="line">use p1;</span><br><span class="line">destroy p1;</span><br><span class="line">create Printer object p2;</span><br><span class="line">use p2;</span><br><span class="line">destroy p2;</span><br></pre></td></tr></table></figure>
 唯一的做法是将稍早的对象计数（object-counting）码和先前所见的伪构造函数(pseudo-constructors）结合起来： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObjects</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="comment">// pseudo-constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer &amp;rhs)</span></span>;</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob &amp;job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> Printer::maxObjects = <span class="number">10</span>; <span class="comment">//</span></span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="comment">// 不允许拷贝 E27</span></span><br><span class="line">    <span class="built_in">Printer</span>(<span class="keyword">const</span> Printer &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class static</span></span><br><span class="line"><span class="keyword">size_t</span> Printer::numObjects = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Printer::maxObjects;</span><br><span class="line"></span><br><span class="line">Printer::<span class="built_in">Printer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObjects)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObject</span>();</span><br><span class="line">    proceed with normal object construction here;</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PrinterPrinter</span>(<span class="keyword">const</span> Printer &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObejcts)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer* <span class="title">Printer::makePrinter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Printer; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Printer* <span class="title">Printer::makePrinter</span><span class="params">(<span class="keyword">const</span> Printer &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Printer</span>(rhs); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// old</span></span><br><span class="line">Printer p1; <span class="comment">// error, default ctor is private</span></span><br><span class="line">Printer *p2 = Printer::<span class="built_in">makePrinter</span>();   <span class="comment">// ok</span></span><br><span class="line">Printer p3 = *p2;   <span class="comment">// error</span></span><br><span class="line">p2-&gt;<span class="built_in">performSelfTest</span>();  <span class="comment">//</span></span><br><span class="line">p2-&gt;<span class="built_in">reset</span>();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p2;  <span class="comment">// 如果p2是smart pointer就不用</span></span><br></pre></td></tr></table></figure>
 这就被泛化伪任意个数（不限一个）的对象，它将原本的常量1改为class专属的一个数值。</li>
</ol>
<h5 id="一个用来计算对象个数的Base-Class"><a href="#一个用来计算对象个数的Base-Class" class="headerlink" title="一个用来计算对象个数的Base Class"></a>一个用来计算对象个数的Base Class</h5><ol start="4">
<li>我们可以轻易完成一个base class，用来当作对象计数来使用，并让Printer之类的classes继承它。确保计算对象的每个class都有各自的计数器。设计一个class template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counted</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TooManyObject</span> &#123;</span>&#125;; <span class="comment">// 可能抛出exceptions</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">objectCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numObjects;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Counted</span>();</span><br><span class="line">    <span class="built_in">Counted</span>(<span class="keyword">const</span> Counted &amp;rhs);</span><br><span class="line">    ~<span class="built_in">Counted</span>() &#123; --numObjects; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> numObjects;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> maxObjects;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;    <span class="comment">// 避免ctor重复出现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>()</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line">Counted&lt;BeingCounted&gt;::<span class="built_in">Counted</span>(<span class="keyword">const</span> Counted&lt;BeingCounted&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Counted&lt;BeingCounted&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numObjects &gt;= maxObjects) <span class="keyword">throw</span> <span class="built_in">TooManyObjects</span>();</span><br><span class="line">    ++numObjects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 修改Printer class，让它运用Counted template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> :</span> <span class="keyword">private</span> Counted&lt;Printer&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// pseudo-constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Printer* <span class="title">makePrinter</span><span class="params">(<span class="keyword">const</span> Printer &amp;rhs)</span></span>;</span><br><span class="line">    ~<span class="built_in">Printer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">submitJob</span><span class="params">(<span class="keyword">const</span> PrintJob &amp;job)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">performSelfTest</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::objectCount;</span><br><span class="line">    <span class="keyword">using</span> Counted&lt;Printer&gt;::TooManyObjects;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Printer</span>();</span><br><span class="line">    <span class="built_in">Printer</span>(<span class="keyword">const</span> Printer &amp;rhs);ss</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 Counted的大部分作为都隐藏起来不让Printer的用户知道，但用户可能希望知道有多少个Printer对象存在。Counted template提供了objectCount函数，提供信息。然而该函数在Printer中变成了private访问层级，因为上面用的是private inheritance，<strong>为了恢复public访问层级，采用了using表达式</strong>。关于Counted内的statics义务性定义，只要将： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BeingCounted</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> Counted&lt;BeingCounted&gt;::numObjects;  <span class="comment">// 定义并自动初始化为0</span></span><br></pre></td></tr></table></figure>
 放进某个Counted的某个实现文件就可以了。而maxObjects则放在Printer作者的某个实现文件中就可以了： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Counted&lt;Printer&gt;::maxObjects = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款27：要求（或禁止）对象产生于heap之中"><a href="#条款27：要求（或禁止）对象产生于heap之中" class="headerlink" title="条款27：要求（或禁止）对象产生于heap之中"></a>条款27：要求（或禁止）对象产生于heap之中</h4><h5 id="要求对象产生于heap之中（Heap-Based-Objects）"><a href="#要求对象产生于heap之中（Heap-Based-Objects）" class="headerlink" title="要求对象产生于heap之中（Heap-Based Objects）"></a>要求对象产生于heap之中（Heap-Based Objects）</h5><ol>
<li>阻止clients不得使用new以外的方法产生对象,这很容易办到,只要让那些被隐式调用的构造动作和析构动作不合法就可以了。把constructors和destructor声明为private就太过了，那么只<strong>将destructors成为private</strong>就可以了。而用一个pseudo destructor函数来调用真正的destructor： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UPNumber</span>();</span><br><span class="line">    <span class="built_in">UPNumber</span>(<span class="keyword">int</span> initValue);</span><br><span class="line">    <span class="built_in">UPNumber</span>(<span class="keyword">double</span> initValue);</span><br><span class="line">    <span class="built_in">UPNumber</span>(<span class="keyword">const</span> UPNumber &amp;rhs);</span><br><span class="line">    <span class="comment">// pseudo destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~<span class="built_in">UPNumber</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UPNumber n; <span class="comment">// error</span></span><br><span class="line">UPNumber *p = <span class="keyword">new</span> UPNumber; <span class="comment">// ok</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// error</span></span><br><span class="line">p-&gt;<span class="built_in">destroy</span>();   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 把constructors声明为private的缺点是，必须记住每一个constructor都声明为private。只要限制destructor或constructors的运用，就可以阻止non-heap objects的诞生，但是，它妨碍了<strong>继承（inheritance）</strong>和<strong>内含（containment）</strong>。这个困难可以克服，只需要将UPNumber的destructor成为protected就可以解决： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonNegativeUPNumber</span> :</span> <span class="keyword">public</span> UPNumber &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Asset</span>(<span class="keyword">int</span> initValue);</span><br><span class="line">    ~<span class="built_in">Asset</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber *value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Asset::<span class="built_in">Asset</span>(<span class="keyword">int</span> initValue) : <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">UPNumber</span>(initValue)) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">Asset::~<span class="built_in">Asset</span>()</span><br><span class="line">&#123; value-&gt;<span class="built_in">destroy</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断某个对象是否位于heap内"><a href="#判断某个对象是否位于heap内" class="headerlink" title="判断某个对象是否位于heap内"></a>判断某个对象是否位于heap内</h5></li>
<li>没有办法侦测出一个construcotr是不是在heap内。或许可以通过设置标志位，但对于operator new[]来说，设置标志位却只有一次机会设立标志信息，而第二次就会exception。或者是利用系统的一个特点：<strong>stack（栈）高地址往低地址成长，heap（堆）由低地址往高地址成长</strong>。但是这是不可移植的。这个函数的观念很有趣。一个临时stack是个局部变量，它会被放在stack的顶端，而stack向低地址成长，所以这个stack的地址一定比任何一个位于stack中的变量（或对象）更低。因此，如果一个位于heap的对象，其地址一定比临时stack的地址更低。但这个想法不完善，很多系统把static对象放置在heap的底下。<br> 如果真实目的只是为了想知道对象调用delete是否安全，那就跟判断对象是否在heap是两回事了： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">getMemory</span>(size);</span><br><span class="line">    <span class="comment">// add p to the collection of allocated addresses;</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">releaseMemory</span>(ptr); <span class="comment">// free store</span></span><br><span class="line">    <span class="comment">// remove ptr from the collection of allocated addresses;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSafeToDelete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *address)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// return whether address is in collection of allocated addresses</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 operator new负责把一些条目（entires）加到一个由“动态分配而得的地址”所形成的集合中，operator delete负责把这些条目移除；isSafeToDelete负责查找集合，看看地址是否在其中。这些operator new和operator delete函数都在全局范围内，这应该堆所有类型都管用（甚至内置类型）。但这不是我们想要的——当对象存在多重继承或虚拟继承时，可能拥有多地址，这就是<font color=red>非自然多态</font>（<font color=green>unnatural polymorphism</font>）。<br> 我们需要的是一个提供函数机能，但不符带全局命名空间的污染问题、额外的义务性负担，以及正确性的疑惑。那么<font color=green>abstract mixin base class</font>（<font color=red>抽象混合式基类</font>）可以满足需求。抽象基类不能被实例化，因为它至少有一个纯虚函数。mix in class则提供了一组定义好的能力，能与derived class兼容： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapTracked</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">class <span class="title">MissingAddress</span><span class="params">()</span></span>; <span class="comment">// exception class</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">HeapTracked</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">void</span> *RawAddress;</span><br><span class="line">    <span class="keyword">static</span> list&lt;RawAddress&gt; addresses;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static class member的义务性定义</span></span><br><span class="line">list&lt;RawAddress&gt; HeapTracked::addresses;</span><br><span class="line"></span><br><span class="line">HeapTracked::~<span class="built_in">HeapTracked</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* HeapTracked::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *memPtr = ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);    <span class="comment">// 取得内存</span></span><br><span class="line">    addresses.<span class="built_in">push_front</span>(memPtr); <span class="comment">// 将地址放到list头部</span></span><br><span class="line">    <span class="keyword">return</span> memPtr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> HeapTracked::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    list&lt;RawAddress&gt;::iterator it = <span class="built_in">find</span>(address.<span class="built_in">begin</span>(), address.<span class="built_in">end</span>(), ptr);</span><br><span class="line">    <span class="keyword">if</span> (it != address.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        addresses.<span class="built_in">erase</span>(it);</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">MissingAddress</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HeapTracked::isOnHeap</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *rawAddress = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(<span class="keyword">this</span>);</span><br><span class="line">    list&lt;RawAddress&gt;::iterator it = <span class="built_in">find</span>(address.<span class="built_in">begin</span>(), address.<span class="built_in">end</span>(), rawAddress);</span><br><span class="line">    <span class="keyword">return</span> it != addresses.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asset</span> :</span> <span class="keyword">public</span> HeapTracked</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    UPNumber value;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inventoryAsset</span><span class="params">(<span class="keyword">const</span> Asset *ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ap-&gt;<span class="built_in">isOnHeap</span>())</span><br><span class="line">        ap is a heap-based asset -- inventory it as such;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        ssap is a non-heap-based asset -- record it that way;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 凡涉及“多重或虚拟基类”的对象，会拥有多个地址，如果写在全局函数就会很复杂，但是isOnHeap只施行于HeapTracked对象身上，所以只要简单的将指针<strong>dynamic_cast</strong>为**void*<strong>（或</strong>const void*<strong>或</strong>volatile void*<strong>或</strong>const volatile void***），就会获得一个指针，指向原指针所指对象的内存起始处。不过dynamic_cast只适用于有至少一个虚函数的指针身上。之所以前面的isSafeToDelete撰写很复杂，就是因为它可以对任何类型起作用，因此dynamic_cast无法帮助它。isOnHeap有所选择（只针对HeapTracked对象的指针）。这个技术有移植性，只要编译器支持dynamic_cast。</li>
</ol>
<h5 id="禁止对象产生于heap之中"><a href="#禁止对象产生于heap之中" class="headerlink" title="禁止对象产生于heap之中"></a>禁止对象产生于heap之中</h5><ol start="3">
<li>一般有3种情况：<ul>
<li> 对象被直接实例化</li>
<li> 对象被实例化为derived class objects内的base class成分</li>
<li>对象被内嵌于其他对象之中。<br>阻止clients直接将对象实例化于heap之中，很容易，只需要将operator new和operator delete声明为private就可以了，如果想禁止对象所组成的数组，可以将operator new[]和operator delete声明为private。</li>
</ul>
</li>
</ol>
<h4 id="条款28：Smart-Pointers（智能指针）"><a href="#条款28：Smart-Pointers（智能指针）" class="headerlink" title="条款28：Smart Pointers（智能指针）"></a>条款28：Smart Pointers（智能指针）</h4><ol>
<li>Smart poinnters是一种像内建指针，却提供了更多机能的对象。当以smart pointers取代C++的内建指针（<strong>dumb pointer</strong>），你会获得各种指针行为的控制权：<ul>
<li><font color=red>构造和析构</font>（<font color=green>Construction and Destruction</font>）。你可以决定smart pointer被产生以及被构造时发生什么事。通常给smart pointers一个默认值0，以避免指针未获初始化。</li>
<li><font color=red>复制和复制</font>（<font color=green>Copying and Assignment</font>）。当一个smart pointer被复制或涉及复制动作时，可以控制发生什么事。</li>
<li><font color=red>解引</font>（<font color=green>Dereferencing</font>）。当client解引（取用）smart pointer所指的对象时，有权决定发生什么事情。<br>Smart pointers由templates产生出来。由于像内建指针一样，所以它必须由强烈的<font color=red>类型性</font>（<font color=green>strongly teyped</font>）。</li>
</ul>
</li>
</ol>
<h5 id="Smart-Pointers的构造、复制、析构"><a href="#Smart-Pointers的构造、复制、析构" class="headerlink" title="Smart Pointers的构造、复制、析构"></a>Smart Pointers的构造、复制、析构</h5><ol start="2">
<li>auto_ptr template可能实现如下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_tpr</span>(T *ptr = <span class="number">0</span>) : <span class="built_in">pointee</span>(ptr) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> pointee; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 在同一个对象只可被一个auto_ptr拥有的前提下，上述做法有效运转。但一旦auto_ptr被复制或被赋值，会发生什么？会导致两个auto_ptrs指向同一对象。这当在销毁对象时，可能会删除两次，往往会导致未定义。<br> 另一个做法是<strong>以new操作符为所指对象产生一个新副本</strong>。而auto_ptr<T>不得指向一个类型为T的对象，可以指向一个T派生类型的对象。auto_ptr采用了一个富弹性的解法：当auto_ptr被复制或被赋值，其对象拥有权会转移： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt; &amp;rhs); <span class="comment">// copy constructor</span></span><br><span class="line">    auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(auto_ptr&lt;T&gt; &amp;rhs);  <span class="comment">// assignment operator</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">auto_ptr&lt;T&gt;::<span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt; &amp;rhs);</span><br><span class="line">&#123;</span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">auto_ptr&lt;T&gt;&amp; auto_ptr&lt;T&gt;::<span class="keyword">operator</span>=(auto_ptr&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> pointee; <span class="comment">// 删除原有的对象</span></span><br><span class="line">    pointee = rhs.pointee;</span><br><span class="line">    rhs.pointee = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 由于auto_ptr的copy constructor被调用时，对象拥有权转移了，所以以by value方式转递auto_ptrs往往是个糟糕的主意： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTreeNode</span><span class="params">(ostream &amp;s, auto_ptr&lt;TreeNode&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123; s &lt;&lt; *p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">auto_ptr&lt;TreeNode&gt; <span class="title">ptn</span><span class="params">(ew TreeNode)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">printTreeNode</span>(cout, ptn);   <span class="comment">// 以by value传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 当printTreeNode的参数被p初始化（通过auto_ptr的copy constructor），ptn所指的对象拥有权被转移至p。当printTreeNode结束，p离开生存空间，destructor被调用。然而ptn不再指向任何东西，这将产生未定义行为。所以Pass-by-reference-to-const才是适当的途径： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTreeNode</span><span class="params">(ostream &amp;s, <span class="keyword">const</span> auto_ptr&lt;TreeNode&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123; s &lt;&lt; *p; &#125;</span><br></pre></td></tr></table></figure>
 在此函数中，p是个referene而不是对象。所以不会由constructor被用来为p设定初值，ptn将保留拥有权。</li>
</ol>
<h5 id="实现Dereferencing-Operators（解引操作符）"><a href="#实现Dereferencing-Operators（解引操作符）" class="headerlink" title="实现Dereferencing Operators（解引操作符）"></a>实现Dereferencing Operators（解引操作符）</h5><ol start="3">
<li>现在注意力放在smart pointers的核心：operator*和operator-&gt;函数身上： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">    <span class="keyword">return</span> *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个函数首先做任何必要的初始化动作或是让pointee获得有效值的任何动作。<br> 检验operator-&gt;前，看一下此函数的不寻常意义： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产生smart ptrs，用来指向分布式数据库（DB）内的对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DBPtr</span>(T *realPtr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">DBPtr</span>(DataBaseID id);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来表现数据库中的一笔数据（tuples）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayEditDialog</span><span class="params">()</span></span>;   <span class="comment">// 呈现图形式对话框，供输入tuple</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span> <span class="keyword">const</span></span>;   <span class="comment">// 检验*this是否有效</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class template，用来在T对象被修改时，完成运转记录（log entires）。</span></span><br><span class="line"><span class="keyword">template</span>&lt;classs T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogEntry</span>(<span class="keyword">const</span> T &amp;objectToBeModified);</span><br><span class="line">    ~<span class="built_in">LogEntry</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">editTuple</span><span class="params">(DBPtr&lt;Tuple &amp;pt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">LogEntry&lt;Tuple&gt; <span class="title">entry</span><span class="params">(*pt)</span></span>;</span><br><span class="line">    <span class="comment">// 反复显示编辑对话框，知道获得有效值为止</span></span><br><span class="line">    <span class="keyword">do</span> pt-&gt;<span class="built_in">displayEditDialog</span>();</span><br><span class="line">    <span class="keyword">while</span> (pt-&gt;<span class="built_in">isValid</span>() == <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 其中<code>pt-&gt;displayEditDialog();</code>会被编译器解释为：<code>(pt.operator-&gt;())-&gt;displayEditDialog();</code>这个意味着，<strong>不论operator-&gt;返回什么，在该回传值身上施行-&gt;操作符都是合法的</strong>。因此operator-&gt;只能返回两个东西：一个dumb pointer或是一个smart pointer： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    perform <span class="string">&quot;smart pointer&quot;</span> processing;</span><br><span class="line">    <span class="keyword">return</span> pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="测试Smart-Pointers是否为NULL"><a href="#测试Smart-Pointers是否为NULL" class="headerlink" title="测试Smart Pointers是否为NULL"></a>测试Smart Pointers是否为NULL</h5><ol start="4">
<li>我们可以产生、销毁、赋值、复制、解引smart pointers。但有一件事没办法做，就是判断是否为NULL： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...        <span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (!ptn) ...       <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 为我们smart pointer class添加一个isNULL很容易，但不自然。另一个做法是，提供一个隐式转换操作符，允许上述测试动作通过编译。<font color=red>这个转换的传统目标是void*</font>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">void</span>*();   <span class="comment">// 如果dumb ptr是null，返回0，否则是非0值</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...   <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...        <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">if</span> (!ptn) ...       <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 <strong>这个做法的缺点是，它竟然可以用来对完全不同类型的对象比较</strong>（我好像没出现这样的情况……）！这个问题无法解决，但有个差强人意的做法，允许提供测试nullness的合理语法，并能够将意外引起不同类型之smart pointers相互比较的机会降到最低，那就是将!操作符重载，并在其调用者是null的情况下，返回true： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;TreeNode&gt; ptn;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!ptn) ...   <span class="comment">// ok ptn is null</span></span><br><span class="line"><span class="keyword">else</span> ...        <span class="comment">// ptn is not null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptn == <span class="number">0</span>) ...   <span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (ptn) ...        <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Apple&gt; pa;</span><br><span class="line">SmartPtr&lt;Orange&gt; po;    </span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!pa == !po) ... <span class="comment">// ok </span></span><br></pre></td></tr></table></figure>
 这个有风险的做法的原因是很少有程序员这么个写法。在C++标准程序库中，隐式转换为void*已被隐式转换为bool取代，而operator bool总是返回operator!的反相。</li>
</ol>
<h5 id="将Smart-Pointers转换为Dumb-Pointers"><a href="#将Smart-Pointers转换为Dumb-Pointers" class="headerlink" title="将Smart Pointers转换为Dumb Pointers"></a>将Smart Pointers转换为Dumb Pointers</h5><ol start="5">
<li>有时候你希望将smart pointers加入已使用的dumb pointers应用软件中， <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(Tuple *pt)</span></span>;  <span class="comment">// by dumb pointer</span></span><br><span class="line"></span><br><span class="line">DBPtr&lt;Tuple&gt; pt;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">normaize</span>(pt);   <span class="comment">// error</span></span><br><span class="line"><span class="built_in">normalize</span>(&amp;*pt);<span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 那个转换动作很难看，如果为smart pointer-to-T template加上隐式类型转换操作符，使之转换为<font color=red>dumb pointer-to-T</font>，先前的调用就能成功。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">operator</span> T*() &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBPtr&lt;Tuple&gt; pt;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">normalize</span>(pt);  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 上述函数一加上，nullness测试问题也一并解决了。不过这样的转换也有阴暗面，它式clients得以轻易地直接对dumb pointers做动作，因而回避了smart pointer的最初目的。允许直接适用dumb pointers有灾难，它导致class的计数簿记工作方面的错误。造成引用计数所用的数据结构崩溃。<br> 即使提供了一个隐式转换操作符，smart pointer还是无法完全取代dumb pointer。因为从smart pointer转换为dumb pointer是一种用户定制的转换行为，而<font color=red><strong>编译器禁止一次施行一次以上这类转换</strong></font>。举个例子，有个class，考虑一个函数用来整合两个TupleAccessors对象的信息： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TupleAccessors</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TupleAccessors</span>(<span class="keyword">const</span> Tuple *pt);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TupleAccessors <span class="title">merge</span><span class="params">(<span class="keyword">const</span> TupleAccessors &amp;ta1, <span class="keyword">const</span> TupleAccessors &amp;ta2)</span></span>;</span><br><span class="line"></span><br><span class="line">Tuple *pt1, *pt2;</span><br><span class="line"><span class="built_in">merge</span>(pt1, pt2);    <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">DBPtr&lt;Tuple&gt; pt1, pt2;</span><br><span class="line"><span class="built_in">merge</span>(pt1, pt2);    <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 这是因为从DBPtr<Tuple>转换为TupleAccessors需要两个用户定制转换，而着C++不允许，所以第一个将DBPtr<Tuple>转换为Tuple*，而第二个将需要将Tuple*转环为TupleAccessors）。所以不要提供对dumb pointers的隐式转换操作符，除非不得已。</li>
</ol>
<h5 id="Smart-Pointers和与继承有关的类型转换"><a href="#Smart-Pointers和与继承有关的类型转换" class="headerlink" title="Smart Pointers和与继承有关的类型转换"></a>Smart Pointers和与继承有关的类型转换</h5><ol start="6">
<li>假设有一个public inheritance继承体系，构建出消费性音乐产品： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicProduct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MusicProduct</span>(<span class="keyword">const</span> string &amp;title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cassette</span> :</span> <span class="keyword">public</span> MusicProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cassette</span>(<span class="keyword">const</span> string &amp;title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displayTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span> :</span> <span class="keyword">public</span> MusicProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CD</span>(<span class="keyword">const</span> string &amp;title);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">displalyTitle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> MusicProduct *pmp, <span class="keyword">int</span> numTimes)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numTimes; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pmp-&gt;<span class="built_in">displayTitle</span>();</span><br><span class="line">        pmp-&gt;<span class="built_in">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dumb pointers的方式没问题，smart pointer取代之则另一种情况了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displayAndPlay</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;MusicProduct&gt; &amp;pmp, <span class="keyword">int</span> numTimes)</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;Cassette&gt; <span class="title">funMusic</span><span class="params">(<span class="keyword">new</span> Cassette(<span class="string">&quot;Alapalooza&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">SmartPtr&lt;CD&gt; <span class="title">nightmareMusic</span><span class="params">(<span class="keyword">new</span> CD(<span class="string">&quot;Disco Hits of the 70s&quot;</span>))</span></span>;</span><br><span class="line"><span class="built_in">displayAndPlay</span>(funMusic, <span class="number">10</span>);       <span class="comment">// error</span></span><br><span class="line"><span class="built_in">displayAndPlay</span>(nightmareMusic, <span class="number">0</span>);  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 之所以无法通过编译，是因为编译器所看见的是3个互不相干的classs。有个办法可以绕弯解除这一束缚：<strong>令每个smart pointer class有个隐式类型转换操作符，用来转换至另一个smart pointer class</strong>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;</span>Cassette&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()</span><br><span class="line">    &#123; <span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cassette *pointee;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&lt;</span>CD&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;()</span><br><span class="line">    &#123; <span class="keyword">return</span> SmartPtr&lt;MusicProduct&gt;(pointee); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CD *pointee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个做法有两个缺点。第一，必须为每一个“SmartPtr class实例”加入上述例子；第二，需要加上很多这样的转换操作符，因为所指的对象位于继承体系的底层，必须为对象直接继承或间接继承的每个base class提供一个转换函数。由于编译器禁止一次执行一个以上的用户定制类型转换函数，所以无法将<font color=red>smart pointer-to-T</font>转换为一个<font color=red>smart pointer-to-indirect-base-class-of-T</font>。刚好有个语言扩充性质，它可以将nonvirtual member function声明为template，可以用它来产生smart pointer的转换函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template class，用于smart pointer-to-T对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T *realPtr = <span class="number">0</span>);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// template function，用于隐式转换操作符</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">newType</span>&gt;</span></span><br><span class="line">    <span class="keyword">operator</span> SmartPtr&lt;newType&gt;()</span><br><span class="line">    &#123; <span class="keyword">return</span> SmartPtr&lt;newType&gt;(pointee); &#125;</span><br><span class="line">    ,,,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 funMusic对象属于SmartPtr<Cassette>类型，而displayAndPlay函数期望得到一个SmartPtr<MusicProduct>对象。编译器发现类型不吻合，于是企图将funMusic转换其期望的对象。编译器在SmartPtr<MusicProduct> class内企图找一个”单一变量之construcotr“，其自变量类型为SmartPtr<Cassette>，但没有找到；于是企图在SmartPtr<Cassette> class内找一个隐式类型转换操作符，希望产出已给SmartPtr<MusicProduct> class，但也失败了；接下来再试图寻找一个”可实例化以导出合宜转换函数“的member function template。它在SmartPtr<Cassette>找到一个东西，当它被实例化并令newType绑定MusicProduct时，编译器将之实例化，可得： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;Cassette&gt;::<span class="keyword">operator</span> SmartPtr&lt;MusicProduct&gt;() </span><br><span class="line">&#123; <span class="keyword">return</span> SmartPTr&lt;MusicProduct&gt;(pointee); &#125;</span><br></pre></td></tr></table></figure>
 这其中涵盖的技术不简单，它包括：（1）函数调用的自变量匹配规则、（2）隐式类型转换函数、（3）template functions的暗自实例化、（4）member function templates等技术。</li>
</ol>
<h6 id="Smart-Pointers与const"><a href="#Smart-Pointers与const" class="headerlink" title="Smart Pointers与const"></a>Smart Pointers与const</h6><ol start="7">
<li>const可以修饰被指的东西 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CD <span class="title">goodCD</span><span class="params">(<span class="string">&quot;Flood&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> CD *p;    <span class="comment">// p时non-const指针，指向const CD object</span></span><br><span class="line">CD *<span class="keyword">const</span> p = &amp;goodCD;  <span class="comment">// p是哟个const指针，指向non-const CD object，必须有初值</span></span><br><span class="line"><span class="keyword">const</span> CD *<span class="keyword">const</span> p = &amp;goodCD;    <span class="comment">//p是一个const指针，指向一个const CD object</span></span><br></pre></td></tr></table></figure>
 很自然，我们想要smart pointers也有同样的弹性。但Smart pointer只能有一个地方放置const，只能施行与指针身上，不能及于所指对象，不过我们可以对const以及non-const的对象及指针，产生4种组合： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; p;</span><br><span class="line">Smart&lt;<span class="keyword">const</span> CD&gt; p;</span><br><span class="line"><span class="keyword">const</span> SmartPtr&lt;CD&gt; p = &amp;goodCD;</span><br><span class="line"><span class="keyword">const</span> SmartPtr&lt;<span class="keyword">const</span> CD&gt; p = &amp;goodCD;</span><br></pre></td></tr></table></figure>
 如果适用dumb pionters，可以non-const指针作为const指针的初值，也可以指向non-const独享的指针作为指向const对象指针的初始值，赋值规则类似： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CD *pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CD *pConstCD = pCD;   <span class="comment">// ok</span></span><br><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> CD&gt; pConstCD = pCD;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 类型转换如果涉及const，便是一条单行道：从non-const到const是安全的，从const到non-const是不安全的。解决上面的方法是，将derived class object转换为base class object，令smart pointer-to-T class公开继承一个对应的smart pointer-to-const-T class： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtrToConst</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    functions</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in"><span class="keyword">union</span></span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> T *constPointee;</span><br><span class="line">        T *pointee;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;class T&gt;</span><br><span class="line">class SmartPtr : <span class="keyword">public</span> SmartPtrToConst&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 运用这个设计，我们获得了自己希望的行为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SmartPtr&lt;CD&gt; pCD = <span class="keyword">new</span> <span class="built_in">CD</span>(<span class="string">&quot;Famous Movie Themes&quot;</span>);</span><br><span class="line">SmartPtrToConst&lt;CD&gt; pConstCD = pCD; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款29：Reference-counting（引用计数）"><a href="#条款29：Reference-counting（引用计数）" class="headerlink" title="条款29：Reference counting（引用计数）"></a>条款29：Reference counting（引用计数）</h4><ol>
<li>Reference counting这项技术，允许多个等值对象共享同一个实值。Reference counting可以消除记录对象拥有权的负荷，因为当对象用reference counting技术，它拥有它自己，一旦没人使用它，便自动销毁自己。因此，reference counting建构出<font color=red>垃圾回收机制</font>（<font color=green>garbage colection</font>）的一个简单形式。</li>
</ol>
<h5 id="Reference-Counting（引用计数）的实现"><a href="#Reference-Counting（引用计数）的实现" class="headerlink" title="Reference Counting（引用计数）的实现"></a>Reference Counting（引用计数）的实现</h5><ol start="2">
<li>基本设计像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span> ... &#125;; <span class="comment">// 包含引用计数和字符串值</span></span><br><span class="line">    StringValue *value; <span class="comment">// value of this String</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 内嵌的结构体StringValue主要用于存储引用计数和字符串值,并使得引用计数和字符串值相关联.StringValue的实现像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue) : <span class="built_in">refCount</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 StringValue只对String类可见,而对客户不可见,接口由String定义并提供给客户。String的构造函数: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue = <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; rhs);</span><br></pre></td></tr></table></figure>
  第一个构造函数的实现较简单,根据传入的char数组构造StringValue对象,然后使String中的指针指向这个String即可:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue): <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">StringValue</span>(initValue))&#123;&#125;</span><br></pre></td></tr></table></figure>
 但这样的实现导致”分开构造,但拥有相同初值的String对象,并不共享同一个数据结构”,因此像这样的代码:    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;More Effective C++&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;More Effective C++&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
 尽管是s1和s2的值相同,但它们却并不共享同一个块内存,而是各自拥有独立内存。<br> 拷贝构造函数可以使用引用计数,并共享内存,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; rhs): <span class="built_in">value</span>(rhs.value)&#123; ++value-&gt;refCount; &#125;</span><br></pre></td></tr></table></figure>
 析构函数负责在引用计数为0的时候撤销内存: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">delete</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 赋值操作符要注意自身赋值的情况: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == rhs.value) &#123; <span class="comment">//处理自身赋值</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (--value-&gt;refCount == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">delete</span> value; </span><br><span class="line">    &#125;</span><br><span class="line">    value = rhs.value; </span><br><span class="line">    ++value-&gt;refCount;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="Copy-on-Write（写时才复制）"><a href="#Copy-on-Write（写时才复制）" class="headerlink" title="Copy-on-Write（写时才复制）"></a>Copy-on-Write（写时才复制）</h5><ol start="3">
<li>对operator[]的重载比较复杂:const版本是只读动作,因而只返回指定字符即可,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>&#123; <span class="keyword">return</span> value-&gt;data[index]; &#125;</span><br></pre></td></tr></table></figure>
 但non-const版本面临着被写入新的值的可能,由于对当前String的修改不应影响到共享内存的其他String对象,因此需要先为当前String分配独立内存并将原值进行拷贝,像这样: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char&amp; String::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">    if (value-&gt;refCount &gt; 1) &#123;</span><br><span class="line">        --value-&gt;refCount; </span><br><span class="line">        value =new StringValue(value-&gt;data); </span><br><span class="line">    &#125;</span><br><span class="line">    return value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 不仅是operator[],其他可能改变String对象的操作也应该采取和non-cons版本operator[]相同的动作.这其实是lazy evaluation的一种应用.</li>
</ol>
<h5 id="Pointers-References-以及Copy-on-Write"><a href="#Pointers-References-以及Copy-on-Write" class="headerlink" title="Pointers,References,以及Copy-on-Write"></a>Pointers,References,以及Copy-on-Write</h5><ol start="4">
<li>3中对operator[]的重载解释并解决了可能的写操作篡改共享内存的问题,但是却无法阻止外部指针或引用对共享内存的篡改,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = &amp;s1[<span class="number">1</span>];</span><br><span class="line">String s2 = s1;</span><br></pre></td></tr></table></figure>
 对p所指向的内存的任何写操作都会同时更改s1和s2的值,但是s1却对此一无所知,因为p和s1没有内在联系.解决办法并不难:为每一个StringValue对象加一个标志(flag)变量,用表示是否可以被共享,开始时先将flag设为true(可以共享),一旦non-const operator[]被调用就将该flag设为false,并可能永远不许再更改(除非重新为StringValue分配更大内存而导致指针失效),StringValue的修改版像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> refCount;</span><br><span class="line">        <span class="keyword">bool</span> shareable; </span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue): <span class="built_in">refCount</span>(<span class="number">1</span>),<span class="built_in">shareable</span>(<span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 String的member function在企图使用共享内存前,就必须测试内存是否允许被共享: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.value-&gt;shareable) &#123;</span><br><span class="line">        value = rhs.value;</span><br><span class="line">        ++value-&gt;refCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(rhs.value-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
 其他返回引用的member function(对于String只有operator[])都涉及到对flag的修改,而其他可能需要共享内存的member function都涉及到对flag的检测。   条款30的proxy class技术可以将operator[]的读和写用途加以区分,从而降低”需被标记为不可共享”之StringValue对象的个数。</li>
</ol>
<h5 id="一个Reference-Counting（引用计数）基类"><a href="#一个Reference-Counting（引用计数）基类" class="headerlink" title="一个Reference-Counting（引用计数）基类"></a>一个Reference-Counting（引用计数）基类</h5><ol start="5">
<li><p>任何要支持内存共享的class都可以使用reference-counting,因此可以考虑把它抽象为一个类,任何需要reference-counting功能的class只要使用这个类即可。  </p>
<p> 第一步就是产生一个base class RCObject,执行引用计数的功能并标记对象是否可被共享,像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RCObject</span>();</span><br><span class="line">    <span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp; rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RCObject</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 由于RCObject的作用只是实现引用计数的辅助功能,然后让StringValue继承它,因此StringValue被设为一个抽象基类——通过将析构函数设为纯虚函数,但仍需要为析构函数提供定义.RCObject的实现像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RCObject::<span class="built_in">RCObject</span>(): <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::<span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject&amp;):<span class="built_in">refCount</span>(<span class="number">0</span>),<span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp;)</span><br><span class="line">&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">RCObject::~<span class="built_in">RCObject</span>() &#123;&#125; <span class="comment">// virtual dtors must always</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">if</span> (--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; shareable = <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> shareable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p> RCObject的实现非常简单,但是其拷贝构造函数和赋值操作符有些特殊——它们的参数没有名字,也就是说参数没有作用,其拷贝构造函数和赋值操作符都只是形式上的:  </p>
<p> RCObjetc拷贝构造函数与RCObject的作用相对应——RCObject一旦被构造,就说明一个新的对象被产生出来,那么RCObject对象本身的初始值和默认构造函数相同,至于refCount设为0而不是1,这要求对象创建者自行将refCount设为1.  </p>
<p> RCObject的赋值操作符什么也不做,仅仅返回*this,因为它不应该被调用,正如之前的StringValue,如果对String对象赋值,那么或者StringValue被共享,或者拷贝构造一个新的StringValue,实际上StringValue的赋值操作永远不会被调用.即使要对StringValue做赋值操作,像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sv1=sv2;<span class="comment">//sv1和sv2是StringValue型对象</span></span><br></pre></td></tr></table></figure>
<p> 指向sv1和sv2的对象数目实际上并未改变,因此sv1的基类部分RCObject什么也不做仍然是正确的.<br> removeReference的责任不仅在于将refCount减1,实际上还承担了析构函数的作用——在refCount=1的时候delete销毁对象,从这里可以看出RCObject必须被产生于heap中.<br> StringValue要直接使用RCObject,像这样:</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span>:</span> <span class="keyword">public</span> RCObject &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> StringValue类public继承自RCObject,因此它继承了RCObject的接口并供String使用,StringValue也必须构造在heap中.</p>
</li>
</ol>
<h5 id="自动操作Reference-Count（引用计数）"><a href="#自动操作Reference-Count（引用计数）" class="headerlink" title="自动操作Reference Count（引用计数）"></a>自动操作Reference Count（引用计数）</h5><ol start="6">
<li>RCObject提供了一定程度的代码复用功能,但还远远不够——String类仍然需要手动调用RCObject的成员函数来对引用计数进行更改.解决方法就是”计算机科学领域中大部分问题得以解决的原理”——在中间加一层,也就是在String和StringValue中间加一层智能指针类对引用计数进行管理,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理引用计数的智能指针类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RCPtr</span>(T* realPtr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    ~<span class="built_in">RCPtr</span>();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr&amp; rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>; <span class="comment">// see Item 28</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>; <span class="comment">//将构造函数中的重复操作提取成一个函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 之前RCPtr是一个类模板,String之前有一个StringValue*成员,现在只要将它替换为RCPtr<StringValue>即可.<br> RCPtr的构造函数像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(T* realPtr): <span class="built_in">pointee</span>(realPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr&amp; rhs): <span class="built_in">pointee</span>(rhs.pointee)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> RCPtr&lt;T&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;<span class="built_in">isShareable</span>() == <span class="literal">false</span>) &#123; </span><br><span class="line">        pointee = <span class="keyword">new</span> <span class="built_in">T</span>(*pointee); </span><br><span class="line">    &#125; </span><br><span class="line">    pointee-&gt;<span class="built_in">addReference</span>();<span class="comment">//引用计数的更改负担转移到这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 init中使用了new关键字,它调用T的拷贝构造函数,为防止编译器为StringValue合成的拷贝构造函数执行浅复制,需要为StringValue定义执行深度复制的拷贝构造函数,像这样: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> StringValue&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(rhs.data) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, rhs.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 此外,由于多态性的存在,尽管pointee是T*类型,但它实际可能指向T类型的派生类,在此情况下new调用的却是T的拷贝构造函数,要防止这种现象,可以使用virtual copy constructor(见条款25),这里不再讨论</li>
</ol>
<h5 id="把所有努力放到这里"><a href="#把所有努力放到这里" class="headerlink" title="把所有努力放到这里"></a>把所有努力放到这里</h5><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RCPtr</span>(T *realPtr = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr &amp;rhs);</span><br><span class="line">    ~<span class="built_in">RCPtr</span>();</span><br><span class="line">    RCPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr &amp;rhs);</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="keyword">void</span> RCPtr&lt;T&gt;::<span class="built_in">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pointee-&gt;<span class="built_in">isShareable</span>() == <span class="literal">false</span>)</span><br><span class="line">        pointee = <span class="keyword">new</span> <span class="built_in">T</span>(*pointee);</span><br><span class="line">    pointee-&gt;<span class="built_in">addReference</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(T *realPtr) : <span class="built_in">pointee</span>(realPtr) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;::<span class="built_in">RCPtr</span>(<span class="keyword">const</span> RCPtr &amp;rhs) : <span class="built_in">pointee</span>(rhs.pointee) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;::~<span class="built_in">RCPtr</span>() &#123; <span class="keyword">if</span> (pointee) pointee-&gt;<span class="built_in">removeReference</span>(); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T* RCPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> pointee; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> T&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *pointee; &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> RCPtr&lt;T&gt;&amp; RCPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pointee != rhs.pointee)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointee) pointee-&gt;<span class="built_in">removeReference</span>();</span><br><span class="line">        pointee = rhs.pointee;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RCObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeReference</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">markUnshareable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShareable</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isShared</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">RCObject</span>();</span><br><span class="line">    <span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject &amp;rhs);</span><br><span class="line">    RCObject&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject &amp;rhs);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RCObject</span>() = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> refCount;</span><br><span class="line">    <span class="keyword">bool</span> shareable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RCObject::<span class="built_in">RCObject</span>() : <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject::<span class="built_in">RCObject</span>(<span class="keyword">const</span> RCObject&amp;) : <span class="built_in">refCount</span>(<span class="number">0</span>), <span class="built_in">shareable</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">RCObject&amp; RCObject::<span class="keyword">operator</span>=(<span class="keyword">const</span> RCObject&amp;) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">RCObject::~<span class="built_in">RCObject</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::addReference</span><span class="params">()</span> </span>&#123; ++refCount; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::removeReference</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (--refCount == <span class="number">0</span>) <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RCObject::markUnshareable</span><span class="params">()</span> </span>&#123; shareable == <span class="literal">false</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShareable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> shareable; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RCObject::isShared</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> refCount &gt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *value = <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringValue</span> :</span> <span class="keyword">public</span> RCObject</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *data;</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue);</span><br><span class="line">        <span class="built_in">StringValue</span>(<span class="keyword">const</span> StringValue &amp;rhs);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span></span>;</span><br><span class="line">        ~<span class="built_in">StringValue</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    RCPtr&lt;StringValue&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> String::StringValue::<span class="built_in">init</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue)</span><br><span class="line">&#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(initValue) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, initValue);</span><br><span class="line">&#125;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue) &#123; <span class="built_in">init</span>(initValue); &#125;</span><br><span class="line">String::StringValue::<span class="built_in">StringValue</span>(<span class="keyword">const</span> StringValue&amp; rhs) &#123; <span class="built_in">init</span>(rhs.data); &#125;</span><br><span class="line">String::StringValue::~<span class="built_in">StringValue</span>() &#123; <span class="keyword">delete</span> []data; &#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *initValue) : <span class="built_in">value</span>(<span class="keyword">new</span> <span class="built_in">StringValue</span>(initValue)) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> value-&gt;data[index]; &#125;</span><br><span class="line"><span class="keyword">char</span>&amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value-&gt;<span class="built_in">isShared</span>())</span><br><span class="line">        value = <span class="keyword">new</span> <span class="built_in">StringValue</span>(value-&gt;data);</span><br><span class="line">    value-&gt;<span class="built_in">markUnshareable</span>();</span><br><span class="line">    <span class="keyword">return</span> value-&gt;data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="条款30：Proxy-classes（替身类、代理类）"><a href="#条款30：Proxy-classes（替身类、代理类）" class="headerlink" title="条款30：Proxy classes（替身类、代理类）"></a>条款30：Proxy classes（替身类、代理类）</h4><ol>
<li>通过一个类对象来象征一个其他对象，常被称为<font color=green>proxy objects</font>（<font color=red>替身对象</font>）。它允许我们完成某些十分困难或几乎不可能完成的行为。多维数组是其中之一，左值/右值的区分是其中之二，压抑隐式转换是其中之三。</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/reasno/p/4858490.html">https://www.cnblogs.com/reasno/p/4858490.html</a></li>
</ol>
<h4 id="条款31：让函数根据一个以上的对象类型来决定如何虚化"><a href="#条款31：让函数根据一个以上的对象类型来决定如何虚化" class="headerlink" title="条款31：让函数根据一个以上的对象类型来决定如何虚化"></a>条款31：让函数根据一个以上的对象类型来决定如何虚化</h4><ol>
<li>假设设计一个游戏，根据宇宙飞船、太空站和小行星三者的共同特征，设计为以下情况： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">A[SpaceShip] --&gt; S(GameObject) </span><br><span class="line">B[SpaceStation] --&gt; S</span><br><span class="line">C[Asteroid] --&gt; S</span><br></pre></td></tr></table></figure>
 整个继承体系： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> :</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span> :</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span> :</span> <span class="keyword">public</span> GameObject &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
 不同对象相撞要有不同的规则，处理碰撞的函数声明像这样： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkForCollision</span><span class="params">(GameObject &amp;object1, GameObject &amp;object2)</span></span>;</span><br></pre></td></tr></table></figure>
 现在挑战出来了，处理他们之间的碰撞，首先得知道它们的动态类型。人们常把面向对象里虚函数的调用动作称为<font color=green>&gt;message dispatch</font>（<font color=red>消息分派</font>）。然而C++并不直接支持multiple dispatch。</li>
</ol>
<h5 id="虚函数-RTTI（运行时期类型识别）"><a href="#虚函数-RTTI（运行时期类型识别）" class="headerlink" title="虚函数 + RTTI（运行时期类型识别）"></a>虚函数 + RTTI（运行时期类型识别）</h5><ol start="2">
<li>最一般化的double-dispatching实现方法是用<font color=red><strong>if-then-elses</strong></font>来仿真虚函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">calss SpaceShip : <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果和一个未知类型对象相撞，就抛出以下exception</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollisionWithUnknownObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CollisionWithUnknownObject</span>(GameObject &amp;whatWeHit);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject &amp;otherObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type_info &amp;objectType = <span class="built_in"><span class="keyword">typeid</span></span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span> (objectType == <span class="built_in"><span class="keyword">typeid</span></span>(SpaceShip)) &#123;</span><br><span class="line">        SpaceShip &amp;ss = <span class="keyword">static_cast</span>&lt;SpaceShip&amp;&gt;(otherObject);</span><br><span class="line">        <span class="comment">// process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="built_in"><span class="keyword">typeid</span></span>(SpaceStation)) &#123;</span><br><span class="line">        SpaceStation &amp;ss = <span class="keyword">static_cast</span>&lt;SpaceStation&amp;&gt;(otherObject);</span><br><span class="line">        <span class="comment">// process a SpaceShip-SpaceStation collision;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectType == <span class="built_in"><span class="keyword">typeid</span></span>(Asteroid)) &#123;</span><br><span class="line">        Asteroid &amp;a = <span class="keyword">static_cast</span>&lt;Asteroid&amp;&gt;(otherObject);</span><br><span class="line">        <span class="comment">// sprocess a SpaceShip-Asteroid collision;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">CollisionWithUnknownObject</span>(otherObejct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 我们只需要决定碰撞双方的其中一个类型，因为另一个对象是*this，它的类型被虚函数机制决定下来了，是SpaceShip对象。<br> 这种以类型为行事基准的方法有个缺点：它会造成程序难以维护。这就是虚函数当初被发明出来的原因：把生产维护以类型为行事基准的函数的负担，从程序员转到编译器。但现在如果使用RTTI来实现double-dispatching，等于回到老而糟糕的年代。</li>
</ol>
<h5 id="只使用虚函数"><a href="#只使用虚函数" class="headerlink" title="只使用虚函数"></a>只使用虚函数</h5><ol start="3">
<li>看看如何只以虚函数来解决问题： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span>;</span>    <span class="comment">// forward declarations</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceStation</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asteroid</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObjet &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> :</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObjet &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceShip &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(SpaceStation &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(Asteroid &amp;otherObject)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 这种方法将double-dispatching以两个分离的虚函数调用实现出来的。这并不是递归调用。第一个虚函数调用动作针对的是接收GameObject&amp;参数的collide函数，有点简单： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    otherObject.<span class="built_in">collide</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(SpaceShip &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(SpaceStation &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// processa SpaceShip-SpaceStation collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> SpaceShip:<span class="built_in">collide</span>(Asteroid &amp;otherObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// process SpaceShip-Asteroid collision;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 但这种做法成本太高，每次修改需要在每个class中增添（E34）。但它也有好处，那就是不再因为为止类型而不得不抛出异常。</li>
</ol>
<h5 id="自行仿真虚函数表格（Virtual-Function-Tables）"><a href="#自行仿真虚函数表格（Virtual-Function-Tables）" class="headerlink" title="自行仿真虚函数表格（Virtual Function Tables）"></a>自行仿真虚函数表格（Virtual Function Tables）</h5><ol start="4">
<li>回忆条款24，编译器通过vtbl直接索引取得函数指针，而不必条条框框if-then-else运算。这样一来效率也高，也可以当使用RTTI的时候隔离至一个点：vtbl的初始化处。<br> 先从GameObject继承体系内的函数开始： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> :</span> <span class="keyword">public</span> GameObject &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(GameObject &amp;otherObject)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceShip</span><span class="params">(GameObject &amp;spaceShip)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitSpaceStation</span><span class="params">(GameObject &amp;spaceStation)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">hitAsteroid</span><span class="params">(GameObject &amp;asteroid)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">typeef <span class="title">void</span> <span class="params">(SpaceShip::*HitFunctionPtr)</span><span class="params">(GameObject&amp;)</span></span>;</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;string, HitFunctionPtr&gt; HitMap;</span><br><span class="line">    <span class="comment">// 产生中介函数lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> hitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> GameObject &amp;whaWeHit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span>;      </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceShip</span><span class="params">(SpaceShip &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SpaceShip &amp;otherShip = <span class="keyword">dynamic_cast</span>&lt;SpaceShip&amp;&gt;(spaceShip);</span><br><span class="line">    <span class="comment">// process a SpaceShip-SpaceShip collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitSpaceStation</span><span class="params">(SpaceStation &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SpaceStation &amp;station = <span class="keyword">dynamic_cast</span>&lt;SpaceStation&amp;&gt;(spaceStation);</span><br><span class="line">    <span class="comment">// process a SpaceShip-SpaceStation collision;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::hitAsteroid</span><span class="params">(Asteroid &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Asteroid &amp;theAsteroid = <span class="keyword">dynamic_cast</span>&lt;Asteroid&amp;&gt;(asteroid);</span><br><span class="line">    <span class="comment">// process a SpaceShip-Asteroid collision;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpaceShip::collide</span><span class="params">(GameObject &amp;otherObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 找出调用的函数</span></span><br><span class="line">    HitFunctionPtr hfp = <span class="built_in">lookup</span>(otherObject);</span><br><span class="line">    <span class="keyword">if</span> (hfp) (<span class="keyword">this</span>-&gt;*hfp)(otherObject);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">CollisionWithUnknownObject</span>(otherObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SpaceShip::HitMap* <span class="title">SpaceShip::initializeCollisionMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">    (*phm)[<span class="string">&quot;SpaceShip&quot;</span>] = &amp;hitSapceShip;</span><br><span class="line">    (*phm)[<span class="string">&quot;SpaceStation&quot;</span>] = &amp;hitSpaceStation;</span><br><span class="line">    (*phm)[<span class="string">&quot;Asteroid&quot;</span>] = &amp;hitAsteroid;</span><br><span class="line">    <span class="keyword">return</span> phm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SpaceShip::HitFunctionPtr <span class="title">SpaceShip::lookup</span><span class="params">(<span class="keyword">const</span> GameObject &amp;whatWeHit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> auto_ptr&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">    HitMap::iterator mapEntry = collisionMap.<span class="built_in">find</span>(<span class="built_in"><span class="keyword">typeid</span></span>(whatWeHit).<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">if</span> (mapEntry == collisionMap.<span class="built_in">end</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 跟一开始说的RTTI解法一样，GameObject class只含有一个碰撞处理函数，这个函数执行两个必要的<strong>single-dispatches</strong>中的第一个。而其他互动函数不再使用同一个collide名称，放弃了重载。<br> 这里我们需要交付给一个中介函数lookup一个GameObject，它会返回一个指向”当和GameObject相撞时“必须调用的函数的指针（<font  color=red>函数指针</font>）。为了能够动态映射某个member function指针，一个简单的方法是产生一个关系型（associative）数组，只要获得class名字，导出member function指针（key-value？)。</li>
</ol>
<h5 id="将自行仿真的虚函数表格（Virtual-Function-Tables）初始化"><a href="#将自行仿真的虚函数表格（Virtual-Function-Tables）初始化" class="headerlink" title="将自行仿真的虚函数表格（Virtual Function Tables）初始化"></a>将自行仿真的虚函数表格（Virtual Function Tables）初始化</h5><ol start="5">
<li>对于collisionMap的初始化问题，只需要写一个private static member function，名为initializeCollisionMap，用来初始化，然后返回值作为初值就可以了。然而返回值Map按值传递意味着构造和析构成本，如果返回指针，又要苦恼map对象的delete时宜，那么用smart pointer吧(见上面完整实现)。</li>
</ol>
<h5 id="使用”非成员（Non-Member）函数“的碰撞处理函数"><a href="#使用”非成员（Non-Member）函数“的碰撞处理函数" class="headerlink" title="使用”非成员（Non-Member）函数“的碰撞处理函数"></a>使用”非成员（Non-Member）函数“的碰撞处理函数</h5><ol start="6">
<li>当有新的class加入时,继承体系的每个类都需要添加处理新型碰撞的代码.这是因为此前的策略都是将处理碰撞的任务交由碰撞的某一方来执行,仿真虚函数表策略也不例外——每个class内含一个仿真的虚函数表,内含的指针也都指向成员函数。将碰撞处理函数设为non-member,就可以使得class定义式不包含碰撞处理函数,当需要添加碰撞处理函数时也就不需要修改class定义。将碰撞处理函数移出class外，成为中立的第三者处理，则构筑processCollision函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SpaceShip.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SpaceStation.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Asteroid.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名namespace具有文件内部static的功效</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要的碰撞处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject &amp;spaceShip, GameObject &amp;asteroid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shipStation</span><span class="params">(GameObject &amp;spaceShip, GameObject &amp;spaceStation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">asteroidStation</span><span class="params">(GameObject &amp;asteroid, GameObject &amp;spaceStation)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 次要的碰撞处理函数，只是为了实现对称性</span></span><br><span class="line"><span class="comment">// 对调参数位置，然后调用主要的碰撞处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">asteroidShip</span><span class="params">(GameObject &amp;asteroid, GameObject &amp;spaceShip)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">shipAsteroid</span>(spaceShip, asteroid); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stationShip</span><span class="params">(GameObject &amp;spaceStation, GameObject &amp;spaceShip)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">shipStation</span>(spaceShip, spaceStation); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stationAsteroid</span><span class="params">(GameObject &amp;spaceStation, GameObject &amp;asetroid)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">asteroidStation</span>(asteroid, spaceSation); &#125;</span><br><span class="line">... </span><br><span class="line"><span class="comment">// types/functions</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*HitFunctionPtr)</span><span class="params">(GameObject&amp;, GameObject&amp;)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> map&lt; pair&lt;string, string&gt;, HitFunctionPtr &gt; HitMap;</span><br><span class="line"><span class="comment">// 以两个char*字面常量产生一个pair&lt;string, string&gt;对象</span></span><br><span class="line"><span class="function">pair&lt;string, string&gt; <span class="title">makeStringPair</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> pair&lt;string, string&gt;(s1, s2); &#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">HitMap* <span class="title">initializeCollisionMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitMap *phm = <span class="keyword">new</span> HitMap;</span><br><span class="line">    (*phm)[<span class="built_in">makeStringPair</span>(<span class="string">&quot;SpaceShip&quot;</span>, <span class="string">&quot;Asteroid&quot;</span>)] = &amp;shipAsteroid;</span><br><span class="line">    (*phm)[<span class="built_in">makeStringPair</span>(<span class="string">&quot;SpaceShip&quot;</span>, <span class="string">&quot;SpaceStation&quot;</span>)] = &amp;shipStation;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> phm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须修改，以便接纳pair&lt;string, string&gt;对象</span></span><br><span class="line"><span class="function">HitFunctionPtr <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> string class1, <span class="keyword">const</span> string &amp;class2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> auto_ptr&lt;HitMap&gt; <span class="title">collisionMap</span><span class="params">(initializeCollisionMap())</span></span>;</span><br><span class="line">    HitMap::iterator mapEntry = collisionMap-&gt;<span class="built_in">find</span>(<span class="built_in">make_pair</span>(class1, class2));</span><br><span class="line">    <span class="keyword">if</span> (mapEntry == collisionMap-&gt;<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (*mapEntry).second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processCollision</span><span class="params">(GameObject &amp;object1, GameObject &amp;object2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HitFunctinoPtr phf = <span class="built_in">lookup</span>(<span class="built_in"><span class="keyword">typeid</span></span>(object1).<span class="built_in">name</span>(), <span class="built_in"><span class="keyword">typeid</span></span>(object2).<span class="built_in">name</span>());</span><br><span class="line">    <span class="keyword">if</span> (phf) <span class="built_in">phf</span>(object1, object2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">UnknownCollision</span>(object1, object2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这份实现和先前的member functions版相同，但略有差异：<ul>
<li><font color=red>HitFunctionPtr</font>如今是一个指向non-member function的指针。</li>
<li><font color=red>exception class CollsionWithUnknownObject</font>已经被重新命名为UnknownCollision并改为取得两个对象。</li>
<li><font color=red>lookup</font>需要接收两个类型名称，并执行double-dispatch的完整两半。</li>
</ul>
 这意味着collision map需要持有三份信息：<strong>两个类型名称和一个HitFunctionPtr</strong>。<br> 由于makeStringPair，initializationCollisionMap，lookup都声明于匿名namespace内，因此它们必须实现于相同的namesapce中，使得<strong>链接器能够正确的将定义和声明关联起来</strong>。<br> <strong>通过将碰撞处理函数从类中分离,实现了即使新的GameObject被添加,原有的class也不需要重新编译,只需要在initializeCollisionMap中增加对应的键-值对,并在processCollision所在的匿名命名空间中申明一个新的碰撞处理函数即可</strong>。</li>
</ol>
<h5 id="”继承“-”自行仿真的虚函数表格“"><a href="#”继承“-”自行仿真的虚函数表格“" class="headerlink" title="”继承“ + ”自行仿真的虚函数表格“"></a>”继承“ + ”自行仿真的虚函数表格“</h5><ol start="7">
<li>目前所做的每一件事都可以有效运作——只要在调用碰撞处理函数时不发生<font color=red><strong>inheritance-based类型转换</strong></font>。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">A[SpaceStation] --&gt; G</span><br><span class="line">S(SpaceShip) --&gt; G(GameObject)</span><br><span class="line">B[Asteroid] --&gt; G</span><br><span class="line">C[CommercialShip] --&gt; S</span><br><span class="line">D[MilitaryShip] --&gt; S</span><br></pre></td></tr></table></figure>
 如果MilitaryShip和一个Asteroid碰撞，希望调用的时： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shipAsteroid</span><span class="params">(GameObject &amp;spaceShip, GameObject &amp;asteroid)</span></span>;</span><br></pre></td></tr></table></figure>
 然而事非如此，而是抛出一个<font color=red>UnknownCollision exception</font>。虽然MilitaryShip对象可视为一个SpaceShip对象，但lookup并不知道。<br> 如果想要实现double-dispatching而且需要支持inheritance-based参数转换，那么唯一可用的资源是<strong>”双虚函数调用“机制</strong>。</li>
</ol>
<h5 id="将自行仿真的虚函数表格初始化（再度讨论）"><a href="#将自行仿真的虚函数表格初始化（再度讨论）" class="headerlink" title="将自行仿真的虚函数表格初始化（再度讨论）"></a>将自行仿真的虚函数表格初始化（再度讨论）</h5><ol start="8">
<li></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/4-%E6%95%88%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/4-%E6%95%88%E7%8E%87/" class="post-title-link" itemprop="url">4 效率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:52:02" itemprop="dateCreated datePublished" datetime="2020-06-14T13:52:02+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-03/" itemprop="url" rel="index"><span itemprop="name">2019.03</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E4%BE%8B16%EF%BC%9A%E8%B0%A8%E8%AE%B080-20%E5%8E%9F%E5%88%99">条例16：谨记80-20原则</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8lazy-evaluation%EF%BC%88%E7%BC%93%E5%BC%8F%E8%AF%84%E4%BC%B0%EF%BC%89">条款17：考虑使用lazy evaluation（缓式评估）</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E5%88%86%E6%9C%9F%E6%91%8A%E8%BF%98%E9%A2%84%E6%9C%9F%E7%9A%84%E8%AE%A1%E7%AE%97%E6%88%90%E6%9C%AC">条款18：分期摊还预期的计算成本</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E4%BA%86%E8%A7%A3%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9D%A5%E6%BA%90">条款19：了解临时对象的来源</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%8D%8F%E5%8A%A9%E5%AE%8C%E6%88%90%E2%80%9C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96%EF%BC%88rvo%EF%BC%89%E2%80%9C">条款20：协助完成“返回值优化（RVO）“</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%88%A9%E7%94%A8%E9%87%8D%E8%BD%BD%E6%8A%80%E6%9C%AF%EF%BC%88overload%EF%BC%89%E9%81%BF%E5%85%8D%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88implicit-type-conversions%EF%BC%89">条款21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E8%80%83%E8%99%91%E4%BB%A5%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%AC%A6%E5%90%88%E5%BD%A2%E5%BC%8F%EF%BC%88op==%EF%BC%89%E5%8F%96%E4%BB%A3%E5%85%B6%E7%8B%AC%E8%BA%AB%E5%BD%A2%E5%BC%8F%EF%BC%88op%EF%BC%89">条款22：考虑以操作符符合形式（op==）取代其独身形式（op）</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E5%BA%93">条款23：考虑使用其他程序库</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E4%BA%86%E8%A7%A3virtual-functions%E3%80%81multiple-inheritance%E3%80%81virtual-base-classes%E3%80%81runtime-type-identification%E7%9A%84%E6%88%90%E6%9C%AC">条款24：了解virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条例16：谨记80-20原则"><a href="#条例16：谨记80-20原则" class="headerlink" title="条例16：谨记80-20原则"></a>条例16：谨记80-20原则</h4><ol>
<li>80-20原则说：一个程序80%的资源用于20%的代码身上。因此根据观察或实验来识别出造成你心痛那20%代码，辨别之道就是使用某个程序分析器（program profiler）。</li>
</ol>
<h4 id="条款17：考虑使用lazy-evaluation（缓式评估）"><a href="#条款17：考虑使用lazy-evaluation（缓式评估）" class="headerlink" title="条款17：考虑使用lazy evaluation（缓式评估）"></a>条款17：考虑使用lazy evaluation（缓式评估）</h4><ol>
<li><font color=green>lazy evaluation</font>（<font color=red>缓式评估</font>）就是以某种方式撰写你的classes，使它们延缓运算，直到那些运算结果刻不容缓地迫切需要为止。其运算结果一直不需要，运算也就一直不执行。lazy evaluation有以下4种常见用途：<ul>
<li><strong>Reference Counting（引用计数）</strong>。可避免非必要的对象赋值。lazy做法可以省下许多工作，string s1和string s2是两个字符串对象，我们让s2以s1为初值，而当s2的值需要修改时，才求取其值。那么我们可以在s2在需要被修改前，使用s1和s2的共享数据，直到需要被修改时才创建s2副本。</li>
<li><strong>区分读和写</strong>。对于一个类的operator[]调用动作，可能为了写或读，而运用lazy evaluatino和proxy classes，可以延缓决定究竟是读是写。</li>
<li><strong>lazy fetching（缓式取出）</strong>。可避免非必要的数据库读取动作。产生一个对象时，只产生相应的“外壳”，不从磁盘读取任何数据，直至被需要时，才求取。这个可以使用smart pointer或者mutable修饰在const member functions里头判断并决定是否求取赋值。</li>
<li><strong>lazy expression evaluation（表达式缓评估）</strong>。可避免非必要的数值计算动作。</li>
</ul>
</li>
</ol>
<h4 id="条款18：分期摊还预期的计算成本"><a href="#条款18：分期摊还预期的计算成本" class="headerlink" title="条款18：分期摊还预期的计算成本"></a>条款18：分期摊还预期的计算成本</h4><ol>
<li>与lazy evaluation不同的是，<font color=red>超急评估</font>（<font color=green>over-eager evaluation</font>）超前进度地做“要求以外”的更多工作。举个例子，有个class template用来表现大型数据收集中心： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NumbercalType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataCollection</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">NumercalType <span class="title">min</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">NumercalType <span class="title">max</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">NumercalType <span class="title">avg</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 这个函数的实现方法有三种：<ul>
<li><strong>eager evaluation</strong>：被调用时返回结果。</li>
<li><strong>lazy evaluation</strong>：函数的返回值需要被派上用场时，决定适当值。</li>
<li><strong>over-eager evaluation</strong>：随实记录程序执行过程中数据集的最小值、最大值和平均值。一旦被调用，立刻返回正确值无需再计算。这种方式通过频繁的调用<strong>摊还成本</strong>。  </li>
</ul>
 <strong>Caching</strong>时“分期摊还预期计算成本”的一种做法。<strong>Prefetching（预先取出）</strong>则是另一个种做法。可以想象它是大批购买物品后的折扣。因为磁盘控制器从磁盘读取数据时，读的是整个数据块或sectors。经验显示，<em>如果某处数据被需要，通常其邻近的数据也被需要</em>。这就是有名的<font color=red>locality of reference现象</font>。系统设计者以此现象设计出<font color=red>磁盘缓存</font>（<font color=green>disk caches</font>）、<font color=red>指令与数据的内存缓存</font>（<font color=green>memory caches</font>）以及<font color=red>指令预先取出</font>（<font color=green>instruction prefetches</font>）。</li>
<li>加入要实现一个动态数组的template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynArray</span> &#123;</span> ... &#125;;</span><br><span class="line">DynArray&lt;<span class="keyword">double</span>&gt; a;</span><br><span class="line">a[<span class="number">22</span>] = <span class="number">3.5</span>;</span><br><span class="line">a[<span class="number">32</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
 它怎么扩张自己？做内存动态分配行为： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;clas T&gt;</span><br><span class="line">T&amp; DynArray&lt;T&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> an exception;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; the current maximum index value) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = index - the current maximum index value;</span><br><span class="line">        </span><br><span class="line">        call <span class="keyword">new</span> to allocate enough additional memory so that index+diff is valid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> the indexth element of the array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 增加数组大小会调用new，但new会调用operator new，而operator new通常代价昂贵，因为它们会调用底层操作系统，而系统调用比进程内的函数调用速度慢，所以尽量不要系统调用。这时就可以使用over-eager evaluation（超急评估）策略，通过增加额外的数组大小来降低不久的下次可能再扩张时的成本。</li>
</ol>
<h4 id="条款19：了解临时对象的来源"><a href="#条款19：了解临时对象的来源" class="headerlink" title="条款19：了解临时对象的来源"></a>条款19：了解临时对象的来源</h4><ol>
<li>程序员交谈的时候往往把一个短暂需要的变量称为临时变量，但在C++中它并不是临时对象，只是函数中的一个局部对象。C++真正的临时对象是不可见的。只要产生一个<strong>non-heap object</strong>而没有为它命名，就是临时对象。这种匿名对象发生于两种情况：一是<strong>隐式类型转换（implicit type conversions）</strong>；二是<strong>函数返回对象</strong>。<ul>
<li>第一种考虑为了让函数调用成功而产生的临时对象，发生在传递某对象给一个函数，而其类与它即将绑定上去的参数类型不同：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回ch在str中出现的个数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">countChar</span><span class="params">(<span class="keyword">const</span> string &amp;str, <span class="keyword">char</span> ch)</span></span>;</span><br><span class="line"><span class="keyword">char</span> buffer[MAX_STRING_LEN];</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="comment">// 读入一个char和一个string，利用setw避免读入string时缓冲区满溢的情况</span></span><br><span class="line">std::cin &gt;&gt; c &gt;&gt; <span class="built_in">setw</span>(MAX_STRING_LEN) &gt;&gt; buffer;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;There are &quot;</span> &lt;&lt; <span class="built_in">countChar</span>(buffer, c)</span><br><span class="line">    &lt;&lt; <span class="string">&quot; occurrences of the character &quot;</span> &lt;&lt; c</span><br><span class="line">    &lt;&lt; <span class="string">&quot; in &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
编译器擦除了类型不吻合的状态：以buffer作为自变量，调用string constructor，countChar的str参数绑定于此string临时对象上。当countChar返回，此临时对象自动销毁。只有当对象以by value或当对象传给一个reference-to-const参数时转换才会发生。</li>
<li>第二种会产生临时对象的情况是当函数返回一个对象时。例如operator+的返回对象。</li>
</ul>
</li>
</ol>
<h4 id="条款20：协助完成“返回值优化（RVO）“"><a href="#条款20：协助完成“返回值优化（RVO）“" class="headerlink" title="条款20：协助完成“返回值优化（RVO）“"></a>条款20：协助完成“返回值优化（RVO）“</h4><ol>
<li>函数如果返回对象，对于效率狂来说是个严重的溃败，因为以by-value方式返回对象，背后隐藏的constructor和destructor都将无法消除。而如果以by-pointer方式返回对象，对于其删除指针的操作通常会遗忘而导致资源泄露（resource leaks）。甚至以by-reference返回对象，那也是一个错误的行为，它返回的reference指向一个不再存活的对象。</li>
<li>我们可以用某种特殊写法来撰写函数， 使它在返回对象时能够让编译器消除临时变量的成本。这个伎俩就是：返回所谓的<font color=red><strong>constructor arguments</strong></font>以取代对象： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回对象：最有效率的做法。</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 它返回了一个表达式，该表达式调用了一个Rational constructor，这是一个临时对象，而函数复制此临时对象。<br> C++允许编译器将临时对下个你优化。编译器消除operator*内的临时对象及被operaotr*返回的临时对象。它可以让return表达式所定义的对象构造于所绑定的命名对象的内存内。如果编译器这么做，调用operator*的临时对象的总成本为0。甚至还可以声明为inline，以消除调用operator*所花费的额外开销。这种特殊的优化行为甚至有个专属名称：<font color=red>return value optimization</font>。</li>
</ol>
<h4 id="条款21：利用重载技术（overload）避免隐式类型转换（implicit-type-conversions）"><a href="#条款21：利用重载技术（overload）避免隐式类型转换（implicit-type-conversions）" class="headerlink" title="条款21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）"></a>条款21：利用重载技术（overload）避免隐式类型转换（implicit type conversions）</h4><ol>
<li>对于解决可能操作符运算隐式的内置类型转换为用户定制类型产生的临时变量，有个办法是为该操作符重载一个内置参数的版本。</li>
</ol>
<h4 id="条款22：考虑以操作符符合形式（op-）取代其独身形式（op）"><a href="#条款22：考虑以操作符符合形式（op-）取代其独身形式（op）" class="headerlink" title="条款22：考虑以操作符符合形式（op==）取代其独身形式（op）"></a>条款22：考虑以操作符符合形式（op==）取代其独身形式（op）</h4><ol>
<li>大部分程序员希望，如果他们能<code>x = x + y;</code>这么写，那么他们也能够<code>x += y</code>这么写。如果x和y属于定制类型，就不保证如此，到目前为止C++并不考虑在operator+，operator=和operator+=之间设立任何互动关系。除非自己实现。确保操作符的<font color=red>复合形式</font>（operator+=）和<font color=red>独身形式</font>（operator+）之间的自然关系能够存在，一个好办法就是<strong>以前者为基础实现后者</strong>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">const</span> T <span class="keyword">operator</span>+(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="built_in">T</span>(lhs) += rhs; &#125;</span><br><span class="line"></span><br><span class="line">Rational a, b, c, d, result;</span><br><span class="line"><span class="comment">// 会用到3个临时变量</span></span><br><span class="line">result = a + b + c + d;</span><br><span class="line"><span class="comment">// 不需要临时变量，效率比上面的好</span></span><br><span class="line"><span class="comment">// 如果同时供应两种选择，便于客户较易理解的操作符独身版之余，同时保留了更有效率的符合版本</span></span><br><span class="line">result = a;</span><br><span class="line">result += b;</span><br><span class="line">result += c;</span><br><span class="line">result += d;</span><br></pre></td></tr></table></figure>
 T(lhs)是个调用动作，调用T的copy constructor，它会产生一个临时变量，然后临时变量被用来调用operator+=： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">const</span> T <span class="keyword">operator</span>+(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">T <span class="title">result</span><span class="params">(lhs)</span></span>;          <span class="comment">// 将lhs复制发给result</span></span><br><span class="line">    <span class="keyword">return</span> result += rhs;   <span class="comment">// 将rhs加到result上然后返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这个template几乎等同于上一个，但是有个重要差异。第二个template内含了一个命名对象，这意味着<font color=red>返回值优化</font>（<font color=green>return value optimization</font>）无法施展于此operator+。</li>
</ol>
<h4 id="条款23：考虑使用其他程序库"><a href="#条款23：考虑使用其他程序库" class="headerlink" title="条款23：考虑使用其他程序库"></a>条款23：考虑使用其他程序库</h4><ol>
<li>理想的程序库应该小、快速、威力强大、富弹性、有扩展性、直观、可广泛使用、有良好支持，使用时没有束缚，而且没有臭虫。然而这时不存在的。如果针对大小和速度做优化，通常不具移植性，如果有丰富性能，就不容易直观，没有臭虫的程序库只能在乌托邦中寻找。</li>
<li>检验一个极为简单的性能评估软件，它只测试基本的IO机能。这个程序从标准输入读取30,000个浮点数，然后以固定格式将它们写到标准输出设备。程序用iostream还是stdio取决于预处理器符号STDIO： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STDIO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> VALUES = <span class="number">30000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= VALUES; ++n)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> STDIO</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;d);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%10.5f&quot;</span>, d);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        std::cin &gt;&gt; d;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>)</span><br><span class="line">                  &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">5</span>)</span><br><span class="line">                  &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::showpoint)</span><br><span class="line">                  &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::fixed)</span><br><span class="line">                  &lt;&lt; d;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STDIO</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 iostreams也可以产生固定格式的I/O，虽然不易写。但是operator&lt;&lt;不但类型安全而且可扩充，而printf两者皆否。stdio版有时候比iostream只是块一点点（20%），有时候很多（200%）。</li>
</ol>
<h4 id="条款24：了解virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification的成本"><a href="#条款24：了解virtual-functions、multiple-inheritance、virtual-base-classes、runtime-type-identification的成本" class="headerlink" title="条款24：了解virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本"></a>条款24：了解virtual functions、multiple inheritance、virtual base classes、runtime type identification的成本</h4><ol>
<li>了解编译器以什么样的方法来实现它们是件重要的事情。其中最重要的就是虚函数。当一个虚函数被调用，执行的代码对应于调用者对象的类型。对象的pointer或reference，其类型是无形的，编译器是用<font color=red>virtual tables</font>和<font color=red>virtual table pointers</font>，通常被简写为vtbls和vptrs。<ul>
<li><font color=red>vtbl</font>通常是由函数指针架构而成的数组（有些是用链表）。<strong>程序中每个class凡声明（或继承）虚函数者，都有自己的一个vtbl，而其中的<font  color=red>条目</font>（<font color=green>entires</font>）就是该class的各个虚函数实现体的指针</strong>。这就是虚函数的<font color=red><strong>第一个成本</strong></font>：<strong>必须为每个拥有虚函数的class耗费一个vtbl空间，空间大小视虚函数的个数（包括继承而来的）而定</strong>。</li>
<li>凡声明由虚函数的class，其对象都含有一个隐藏的data member，用来指向该class的vtbl。这个隐藏的data member——所谓的<font color=red>vptr</font>——被编译器加入对象内某个只有编译器才知道的位置。这是虚函数的<font color=red><strong>第二个成本</strong></font>：<strong>必须在每个拥有虚函数的对象内付出一个额外指针的代价</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C1</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C1</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> :</span> <span class="keyword">public</span> C1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C2</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C2</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f5</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeACall</span><span class="params">(C1 *pC1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pC1-&gt;<span class="built_in">f1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器必须产生代码，完成以下动作：</li>
</ul>
<ol>
<li><strong>根据对象的vptr找出其vbl</strong>。因为编译器知道去哪里找vptr。成本只有<strong>一个<font color=red>偏移调整</font>（<font color=green>offset adjustment</font>，以便获得vptr）</strong>和<strong>一个指针间接动作（以便获得vtbl）</strong>。</li>
<li><strong>找出被调用函数（f1）在vtbl内的对应指针</strong>。成本只是一个<strong>差移（offset）</strong>。</li>
<li><strong>调用步骤2所得指针所指向的函数</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想象一下每个对象都有隐藏的data member称为vtpr，而函数发</span></span><br><span class="line">的vtbl索引是i</span><br><span class="line"><span class="comment">// 那么先前语句</span></span><br><span class="line">pC1-&gt;<span class="built_in">f1</span>();</span><br><span class="line"><span class="comment">// 产生的代码将是：</span></span><br><span class="line">(*pC1-&gt;vptr[i])(pC1);</span><br><span class="line"><span class="comment">// 调用pC1-&gt;vptr所指的vtbl中的第i条目所指函数。</span></span><br><span class="line"><span class="comment">// 然后pC1被传给该函数的this指针所用</span></span><br></pre></td></tr></table></figure>
这几乎和一个非虚函数的效率相当。它调用虚函数的成本基本和通过一个函数指针来调用函数相同。虚函数本身不构成性能上的瓶颈。<br>虚函数真正的运行期成本发生在和inlining互动的时候。虚函数不应该inlined。因为<strong>inline意味着在编译期，将调用端的调用动作被调用函数的函数本体所取代，而virtual则意味着等待，直到运行期间才知道哪个函数被调用</strong>。这就是虚函数的<font color=red><strong>第三个成本</strong></font>：<strong>事实上等同于放弃了inlining。</strong>（如果虚函数通过对象被调用，是可以inlined的，但大部分虚函数调用动作是通过对象的指针或references完成的，这行为无法被inlined，所以虚函数等于无法被inlined。）<br>在多重继承的情况下，情况变得有些复杂，一个对象可能包含多个vptr（每个base class各对应一个），这使得空间负担更大，运行期的调用成本也有增长。<br>多重继承往往导致virtual base classes（虚拟基类）的需求。virtual base classes可导致另一种成本，当利用指针或references指向某个virtual base class成分时，对象内可能出现多个这样的指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123; ... &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><font color=red>运行时期类型辨识</font>（<font color=green>runtime type identification</font>, <font color=red>RTTI</font>）让我们在运行期获得objects和classes的相关信息，它们被存放在类型为type_info的对象内。可以利用<code>typeid</code>操作符取得某个class相应的type_info对象。只有当某种类型拥有至少一个虚函数，才保证我们能检验该类型对象的动态类型。它是个根据class的vtbl来实现的。RTTI的空间成本就只需在每个class vtbl内增加一个条目，再加上每个class所需的一份type_info对象空间。<table>
<thead>
<tr>
<th>性质</th>
<th>对象大小增加</th>
<th>Class数据量增加</th>
<th>Inlining几率降低</th>
</tr>
</thead>
<tbody><tr>
<td>虚函数<br>Virtual Functions</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>多重继承<br>Multiple Inheritance</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>虚拟基类<br>Virtual Base Classes</td>
<td>往往如此</td>
<td>有时候</td>
<td>否</td>
</tr>
<tr>
<td>运行时期类型标识<br>RTTI</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/3-%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/3-%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">3 异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:51:56" itemprop="dateCreated datePublished" datetime="2020-06-14T13:51:56+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-03/" itemprop="url" rel="index"><span itemprop="name">2019.03</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE9%EF%BC%9A%E5%88%A9%E7%94%A8destuctors%E9%81%BF%E5%85%8D%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2">条款9：利用destuctors避免资源泄露</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E5%9C%A8constructors%E5%86%85%E9%98%BB%E6%AD%A2%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2%EF%BC%88resource-leak%EF%BC%89">条款10：在constructors内阻止资源泄露（resource leak）</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E7%A6%81%E6%AD%A2%E5%BC%82%E5%B8%B8%EF%BC%88exceptions%EF%BC%89%E6%B5%81%E5%87%BAdestructors%E4%B9%8B%E5%A4%96">条款11：禁止异常（exceptions）流出destructors之外</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E4%BA%86%E8%A7%A3%E2%80%9D%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AAexception%E2%80%9C%E4%B8%8E%E2%80%9D%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E2%80%9C%E6%88%96%E2%80%9D%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E8%99%9A%E5%87%BD%E6%95%B0%E2%80%9C%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82">条款12：了解”抛出一个exception“与”传递一个参数“或”调用一个虚函数“之间的差异</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5by-reference%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89exceptions">条款13：以by reference方式捕捉exceptions</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E6%98%8E%E6%99%BA%E8%BF%90%E7%94%A8exception-specifications">条款14：明智运用exception specifications</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88exception-handing%EF%BC%89%E7%9A%84%E6%88%90%E6%9C%AC">条款15：了解异常处理（exception handing）的成本</a></li>
</ul>
<!-- vim-markdown-toc -->
<p>C++增加了exceptions性质后，可能令人不舒服的改变了很多事情。原始指针的使用如今称为高风险行为，资源泄露的机会大增，撰写符合期望的constructors和destructors的难度也大增。程序员特别小心，放置程序在执行时突然中止。可执行文件和程序库变得更大、速度更慢。<br>为什么使用exceptions？答案很简单：exceptions无法被忽视。如果一个函数利用<strong>设定状态变量</strong>的方式或是利用<strong>返回错误码</strong>的方式发出一个异常，无法保证此函数的调用者会检查那个变量或检验那个错误码。于是程序不断执行，远离错误发生地点。但如果函数以抛出exception的方式发出异常信号，而该exception未被捕捉，程序的执行立刻中止。<br>C只有<font color=red><code>setjmp</code></font>和<font 
color=red><code>longjmp</code></font>才能近似这样的行为。但longjmp在C++中有缺陷：当它调整栈（stack）的时候，无法调用局部（local）对象的destructors。C++很依赖destructors被调用。</p>
<h4 id="条款9：利用destuctors避免资源泄露"><a href="#条款9：利用destuctors避免资源泄露" class="headerlink" title="条款9：利用destuctors避免资源泄露"></a>条款9：利用destuctors避免资源泄露</h4><ol>
<li>有个例子，加入你现在要写一个软件。收养中心每天会产生一个文件，其中有它所安排的当天收养个案，你的工作是写程序读文件，然后为每个个案做适当处理： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ALA: abstract base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ALA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processAdoption</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Puppy</span> :</span> <span class="keyword">public</span> ALA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Kitten</span> :</span> <span class="keyword">public</span> ALA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">processAdoption</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ALA* <span class="title">readALA</span><span class="params">(istream &amp;s)</span></span>;</span><br><span class="line"><span class="comment">// 程序核心大致</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream &amp;dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果还有数据</span></span><br><span class="line">    <span class="keyword">while</span> (dataSource)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取出下一只动物</span></span><br><span class="line">        ALA *pa = <span class="built_in">readALA</span>(dataSource);</span><br><span class="line">        <span class="comment">// 处理收养事宜</span></span><br><span class="line">        pa-&gt;<span class="built_in">processAdoption</span>();</span><br><span class="line">        <span class="comment">// 删除readALA返回的对象</span></span><br><span class="line">        <span class="keyword">delete</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 如果pa-&gt;processAdoption抛出一个exception怎么办，很简单： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream &amp;dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource)</span><br><span class="line">    &#123;</span><br><span class="line">        ALA *pa = <span class="built_in">readALA</span>(dataSource);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pa-&gt;<span class="built_in">processAdoption</span>();</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123; <span class="comment">// 捕捉</span></span><br><span class="line">            <span class="keyword">delete</span> pa;  <span class="comment">// delete，避免泄露</span></span><br><span class="line">            <span class="keyword">throw</span>;      <span class="comment">// 传播给调用端</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> pa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这样程序被try语句块和catch语句块搞得乱七八糟。解决方法是以一个类似指针的对象取代指针pa，这样当这个类指针对象被（自动）销毁，可以令其destructor调用delete。这就是<font color=red>smart pointers</font>。C++标准库有，它看起来是这样子的（此书有点旧）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">auto_ptr</span>(T *p = <span class="number">0</span>) : <span class="built_in">ptr</span>(p) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 auto_ptr不适合delete数组对象的指针。如果你希望有这样的auto_ptr用在数组上，要么自己写一个，要么最好使用一些容器，比如vector来取代。用auto_ptr对象取代原始指针后，processAdoptions看起来这样子： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processAdoptions</span><span class="params">(istream &amp;dataSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (dataSource)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">auto_ptr&lt;ALA&gt; <span class="title">pa</span><span class="params">(readALA(dataSource))</span></span>;</span><br><span class="line">        pa-&gt;<span class="built_in">processAdoption</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 它和原版本的差异只有两处。一是pa被声明为一个auto_ptr&lt;ALA&gt;对象；二是循环最后不再有delete语句。它是隐藏在auto_ptr背后的观念——以一个对象存放必须自动释放的资源，并依赖该对象的destructor释放。</li>
</ol>
<h4 id="条款10：在constructors内阻止资源泄露（resource-leak）"><a href="#条款10：在constructors内阻止资源泄露（resource-leak）" class="headerlink" title="条款10：在constructors内阻止资源泄露（resource leak）"></a>条款10：在constructors内阻止资源泄露（resource leak）</h4><ol>
<li>对于尚未完全构造好的对象，C++拒绝调用其destructor。由于C++不自动清理构造期间抛出exceptions的对象，所以设法让constructor在那种情况下也能自我清理。这通常将可能的exceptions捕捉起来，执行清理工作，然后重新抛出exception。让它继续传播： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Image</span>(<span class="keyword">const</span> string &amp;imageDataFileName);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioClip</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AudioClip</span>(<span class="keyword">const</span> string &amp;audioDataFileName);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~<span class="built_in">BookEntry</span>();</span><br><span class="line">    <span class="built_in">BookEntry</span>(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addPhoneNumber</span><span class="params">(<span class="keyword">const</span> PhoneNumber &amp;number)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span></span>;</span><br><span class="line">    string theName;</span><br><span class="line">    string theAddress;</span><br><span class="line">    list&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    Iimage * <span class="keyword">const</span> theImage;</span><br><span class="line">    AudioClip * <span class="keyword">const</span> theAudioClip;</span><br><span class="line">    <span class="function">Image* <span class="title">initImage</span><span class="params">(<span class="keyword">const</span> string &amp;imageFileName)</span></span>;</span><br><span class="line">    <span class="function">AudioClip* <span class="title">initAudioClip</span><span class="params">(<span class="keyword">const</span> string &amp;audioClipFileName)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BookEntry::cleanup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> theImage;</span><br><span class="line">    <span class="keyword">delete</span> the AudioClip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BookEntry::BookEntry(const string &amp;name,</span></span><br><span class="line"><span class="comment">                    const string &amp;address,</span></span><br><span class="line"><span class="comment">                    const string &amp;imageFileName,</span></span><br><span class="line"><span class="comment">                    const string &amp;audioClipFileName) </span></span><br><span class="line"><span class="comment">: theName(name, theAddress(address),</span></span><br><span class="line"><span class="comment">    theImage(0), theAudioClip(0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    try &#123;</span></span><br><span class="line"><span class="comment">        if (imageFileName != &quot;&quot;) </span></span><br><span class="line"><span class="comment">            theImage = new Image(imageFileName);</span></span><br><span class="line"><span class="comment">        if (audioClipFileName != &quot;&quot;)</span></span><br><span class="line"><span class="comment">            theAudioClip = new AudioClip(audioClipFileName);</span></span><br><span class="line"><span class="comment">    &#125; catch (...) &#123;</span></span><br><span class="line"><span class="comment">        cleanup();</span></span><br><span class="line"><span class="comment">        throw;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要在exceptions传播到constructor外之前，无法将try和catch放到member initialization list中，就放到某些private member functions中。</span></span><br><span class="line">BookEntry::<span class="built_in">BookEntry</span>(<span class="keyword">const</span> string &amp;name,</span><br><span class="line">                    <span class="keyword">const</span> string &amp;address,</span><br><span class="line">                    <span class="keyword">const</span> string &amp;imageFileName,</span><br><span class="line">                    <span class="keyword">const</span> string &amp;audioClipFileName) </span><br><span class="line">: <span class="built_in">theName</span>(name, <span class="built_in">theAddress</span>(address),</span><br><span class="line">    <span class="built_in">theImage</span>(<span class="built_in">initImage</span>(imageFileName)), <span class="built_in">theAudioClip</span>(<span class="built_in">initAudioClip</span>(audioClipFileName))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">Image* BookEntry::<span class="built_in">initImage</span>(<span class="keyword">const</span> string &amp;imageFileName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (imageFileName != <span class="string">&quot;&quot;</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Image</span>(imageFileName);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioClip* BookEntry::<span class="built_in">initAudioClip</span>(<span class="keyword">const</span> string &amp;audioClipFileName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (audioClipFileName != <span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioClip</span>(audioClipFIleName);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> theImage;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BookEntry::~<span class="built_in">BookEntry</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cleanup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 更好的做法是如条款9一样，使用smart pointer来取代pointer class members，免除了exception出现时发生资源泄露。</li>
</ol>
<h4 id="条款11：禁止异常（exceptions）流出destructors之外"><a href="#条款11：禁止异常（exceptions）流出destructors之外" class="headerlink" title="条款11：禁止异常（exceptions）流出destructors之外"></a>条款11：禁止异常（exceptions）流出destructors之外</h4><ol>
<li>两种情况下destructor会被调用。第一种情况是<strong>当对象在正常状态下被销毁，也就是离开生存空间（scope）或是被明确删除时</strong>；第二种情况是<strong>当对象被exception处理机制——也就是exception传播过程中的stack-unwinding（栈展开）机制——销毁</strong>。</li>
<li>当destructor被调用，可能有一个exception正在作用中，可惜的是无法在destructor区分这些状态（有了）。这样就要保守撰写destructors了。如果控制权基于exception的因素离开destructor，而此时另一个exception处于作用状态，C++会调用terminate函数，将程序结束掉。</li>
<li>有两个理由支持阻止exceptions传出destructor之外。第一，<strong>它可以避免terminate函数在exception传播过程的<font color=red>栈展开</font>（<font color=green>stack-unwinding</font>）机制被调用</strong>；第二，<strong>它可以协助确保destructors完成其应该完成的所有事情</strong>。</li>
</ol>
<h4 id="条款12：了解”抛出一个exception“与”传递一个参数“或”调用一个虚函数“之间的差异"><a href="#条款12：了解”抛出一个exception“与”传递一个参数“或”调用一个虚函数“之间的差异" class="headerlink" title="条款12：了解”抛出一个exception“与”传递一个参数“或”调用一个虚函数“之间的差异"></a>条款12：了解”抛出一个exception“与”传递一个参数“或”调用一个虚函数“之间的差异</h4><ol>
<li>从抛出端传递一个exception到catch字句，看起来和从函数调用端传递一个自变量到函数参数是一样的。但是有重大的不同。函数参数和exception的传递参数有3中：by value，by reference，by pointer。然而，当你调用一个函数，控制权最终会回到调用端（除非函数失败），但是当你抛出一个exception，控制权不再回到抛出端。而且被捕捉的exception是某个对象的副本，即使以by reference方式传参。</li>
<li>当对象被赋值当作一个exception，复制行为是由对象的copy constructor执行的。这个copy constructor相当于该对象的”静态类型“而非”动态类型”。例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWidget</span> :</span> <span class="keyword">public</span> Widget &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">passAndThrowWidget</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SpecialWidget localSpecialWidget;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// rw表示一个SpecialWidget</span></span><br><span class="line">    Widget&amp; rw = localSpecialWidget;</span><br><span class="line">    <span class="comment">// 抛出一个类型为Widget的exception</span></span><br><span class="line">    <span class="keyword">throw</span> rw;   <span class="comment">// （条款25有返回动态类型的技术）</span></span><br><span class="line">    <span class="comment">// 抛出一个类型为SpecialWidget的exception；这是因为它并没有发生复制行为，只是再抛出。</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (Widget w) ...    <span class="comment">// by value</span></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (Widget &amp;w) ...   <span class="comment">// by reference</span></span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> Widget &amp;w) ... <span class="comment">// by reference-to-const</span></span><br></pre></td></tr></table></figure>
 以上“参数传递”和“exception传播“之间的另一个区别。exception的复制动作，其结果是个临时对象。一个被抛出的对象可以简单的用by reference的方式捕捉，不需要以<font color=red>by reference-to-const</font>的方式捕捉。调用过程将一个临时对象传递给<font color=red>non-const reference</font>参数是不允许的，但对exceptions则是合法。<br> 值得一提，by value方式传递exception，得符出”被抛出物“<strong>两个副本</strong>的构造代价，其中一个构造动作用于产生exception临时对象，另一个构造动作作用于将临时对象赋值到w；而by reference得付出<strong>单一副本</strong>的构造代价，这个副本就是临时副本，by reference方式传递函数参数不会发生复制行为。<br> 还有，exceptions与catch子句匹配过程中，不会发生隐式转换的行为。它仅有两种转换可以发生。第一种是<font color=red>继承架构中的类转换</font>（<font color=green>inheritance-based conversions</font>）。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">logic_error--&gt;exception</span><br><span class="line">runtime_error--&gt;exception</span><br><span class="line">domain_error--&gt;logic_error</span><br><span class="line">invalid_argument--&gt;logic_error</span><br><span class="line">length_error--&gt;logic_error</span><br><span class="line">out_of_range--&gt;logic_error</span><br><span class="line">range_error--&gt;runtime_error</span><br><span class="line">underflow_error--&gt;runtime_error</span><br><span class="line">overflow_error--&gt;runtime_error</span><br></pre></td></tr></table></figure>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (runtime_error) ...</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (runtime_error&amp;) ...</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> runtime_error&amp;) ...</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (runtime_error*) ...</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> runtime_error*) ...</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">void</span>*) ...</span><br></pre></td></tr></table></figure>
 ”传递参数“和”传播exception“的最后不同是，catch子句总是依出现顺序做匹配尝试。将此行为和调用虚函数的行为比对。当调用虚函数时，被调用的函数是“调用者的动态类型”中的函数。在这方面，虚函数采用<font color=red><strong>”best fit“（最佳吻合）策略</strong></font>，<font color=red><strong>exception遵循”first fit”（最先吻合）策略</strong></font>。所以针对derived class而设计的catch子句必须放到针对base class设计的catch子句之前。</li>
</ol>
<h4 id="条款13：以by-reference方式捕捉exceptions"><a href="#条款13：以by-reference方式捕捉exceptions" class="headerlink" title="条款13：以by reference方式捕捉exceptions"></a>条款13：以by reference方式捕捉exceptions</h4><ol>
<li><font color=red>throw by pointer</font>应该是最有效率的一种做法,因为它不复制对象。但它并没有想象中的好，因为了让exception objects在控制权离开抛出指针的函数之后依然存在，就需要声明global或static对象，而程序很容易忘记。而且如果抛出的指针指向一个新的heap-based，负责catch的人不能区分是global即static还是heap中的exception object，于是可能产生内存泄露或者未定义的行为等潜在问题。<br> 此外，catch-by-pointer和语言本身建立起来的惯例有矛盾。4个标准的exception——<strong>bad-alloc、bad_cast、bad_typeid和bad_exception</strong>——统统都是对象，不是对象指针。说明只能使用by value或by reference。然而<font color=red>catch-by-value</font>每当exception objects被抛出，就得复制两次。而且他会引起<font color=red>切割</font>（<font color=green>slicing</font>）问题，因为derived class exception objects被捕捉并被视为base class exceptions：被切割过的对象其实就是缺少derived class data members。<br> 所以接下来就是<font color=red>catch-by-reference</font>了。它不像catch-by-pointer发生对象删除问题，也不存在catch-by-value的切割问题，而且exception objects只会被复制一次。</li>
</ol>
<h4 id="条款14：明智运用exception-specifications"><a href="#条款14：明智运用exception-specifications" class="headerlink" title="条款14：明智运用exception specifications"></a>条款14：明智运用exception specifications</h4><ol>
<li><font color=red>exception specifications</font>让代码更容易被理解，因为它明确指出一个函数可以抛出什么样的exceptions。但它不只是一个注释而已。编译器有时候能够在编译期间侦测到与exception specifications不一致的行为。如果函数抛出了一个并未列入于其exception speicification的exception，这个错误会在运行期被检验出来。于是特殊函数<font color=red>unexpected</font>会被自动调用。unexpected的默认行为是调用terminate，而terminate的默认行为是调用abort，所以程序如果违反exception speicification，默认结果就是程序被中止。</li>
<li>编译器只会对exception specifications做局部经检验，调用某个函数而该函数可能违反调用端函数本身的exception specification。这么做可能会导致程序被迫终止，为将这种不一致性降到最低，一个方法是<strong>避免将exception specification放在需要类型自变量的templates身上</strong>。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不良的temmplates design，它带有exception specification</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> T &amp;lhs, <span class="keyword">const</span> T &amp;rhs) <span class="built_in"><span class="keyword">throw</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;lhs == &amp;rhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 它指明template产生出来的函数不会抛出任何exception，然而它调用的operator &amp;可能会抛出一个异常。更一般化的问题是，没有任何方法可以知道一个template的类型参数可能抛出什么。<br> 避免踏上unexpected之路的第二个方法是：<strong>如果A函数调用的B函数没有exception specifications，那么A函数本身也不要设定exception specifications</strong>。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准委员会宣称typedef内不可出现exception specification， 可能需要该写宏</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CallBackPtr)</span><span class="params">(<span class="keyword">int</span> eventXLocation, <span class="keyword">int</span> eventYLocation, <span class="keyword">void</span> *dataToPassBack)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallBack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CallBack</span>(CallBackPtr fPtr, <span class="keyword">void</span> *dataToPassBack) : <span class="built_in">func</span>(fPtr), <span class="built_in">data</span>(dataToPassBack) &#123;&#125; </span><br><span class="line">    <span class="function">vvoid <span class="title">makeCallBack</span><span class="params">(<span class="keyword">int</span> eventXLocation, <span class="keyword">int</span> eentYLocaltion)</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;s</span><br><span class="line"><span class="keyword">private</span></span><br><span class="line">    CallBackPtr *func;</span><br><span class="line">    <span class="keyword">void</span> *fdata;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CallBack::makeCallBack</span><span class="params">(<span class="keyword">int</span> eventXLocation, <span class="keyword">int</span> eventYLocatino)</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fnuc</span>(eventXLocation, eventYLocation, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 第三个技术是：<strong>处理“系统”可能抛出的exceptions</strong>。直接处理非预期的exceptions比事先预防来的简单。但如果你写的软件大量运用exception specifications，但调用程序库提供的函数没有使用exception specifications，想要阻止之变得不切实际。这时候可以利用一个事实：以不同类型的exceptions取代非预期的exceptions。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有非预期的exception objects都被取代为此类的objects</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnexpectedException</span> &#123;</span>&#125;;</span><br><span class="line"><span class="comment">// 如果有非预期的exception被抛出，调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convertUnexpected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">UnexpectedException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以convertUnexpected取代默认的unexpected</span></span><br><span class="line">std::<span class="built_in">set_unexpected</span>(convertUnexpected);</span><br></pre></td></tr></table></figure>
 一旦完成这些部署，非预期的exception会导致该函数被调用。那么只要违反的exception specification内含有Unexpected Exception，exception的传播就会继续下去，而如果未含有，terminate会被调用，犹如未取代unexpected一样。<br> 将非预期的exceptions转换为一个已知类型的另一个做法是，依赖以下事实：如果非预期函数的替代者重新抛出当前（current）exception，该xception会被保准类型bad_exception取代而之。</li>
</ol>
<h4 id="条款15：了解异常处理（exception-handing）的成本"><a href="#条款15：了解异常处理（exception-handing）的成本" class="headerlink" title="条款15：了解异常处理（exception handing）的成本"></a>条款15：了解异常处理（exception handing）的成本</h4><ol>
<li>为了能够在运行期处理exceptions，程序必须做大量簿记工作。在每个执行点，它们必须能够确认“如果发生exception，哪些对象需要析构”，它们必须在每个try语句块的进入点和离开点做记号，针对每个try语句块它们必须记录对应的catch子句及能够处理的exceptions类型。这些簿记工作必须符出代价，运行时期的比对工作（以确保符合exception specifications）不是免费的。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/2-%E6%93%8D%E4%BD%9C%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/2-%E6%93%8D%E4%BD%9C%E7%AC%A6/" class="post-title-link" itemprop="url">2 操作符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:51:50" itemprop="dateCreated datePublished" datetime="2020-06-14T13:51:50+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-03/" itemprop="url" rel="index"><span itemprop="name">2019.03</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE5%EF%BC%9A%E5%AF%B9%E5%AE%9A%E5%88%B6%E7%9A%84%E2%80%9C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E2%80%9D%E4%BF%9D%E6%8C%81%E8%AD%A6%E8%A7%89">条款5：对定制的“类型转换函数”保持警觉</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE6%EF%BC%9A%E5%8C%BA%E5%88%ABincrement/decrement%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%89%8D%E7%BD%AE%EF%BC%88prefix%EF%BC%89%E5%92%8C%E5%90%8E%E7%BD%AE%EF%BC%88postfix%EF%BC%89%E5%BD%A2%E5%BC%8F">条款6：区别increment/decrement操作符的前置（prefix）和后置（postfix）形式</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE7%EF%BC%9A%E5%8D%83%E4%B8%87%E4%B8%8D%E8%A6%81%E9%87%8D%E8%BD%BD&&%EF%BC%8C%7C%7C%E5%92%8C%EF%BC%8C%E6%93%8D%E4%BD%9C%E7%AC%A6">条款7：千万不要重载&amp;&amp;，||和，操作符</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE8%EF%BC%9A%E4%BA%86%E8%A7%A3%E5%90%84%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%84%8F%E4%B9%89%E7%9A%84new%E5%92%8Cdelete">条款8：了解各种不同意义的new和delete</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款5：对定制的“类型转换函数”保持警觉"><a href="#条款5：对定制的“类型转换函数”保持警觉" class="headerlink" title="条款5：对定制的“类型转换函数”保持警觉"></a>条款5：对定制的“类型转换函数”保持警觉</h4><ol>
<li>C++允许编译器在不同类型之间执行<font color=red>隐式转换</font>（<font color=green>implicit conversions</font>）。它继承C的传统，允许将char转换为int，将short转换为double。然而还有令人害怕的转型，包括将int转换为short，将double转换为char，这些类型转换会遗失信息。所以我们可以使用自己的类型。两种函数允许编译器执行这样的转换：<strong>单自变量constructors</strong>和<strong>隐式类型转换操作符</strong>。所谓的单自变量constructor是指能够以单一自变量成功调用的constructors： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// string to Name</span></span><br><span class="line">    <span class="built_in">Name</span>(<span class="keyword">const</span> std::string &amp;s);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Rational to double</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 ，而隐式类型转换操作符，是一个拥有奇怪名称的member function：关键词operator后面加上一个类型名称，你不能为此函数指定返回值类型，因为其返回值类型已经表现在函数名称上了： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;   <span class="comment">// r == 1/2</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0.5</span> * r; <span class="comment">// 将r转为double，然后执行乘法运算</span></span><br></pre></td></tr></table></figure></li>
<li>假设有一个class用来表现分数（rational numbers）。你希望像内建类型一样地输出Rational objects内容。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; r;</span><br></pre></td></tr></table></figure>
 假设忘了给Rational写一个operator&lt;&lt;，上述打印不但不会出错，编译器在面对上述动作，它会想尽各种办法（包括找出一系列可接受的隐式类型转换）让函数调用动作成功。而之间的代码发现，只要调用了Rational::oeprator double，将r转换为double，调用动作就能成功，却又有隐式类型转换操作符的缺点：它的出现可能到导致错误（非预期）的函数被调用。于是有了解决办法： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">asDouble</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; r;             <span class="comment">// error</span></span><br><span class="line">std::cout &lt;&lt; r.<span class="built_in">asDouble</span>();  <span class="comment">// ok, 以double形式输出r</span></span><br></pre></td></tr></table></figure>
 必须明白调用类型转换函数虽然有点不便，却可以避免默默调用了不想调用的函数。这也就是为什么标准程序库的string类型并未含有从string object到C-style char*的隐式转换函数，而是提供了一个显式的member function <code>c_str</code>。<br> 在单自变量constructors，这些函数造成的隐式类型转换的情况更难对付： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> lowBound, <span class="keyword">int</span> highBound);</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> size);</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Array&lt;<span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> Array&lt;<span class="keyword">int</span>&gt; &amp;rhs);</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a == b[i])      <span class="comment">// 如果打算写a[i] == b[i]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> something <span class="keyword">for</span> when a[i] <span class="keyword">and</span> b[i] are equal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">do</span> something <span class="keyword">for</span> when they<span class="number">&#x27;</span>re <span class="keyword">not</span>;</span><br></pre></td></tr></table></figure>
 这样的错误编译器并没有提醒，它一声不吭，编译器注意到它，发现只要调用Array&lt;int&gt; constructor（需要一个int自变量）就可以将int转为Array&lt;int&gt; object。于是它放手去做。<br> 有两种办法阻止编译器这么做：一个是简易法，另一个可在编译器不支持简易法的情况下使用。<br> 简易法是使用C++特征：关键词<font color=red><code>explicit</code></font>。只要将constructors声明为explicit，编译器就能因隐式转换而调用它，不过显式类型转换是允许的（没发现）。有个解决方案： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArraySize</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ArraySize</span>(<span class="keyword">int</span> numElements) :  <span class="built_in">theSize</span>(numElements) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> theSize; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> theSize;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> lowBound, <span class="keyword">int</span> highBound);</span><br><span class="line">    <span class="built_in">Array</span>(ArraySize size);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Array&lt;<span class="keyword">int</span>&gt; &amp;lhs, <span class="keyword">const</span> Array&lt;<span class="keyword">int</span>&gt; &amp;rhs);</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Array&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (a == b[i])  <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
 编译器需要一个Array&lt;int&gt;的对象在==右边，但此时没有这样隐式转换的constructor。更不能将int转换一个<strong>临时性</strong>的ArraySize对象，再根据这个临时对象产生必要的Array&lt;int&gt;对象，所以报错。类似ArraySize这样的classes，往往被称为proxy classes，因为它的每一个对象都是为了其他对象而存在的，好像其他对象的<font cololr=red>代理人</font>（<font color=green>proxy</font>）一样。这是一个很值得学习的技术。</li>
</ol>
<h4 id="条款6：区别increment-decrement操作符的前置（prefix）和后置（postfix）形式"><a href="#条款6：区别increment-decrement操作符的前置（prefix）和后置（postfix）形式" class="headerlink" title="条款6：区别increment/decrement操作符的前置（prefix）和后置（postfix）形式"></a>条款6：区别increment/decrement操作符的前置（prefix）和后置（postfix）形式</h4><ol>
<li>重载函数是以其参数类型来区分彼此的，然而不论increment或decrement操作符的前置式或后置式，都没有参数，为了填平这个语言学上的漏洞，只好让后置式有一个int自变量，并且让它被调用时，编译器默默地为该int指定一个<font color=red><strong>0值</strong></font>： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UPInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>++();            <span class="comment">// 前置式++</span></span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>++(<span class="keyword">int</span>);    <span class="comment">// 后置式++</span></span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>--();            <span class="comment">// 前置式--</span></span><br><span class="line">    <span class="keyword">const</span> UPInt <span class="keyword">operator</span>--(<span class="keyword">int</span>);    <span class="comment">// 后置式--</span></span><br><span class="line">    UPInt&amp; <span class="keyword">operator</span>+=(<span class="keyword">int</span>);         <span class="comment">// +=操作符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">UPInt i;</span><br><span class="line">++i;    <span class="comment">// i.operator++();</span></span><br><span class="line">i++;    <span class="comment">// i.operator++(0);</span></span><br><span class="line">--i;    <span class="comment">// i.operator--();</span></span><br><span class="line">i--;    <span class="comment">// i.operator--(0);</span></span><br></pre></td></tr></table></figure></li>
<li>所谓的increment操作符的前置式意义“increment and fetch“（积累然后取出），后置式意义”fetch and increment“（取出然后累加）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UPInt&amp; UPInt::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> UPInt UPInt::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    UPInt oldValue = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 为什么后置increment操作符返回的对象是const呢？以下： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPInt i;</span><br><span class="line">i++++;  <span class="comment">//  后置increment操作符两次</span></span><br><span class="line">i.<span class="built_in"><span class="keyword">operator</span></span>(<span class="number">0</span>).<span class="keyword">operator</span>++(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款7：千万不要重载-amp-amp-，-和，操作符"><a href="#条款7：千万不要重载-amp-amp-，-和，操作符" class="headerlink" title="条款7：千万不要重载&amp;&amp;，||和，操作符"></a>条款7：千万不要重载&amp;&amp;，||和，操作符</h4><ol>
<li>操作符重载也不是任何都能用来重，它也是有底线的，你不能重载以下操作符： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.       .*      ::      ?:      <span class="keyword">new</span> </span><br><span class="line"><span class="keyword">delete</span>  <span class="keyword">sizeof</span>  <span class="keyword">typeid</span>  <span class="keyword">static_cast</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>    <span class="keyword">const_cast</span>  <span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure>
 可以重载的有： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>        <span class="keyword">operator</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">new</span>[]      <span class="keyword">operator</span> <span class="keyword">delete</span>[]</span><br><span class="line">+   -   *   /   %   ^   &amp;   |   ~   </span><br><span class="line">!   =   &lt;   &gt;   +=  -=  *=  /=  %=</span><br><span class="line">^=  &amp;=  |=  &lt;&lt;  &gt;&gt;  &gt;&gt;= &lt;&lt;= ==  !=</span><br><span class="line">&lt;=  &gt;=  &amp;&amp;  ||  ++  --  ,   -&gt;* -&gt;</span><br><span class="line">()  []</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款8：了解各种不同意义的new和delete"><a href="#条款8：了解各种不同意义的new和delete" class="headerlink" title="条款8：了解各种不同意义的new和delete"></a>条款8：了解各种不同意义的new和delete</h4><ol>
<li><p>new operator和operator new之间是有差别的。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Memory Management&quot;</span>);</span><br></pre></td></tr></table></figure>
<p> 所使用的new是所谓的<font color=red>new operator</font>。这个操作符是语言内建的，跟sizeof一样不能改变意义。它的分为两方面：<strong>分配足够的内存用来存放某类型的对象</strong>；<strong>而后调用一个constructor为刚才分配的内存中的那个对象设定初值</strong>。<br> 我们能够重写改函数，改变其行为。这个函数名称叫<font color=red>operator new</font>。它的函数原型是：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p> size_t参数表示需要分配多少内存。然后返回一块原始的内存。和malloc一样，operator new唯一任务是分配内存。但它<strong>不知道</strong>什么是constructors。当你想要调用一个constructor，有个特殊版本的operator new，称为<font color=red>placement new</font>，允许你这么做：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>(<span class="keyword">int</span> widgetSize);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Widget* <span class="title">constructorWidgetInBuffer</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">new</span></span>(buffer) <span class="built_in">Widget</span>(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这是new operator的用法之一，指定一个额外自变量（buffer）作为new operator隐式调用operator new时所用。于是，被调用的operator new除了几首size_t变量外，还接受了一个void*参数，这就是所谓的placement new，看起来像这样：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果你希望将对象产生于heap，请使用new operator，它不但分配内存而且为对象调用一个constructor。如果只是打算分配内存，调用operator new，那没有任何constructor被调用。如果打算在heap objects产生时决定内存分配方式，写一个自己的operator new。</p>
</li>
<li><p>为了避免<font color=red>resource leaks</font>（<strong>资源泄露</strong>），每一个动态分配行为都必须匹配一个相应但相反的释放动作。内存释放动作是由operator delete执行：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string *ps;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *memoryToBeDeallocated)</span></span>;</span><br></pre></td></tr></table></figure>
<p> 因此，<code>delete</code>动作会产生类似代码：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;~<span class="built_in">string</span>();</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>;</span><br></pre></td></tr></table></figure>
<p> 这里呈现的暗示是，如果只打算处理原始的、未设初值的内存，应该回避new operator和delete operators。如果使用了placement new产生对象，避免对该内存使用delete operator。因为delete operator会调用operator delete来释放内存，但该内存并非由operator new分配得来的。placement new只是返回它接受的指针而已，所以未了抵消该对象的constructor的影响，应该直接调用该对象的destructor。</p>
</li>
<li><p>面对数组情况，也有所不同：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p> 上述的new仍然是new operator，但由于诞生的是数组，所以new operator的行为不再以operator new分配，而是由一个名为operator new[]负责分配（通常称为array new）。同样道理，当delete operator被用于数组，它会针对数组中的每个元素调用其destructor，然后调用operator delete[]释放内存。<br> 总结以下，new operator和delete operator都是内建操作符，无法为你所控制，但是它们所调用的内存分配/释放函数则不然。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/1-%E5%9F%BA%E7%A1%80%E8%AE%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/1-%E5%9F%BA%E7%A1%80%E8%AE%AE%E9%A2%98/" class="post-title-link" itemprop="url">1 基础议题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:51:44" itemprop="dateCreated datePublished" datetime="2020-06-14T13:51:44+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-03/" itemprop="url" rel="index"><span itemprop="name">2019.03</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE1%EF%BC%9A%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB">条款1：指针与引用的区别</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE2%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BD%BF%E7%94%A8c++%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">条款2：尽量使用C++风格的类型转换</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE3%EF%BC%9A%E7%BB%9D%E5%AF%B9%E4%B8%8D%E8%A6%81%E4%BB%A5%E5%A4%9A%E6%80%81%EF%BC%88polymorphically%EF%BC%89%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84">条款3：绝对不要以多态（polymorphically）方式处理数组</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE4%EF%BC%9A%E9%9D%9E%E5%BF%85%E8%A6%81%E4%B8%8D%E6%8F%90%E4%BE%9Bdefault-constructor">条款4：非必要不提供default constructor</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款1：指针与引用的区别"><a href="#条款1：指针与引用的区别" class="headerlink" title="条款1：指针与引用的区别"></a>条款1：指针与引用的区别</h4><ol>
<li>当你知道你必须指向一个对象并且不想改变其指向时，或者在重载符并为防止不必要的语义误解时，你不应该使用指针。除此之外的情况下，则使用指针。</li>
</ol>
<h4 id="条款2：尽量使用C-风格的类型转换"><a href="#条款2：尽量使用C-风格的类型转换" class="headerlink" title="条款2：尽量使用C++风格的类型转换"></a>条款2：尽量使用C++风格的类型转换</h4><ol>
<li>将一个pointer-to-const-object转型为一个pointer-to-non-const-object（改变对象常量性，和将一个pointer-to-base-class-object转型为一个pointer-to-derived-class-object（改变对象类型）有很大差异。而传统C转型动作并无区分，不过旧式的C转型动作并非唯一选择，C式转型式为C设计的，不是为了C++。C++导入4个新的<font color=red>转型操作符</font>（<font color=green>cast operators</font>）：<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>和<code>reinterpret_cast</code>。</li>
<li><font color=red>static_cast</font>具有与C旧式转型相同的威力与意义，以及相同的限制。static_cast不能移除表达式的常量性（constness），因为有const_cast。</li>
<li>其他新式C++转型操作符适用于更集种（范围更狭窄）的目的。<font color=red>const_cast</font>用来改变表达式中的常量性（constness）或变易性（volatileness）。常见的用途在于将某个对象的常量性去掉。</li>
<li><font color=red>dynamic_cast</font>用来执行继承体系中“<strong>安全的向下转型或跨转型动作</strong>”。它不能应用在缺乏虚函数的类型身上。</li>
<li><font color=red>reinterpret_cast</font>这个于编译平台有关，基本不具移植性。它的常用用途是转换“函数指针”类型： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FuncPtr)</span><span class="params">()</span></span>;</span><br><span class="line">FuncPtr funcPtrArray[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">funcPtrArray[<span class="number">0</span>] = &amp;doSomething; <span class="comment">// error</span></span><br><span class="line">funcPtrArray[<span class="number">0</span>] = <span class="keyword">reinterpret_cast</span>&lt;FuncPtr&gt;(&amp;doSomething);  <span class="comment">//ok</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款3：绝对不要以多态（polymorphically）方式处理数组"><a href="#条款3：绝对不要以多态（polymorphically）方式处理数组" class="headerlink" title="条款3：绝对不要以多态（polymorphically）方式处理数组"></a>条款3：绝对不要以多态（polymorphically）方式处理数组</h4><ol>
<li><font color=red>继承</font>（<font color=green>inheritance</font>）的最重要性质之一是可以通过指向base class objects的pinters或references来操作derived class objects。我们说它行为是<font color=red>多态的</font>（<font color=green>polymorphically</font>）。它也允许以上形成的数组。但这不值得沾沾自喜，因为它几乎不会如预期般运作。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BalancedBST</span> :</span> <span class="keyword">public</span> BST &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBSTArray</span><span class="params">(std::ostream &amp;s, <span class="keyword">const</span> BST array[], <span class="keyword">int</span> numElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numElements; ++i)</span><br><span class="line">        s &lt;&lt; array[i];      <span class="comment">// 假设BST objects有个operator&lt;&lt;可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BST BSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(std::cout, BSTArray, <span class="number">10</span>); <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 编译器可能会被误导，它假设数组元素大小是BST的大小，通常derived classes比base classes大。</span></span><br><span class="line"><span class="comment">// 那么会发生不可预期的事情？？</span></span><br><span class="line">BalancedBST bBSTArray[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printBSTArray</span>(std::cout, bBSTArray, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteArray</span><span class="params">(std::ostream &amp;logStream, BST array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    logStream &lt;&lt; <span class="string">&quot;Deleting array at address &quot;</span></span><br><span class="line">              &lt;&lt; stati_cast&lt;<span class="keyword">void</span>*&gt;(array) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">delete</span> []array;</span><br><span class="line">&#125;</span><br><span class="line">BalancedBST &amp;balTreeArray = <span class="keyword">new</span> BalancedBST[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">deleteArray</span>(std::cout, balTreeArray);</span><br><span class="line"><span class="comment">// delete []array会产生这样的代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for (int i = the number of elements in the array -1; i &gt;= 0; --i)</span></span><br><span class="line"><span class="comment">    array[i].BST::~BST();   // 调用array[i]的destructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
 在C++语言规范中说，<strong>通过base class指针删除一个由derived classes objects构成的数组，其结果未定义</strong>。</li>
</ol>
<h4 id="条款4：非必要不提供default-constructor"><a href="#条款4：非必要不提供default-constructor" class="headerlink" title="条款4：非必要不提供default constructor"></a>条款4：非必要不提供default constructor</h4><ol>
<li><p>所谓default constructor是C++一种无中生有的方式。constructors用来将对象初始化，所以default constructors的意思是在没有任何外来信息的情况将对象初始化。然而有些对象如果没有外来信息，是无法初始化的，可能产生的对象没有意义。</p>
</li>
<li><p>如果class缺乏一个default constructor，使用class时会有限制，第一个问题在产生<font color=red>数组</font>的时候。例如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EquipmentPiece</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EquipmentPiece</span>(<span class="keyword">int</span> IDNumber);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">EquipmentPiece bestPieces[<span class="number">10</span>];  <span class="comment">// error</span></span><br><span class="line">EquipmentPiece *bestPieces = <span class="keyword">new</span> EquipmentPiece[<span class="number">10</span>]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p> 在产生数组的时候，一般而言没有任何方法可以为数组中的对象指定constructor自变量。有三个方法可以解决这个束缚：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个方式是使用non-heap数组</span></span><br><span class="line"><span class="comment">// 不幸的是此法无法延伸至heap数组</span></span><br><span class="line"><span class="keyword">int</span> ID1, ID2, ID3, ..., ID10;  </span><br><span class="line">...</span><br><span class="line">EquipmentPiece bestPieces[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">EquipmentPiece</span>(ID1)，</span><br><span class="line">    <span class="built_in">EquipmentPiece</span>(ID2)，</span><br><span class="line">    <span class="built_in">EquipmentPiece</span>(ID3)，</span><br><span class="line">    ...,</span><br><span class="line">    <span class="built_in">EquipmentPiece</span>(ID10)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更一般化的做法是使用“指针数组”而非“对象数组</span></span><br><span class="line"><span class="comment">// 此法有两个缺点。</span></span><br><span class="line"><span class="comment">// 第一，必须记得此数组所指的所有对象删除，否则会出现resource leak（资源泄露）</span></span><br><span class="line"><span class="comment">// 第二，需要足够大的内存总量，需要一些空间来放置指针和一些空间来放置EqupmentPiece objects</span></span><br><span class="line"><span class="keyword">typedef</span> EquipmentPiece *PEP;</span><br><span class="line">PEP bestPieces[<span class="number">10</span>]; <span class="comment">// ok，不需要调用ctor</span></span><br><span class="line">PEP *bestPieces = <span class="keyword">new</span> PEP[<span class="number">10</span>];  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    bestPieces[i] = <span class="keyword">new</span> <span class="built_in">EquipmentPiece</span>(ID number);</span><br></pre></td></tr></table></figure>
<p> 过度使用内存这个问题可以避免：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配足够的raw memory</span></span><br><span class="line"><span class="keyword">void</span> *rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="number">10</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(EquipmentPiece));</span><br><span class="line"><span class="comment">// 让bestPieces指向此块内存，将这块内存视为一个EquipmentPiece数组</span></span><br><span class="line">EquipmentPiece *bestPiece = <span class="keyword">static_cast</span>&lt;EquipmentPiece*&gt;(rawwMemory);</span><br><span class="line"><span class="comment">// 利用“placement new”构造这块内存中的objects</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    <span class="keyword">new</span>(&amp;bestPieces[i]) <span class="built_in">EquipmentPiece</span>(ID number);</span><br></pre></td></tr></table></figure>
<p> placement new的缺点是，维护起来比较困难。此外，在数组内的对象结束生命时，以手动方式调用其destructors，最后还得调用operator delete[]的方式释放raw memory：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相反顺序析构掉</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    bestPieces[i].~<span class="built_in">EquipmentPiece</span>();</span><br><span class="line"><span class="comment">// free raw memroy</span></span><br><span class="line"><span class="keyword">operator</span> <span class="keyword">delete</span>[](rwaMemory);</span><br></pre></td></tr></table></figure>
</li>
<li><p>classes缺乏default constructors带来的第二个缺点是：它们不适用于许多<font color=red>template-based container classes</font>。对template而言，<font color=red>被实例化</font>（<font color=green>instantiated</font>）的目标类型必须有一个deault constructors。这是一个普遍的共同需求，那些templates内几乎总是会产生一个以“template类型参数”作为类型而架构起来的数组，例如：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>(<span class="keyword">int</span> size);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(<span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数组中的每个元素都调用T::T()</span></span><br><span class="line">    data = <span class="keyword">new</span> T[size];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果谨慎设计，可以消除对default constructor的需求。标准库中vector template（产生可扩展数组的各种classes）就不要求default constructor。</p>
</li>
<li><p>最后一个考虑点是<font colro=red>virtual base classes</font>。因为virtual base class constructors的自变量由最深层次的派生类的class提供。于是，一个缺乏default constructor的virtual base class，要求所有derived classes都必须知道、了解其意义，并且提供自变量。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/9-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/" class="post-title-link" itemprop="url">9 杂项讨论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:47:06" itemprop="dateCreated datePublished" datetime="2020-06-14T13:47:06+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE53%EF%BC%9A%E4%B8%8D%E8%A6%81%E8%BD%BB%E5%BF%BD%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%AD%A6%E5%91%8A">条款53：不要轻忽编译器的警告</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE54%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89%E5%8C%85%E6%8B%ACtr1%E5%9C%A8%E5%86%85%E7%9A%84%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93">条款54：让自己熟悉包括TR1在内的标准程序库</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE55%EF%BC%9A%E8%AE%A9%E8%87%AA%E5%B7%B1%E7%86%9F%E6%82%89boost">条款55：让自己熟悉Boost</a></li>
</ul>
<!-- vim-markdown-toc -->
<p>这里有3个条款。第一个条款<strong>强调不可轻忽编译器警告信息</strong>。第二个条件<strong>总览C++<br>Standard，主要是TR1</strong>。最后条款<strong>总览Boost</strong>。很多机能都被在C++之后新特性中不断引入把。</p>
<h4 id="条款53：不要轻忽编译器的警告"><a href="#条款53：不要轻忽编译器的警告" class="headerlink" title="条款53：不要轻忽编译器的警告"></a>条款53：不要轻忽编译器的警告</h4><ol>
<li>严肃对待编译器发出的警告信息。</li>
<li>不要过度依赖编译器的报警能力，不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，原本依赖的警告信息有可能消失。</li>
</ol>
<h4 id="条款54：让自己熟悉包括TR1在内的标准程序库"><a href="#条款54：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="条款54：让自己熟悉包括TR1在内的标准程序库"></a>条款54：让自己熟悉包括TR1在内的标准程序库</h4><ol>
<li>C++98列入C++标准程序库有以下成分：<ul>
<li><font color=red>STL</font>（<font color=green>Standard Template Library</font>，<font color=red>标准模板库</font>）。覆盖容器（containers如vector，string，map）、迭代器（iterators）、算法（algorithms如find，sort，transform）、函数对象（function objects如less，greater）、各种容器适配器（container adapters如stack，priority_queue）和函数对象适配器（function object adapters如mem_fun,not1).</li>
<li>Iostreams，覆盖用户自定缓冲功能、国际化I/O，以及预先定义好的对象cin，cout，cerr和clog。</li>
<li>国际化支持，多区域（multiple active locales）能力。像wchar_t（通常是16 bits/char）和wstring（由wchar_ts组成的stirngs）等类型促进Unicode。</li>
<li>数值处理，包括复数模板（complex）和纯数值数组（valaray）。</li>
<li>异常阶层体系（exception hierarchy），包括base class exception及其derived classes logic_error和runtime_error，以及更深继承的各个classes。</li>
<li>C89标准程序库。</li>
</ul>
</li>
<li>C++11相对于C++98/03有哪些显著的增强呢？<ul>
<li>通过内存模型、线程、原子操作等支持本地并行编程（Native Concurrency）</li>
<li>通过统一初始化表达式、auto、decltype、移动语义等来统一对泛型编程的支持</li>
<li>通过constexpr、POD等来更好地支持系统编程</li>
<li>通过内联命名空间、继承构造函数和右值引用等来更好地支持库的构建</li>
</ul>
</li>
<li>C++11 知识点<blockquote>
<p>auto关键字、for-each循环、右值及移动构造函数 + std::forward + std::move + stl容器新增的emplace_back()方法、std::thread库、std::chrono库、智能指针系列（std::shared_ptr/std::unique_ptr/std::weak_ptr）(智能指针的实现原理一定要知道，最好是自己实现过)、线程库std::thread+线程同步技术库std::mutex/std::condition_variable/std::lock_guard等、lamda表达式（JAVA中现在也常常考察lamda表达式的作用）、std::bind/std::function库、其他的就是一些关键字的用法(override、final、delete)，还有就是一些细节如可以像JAVA一样在类成员变量定义处给出初始化值。</p>
</blockquote>
</li>
</ol>
<h4 id="条款55：让自己熟悉Boost"><a href="#条款55：让自己熟悉Boost" class="headerlink" title="条款55：让自己熟悉Boost"></a>条款55：让自己熟悉Boost</h4><ol>
<li>Boost是C++开发者集结的社群。它和C++标准委员会之间有独一无二的密切关系，Boost由委员会成员创设，因此Boost成员和委员会成员由很大的重叠。Boost的目标是作为一个可被加入标准C++之各种功能的测试场。</li>
<li>Boost程序库对付的主题非常繁多，包括：<ul>
<li><strong>字符串与文本处理</strong>，覆盖具备类型安全（type-safe）的pointer-like格式化动作、正则表达式，以及语汇单元切割（tokenizing）和解析（parsing）。</li>
<li><strong>容器</strong>，覆盖数组、大小可变的bitsets以及多维数组。</li>
<li><strong>函数对象和高级编程</strong>，覆盖若干用来作为TR1机能基础的程序库。其中一个程序库是Lambda。</li>
<li>泛型编程（Generic programming），覆盖traits classes。</li>
<li>模板元编程（Template metaprogramming，TMP）覆盖一个针对编译器assertions而写的程序库。</li>
<li>数学和数值（Math and numerics），包括有理数、八元数和四元数（octonions and quaternions）、常见的公约数（divisor）和少见的多重运算、随机数。</li>
<li>正确性与测试（Correctness and testing），覆盖隐式模板接口（implicit template interfaces）。</li>
<li>数据结构，覆盖类型安全（type-safe）的unions以及tuple程序库。</li>
<li>语言间的支持（Inter-language support），包括C++和Python之间的无缝互操作性（seamless interoperability）。</li>
<li>内存，覆盖Pool程序库，用来做出高效率而区块大小固定的分配器，以及多变化的智能指针（smart pointers）。</li>
<li>杂项，包括CRC检验、日期和时间的处理、在文件系统上来回移动等等。</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/8-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/" class="post-title-link" itemprop="url">8 定制new和delete</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:46:29" itemprop="dateCreated datePublished" datetime="2020-06-14T13:46:29+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE49%EF%BC%9A%E4%BA%86%E8%A7%A3new-handler%E7%9A%84%E8%A1%8C%E4%B8%BA">条款49：了解new-handler的行为</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE50%EF%BC%9A%E4%BA%86%E8%A7%A3new%E5%92%8Cdelete%E7%9A%84%E5%90%88%E7%90%86%E6%9B%BF%E6%8D%A2%E6%97%B6%E6%9C%BA">条款50：了解new和delete的合理替换时机</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE51%EF%BC%9A%E7%BC%96%E5%86%99new%E5%92%8Cdelete%E6%97%B6%E9%9C%80%E5%9B%BA%E5%AE%88%E5%B8%B8%E8%A7%84">条款51：编写new和delete时需固守常规</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE52%EF%BC%9A%E5%86%99%E4%BA%86placement-new%E4%B9%9F%E8%A6%81%E5%86%99placement-delete">条款52：写了placement new也要写placement delete</a></li>
</ul>
<!-- vim-markdown-toc -->
<p>以下operator new和operator delete的规则同样适用于operator new[]和operator<br>delete[]</p>
<h4 id="条款49：了解new-handler的行为"><a href="#条款49：了解new-handler的行为" class="headerlink" title="条款49：了解new-handler的行为"></a>条款49：了解new-handler的行为</h4><ol>
<li>当operator new无法满足某一内存分配需求时，就会抛出异常。在它抛出异常前，会先调用一个用户指定的错误处理函数，一个所谓的<code>new-handler</code>，为了指定这个函数，用户需要调用<code>set_new_handler</code>，那是声明于<new>的一个标准程序库函数： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">std::<span class="built_in">set_new_handler</span>(outOfMem);</span><br></pre></td></tr></table></figure>
 一个设计良好的new-handler函数必须做以下事情：<ul>
<li><strong>让更多内存可被使用</strong>。让operator new的下一次内存分配动作可能成功，就让程序一开始执行分配一大块内存，当new-handler第一次被调用，将它们释放给程序使用。</li>
<li><strong>安装另一个new-handler</strong>。如果目前这个new-handler无法取得个更多可用内存，或许其他new-handler有。那么这个new-handler则set_new_handler来替换自己。下次当operator new调用new-handler时，调用的将是最新安装的那个。</li>
<li><strong>卸除new-handler</strong>。一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常，这时候应该将null指针给set_new_handler。</li>
<li><strong>抛出bad_alloc（或派生自bad_alloc）的异常</strong>。这样异常不会被operator new捕捉，会被传播到内存索求处。</li>
<li><strong>不返回</strong>。调用abort或exit。</li>
</ul>
</li>
<li>使用class内自定义的operator new的set_new_handler可以替换global new-handler。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取得当前的的new-handler</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(std::new_handler nh)</span> : handler(nh) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">// 释放它</span></span><br><span class="line">    ~<span class="built_in">NewHandlerHolder</span>() &#123;       </span><br><span class="line">        std::<span class="built_in">set_new_handler</span>(handler); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::new_handler handler;</span><br><span class="line">    <span class="comment">// 禁用copying函数</span></span><br><span class="line">    <span class="built_in">NewHandlerHolder</span>(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">    NewHandlerHolder&amp; oeprator=(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler currentHandler = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 安装Widget的new-handler</span></span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="comment">// 恢复global new-handler</span></span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明，将在Widget对象分配失败时被调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 设定outOfMem为Widget的new-hander函数</span></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(outOfMem);</span><br><span class="line"><span class="comment">// 分配失败调用outOfMem</span></span><br><span class="line">Widget *pw1 = <span class="keyword">new</span> Widget;</span><br><span class="line"><span class="comment">// 分配失败调用global new-handler函数</span></span><br><span class="line">std::string *ps = <span class="keyword">new</span> std::string;</span><br><span class="line"><span class="comment">// 设定Widget专属的new-handing函数为null</span></span><br><span class="line">Widget::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 如果分配失败，立刻抛出异常</span></span><br><span class="line">Widget *pw2 = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure></li>
<li>现在设计一个可以被任何有需要的class使用的template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerSupport</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::new_handler <span class="title">set_new_handler</span><span class="params">(std::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> std::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::<span class="built_in">set_new_handler</span>(std::new_handler p) <span class="keyword">throw</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(std::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::new_handler NewHandlerSupport&lt;T&gt;::currenHandler = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于显式声明nothrow，只能保证operator new不抛出异常，构造函数可能又new一些内存，这就无法强迫了</span></span><br><span class="line"><span class="comment">// Widget *pw = new (std::nothrow)Widget;</span></span><br></pre></td></tr></table></figure>
 <font color=red>怪异的循环模板模式</font >（<font color=green>curiously recurring template pattern</font>;<font color=red>CRTP</font>）。</li>
</ol>
<h4 id="条款50：了解new和delete的合理替换时机"><a href="#条款50：了解new和delete的合理替换时机" class="headerlink" title="条款50：了解new和delete的合理替换时机"></a>条款50：了解new和delete的合理替换时机</h4><ol>
<li>为什么要替换编译期提供的operator new或operator delete呢？由三个理由：<ul>
<li><strong>用来检测运用上的错误</strong>。如果new出的内存delete失败，会导致<font color=red>内存泄露</font>（<font color=green>memory leaks</font>）。new上多次delete会导致不确定行为。如果我们自行定义operator news，超额分配内存，在额外内存上放置byte patterns（签名，signatures）。这样delete时就可以发现分配区中有哪些点发生了overrun（写入点在分配区尾端之后）或underruns（写入点在分配区起点之前）。这时候就可以log那个事实了。</li>
<li><strong>为了强化效能</strong>。对于一些需求，包括大块内存、小块内存、大小混合型内存。它们接纳各种分配形态，从程序存活期间的少量区块动态分配，到大量短命对象的持续分配和归还。必须考虑<font color=red>破碎问题</font>（<font color=green>fragmentation</font>）。这会导致程序有总量足够但分散为很多小区块的自由内存，却无法分配大区块内存。</li>
<li><strong>为了收集使用上的统计数据</strong>。制定news和delete之前，先收集软件如何使用动态内存。分配区块的大小分配？寿命分布？FIFO次序还是LIFO次序或随机分配？不同执行阶段有不同分配/归还形态？任何时刻使用最大动态分配量是多少？</li>
</ul>
</li>
<li> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte;</span><br><span class="line"><span class="comment">// 还有若干错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="comment">// 增加大小，使之能够塞入两个signatures</span></span><br><span class="line">    <span class="keyword">size_t</span> realSize = size + <span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span>* pMem = <span class="built_in">malloc</span>(realSize);</span><br><span class="line">    <span class="keyword">if</span> (!pMem) <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">    <span class="comment">// 将signature写入内存的前段落和后段落</span></span><br><span class="line">    *(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">    *(reinterrpret_cast&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) + realSize - <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>))) = signature;</span><br><span class="line">    <span class="comment">// 返回指针，指向第一个signature之后的内存位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <font color=red>计算机体系结构</font>（<font color=green>computer architectures</font>）要求特定的类型必须放在特定内存地址上，例如指针的地址必须是<font color=red>4倍数</font>（<font color=green>for-byte aligned</font>）或doubles地址是<font oclor=red>8倍数</font>（<font color=green>eight-byte aligned</font>）。<font color=red>齐位</font>（<font color=green>alignment</font>）意义重大，C++要求operator news返回的指针都有适当的内存对齐。malloc就是在这样做的，所以operator new返回一个malloc指针是安全的。然而上面代码中返回一个malloc且偏移一个int大小的指针，没人保证它的安全！</li>
<li>摘要：<ul>
<li>为了检测运用错误。</li>
<li>为了收集动态分配内存之使用统计信息</li>
<li>为了增加分配和归还速度</li>
<li>为了降低缺省内存管理器带来的空间额外开销。</li>
<li>为了弥补缺省分配器中的非最佳齐位（suboptimal alignment）。</li>
<li>为了将相关对象成簇集中。</li>
<li>为了获得非传统的行为。</li>
</ul>
</li>
</ol>
<h4 id="条款51：编写new和delete时需固守常规"><a href="#条款51：编写new和delete时需固守常规" class="headerlink" title="条款51：编写new和delete时需固守常规"></a>条款51：编写new和delete时需固守常规</h4><ol>
<li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，应该调用new-handler。它也应该有能力处理0 bytes、null指针申请。class专属版本还应该处理”比正确大小更大的（错误）申请“。</li>
</ol>
<h4 id="条款52：写了placement-new也要写placement-delete"><a href="#条款52：写了placement-new也要写placement-delete" class="headerlink" title="条款52：写了placement new也要写placement delete"></a>条款52：写了placement new也要写placement delete</h4><ol>
<li> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常的operator new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="comment">// global作用域中的正常签名式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// class作用域中典型的签名式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *rawMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
 如果operator new接受的参数除了一定会有个size_t之外还有其他，这就是所谓的<font color=red>placement new</font>。众多placement new版本中特别有用的一个是”接受一个指针指向对象该被构造之处“： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>, <span class="keyword">void</span> *pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">// placement new</span></span><br></pre></td></tr></table></figure>
 这个版本在C++ STL中，只要#include &lt;new&gt;就可以用它。<br> 举个例子，现在写一个class专属的operator new，要求接受一个ostream，用来log相关分配信息，同时写一个正常形式的class专属operator delete： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 非正常形式的new</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::size size, std::ostream &amp;logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="comment">// 正常class专属delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里有微妙的内存泄漏</span></span><br><span class="line"><span class="comment">// 调用operator new并传递cerr为其ostream实参，这个动作会在构造函数抛出异常时泄露内存</span></span><br><span class="line">Widget *pw = <span class="built_in"><span class="keyword">new</span></span> (std::cerr) Widget;</span><br></pre></td></tr></table></figure>
 对于类似的new placement版本，operator delete如果接受额外参数，称为placement deletes。带有额外参数的operator new应该调用带相同额外参数的对应版本operator delete。  </li>
<li>为了消弭代码中的内存泄露，Widget有必要声明一个placement delete，对应于有志记功能（logging）的placement new： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, std::ostream &amp;logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, std::ostream &amp;logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 对于placement delete自动调用期间构造函数可能会抛出异常，代码会自动调用placement delete；如果没有抛出异常，则只会调用普通operator delete。<br> 顺带一提，成员函数的名称会掩盖外围作用域中的相同名称，假设有一个base class，其中声明唯一的placement operator new，用户会无法使用正常的new： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 会掩盖正常版本</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, std::ostream &amp;logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Base *pb = <span class="keyword">new</span> Base;                <span class="comment">// error</span></span><br><span class="line">Base *pb = <span class="built_in"><span class="keyword">new</span></span> (std::cerr) Base;    <span class="comment">// ok</span></span><br><span class="line">Derived *pb = <span class="built_in"><span class="keyword">new</span></span> (std::clog) Derived;<span class="comment">// error</span></span><br><span class="line">Derived *pb = <span class="keyword">new</span> Derived;          <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
 需要记住的时，C++在global作用域中提供了以下operator new： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line"><span class="comment">// placement new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>, <span class="keyword">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// nothrow new</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span>, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span> &amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">// 49</span></span><br></pre></td></tr></table></figure>
 除非你要阻止class用户使用这些形式，否则确保它们在你生成的定制型operator new之外还可用。对于每个operator new也有对应的operator delete。如果希望这些函数有平常的行为，令你class专属版本调用global版本： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardNewDeleteForms</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// normal new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// placement new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">void</span> *ptr)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, ptr); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="keyword">void</span> *ptr)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::opeator <span class="built_in"><span class="keyword">delete</span></span>(pMemory, ptr); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nothrow new/delete</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span> &amp;nt)</span> <span class="keyword">throw</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(size, nt); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, <span class="keyword">const</span> std::<span class="keyword">nothrow_t</span> &amp;)</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pMemory)</span></span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 供想自定义扩充标准形式的用户，利用继承机制或using声明式（33）取得标准形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> StandardNewDeleteForms</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">using</span> StandardNewDeleteForms::<span class="keyword">operator</span> <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="keyword">size_t</span> size, std::ostream &amp;logStream)</span> <span class="title">throw</span><span class="params">(std::bad_alloc)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> oeprator <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *pMemory, std::ostream &amp;logStream)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/7-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">7 模板与泛型编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:45:58" itemprop="dateCreated datePublished" datetime="2020-06-14T13:45:58+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE41%EF%BC%9A%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81">条款41：了解隐式接口和编译期多态</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE42%EF%BC%9A%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89">条款42：了解typename的双重意义</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE43%EF%BC%9A%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0">条款43：学习处理模板化基类内的名称</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE44%EF%BC%9A%E5%B0%86%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E6%8A%BD%E7%A6%BBtemplates">条款44：将与参数无关的代码抽离templates</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE45%EF%BC%9A%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B">条款45：运用成员函数模板接受所有兼容类型</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE46%EF%BC%9A%E9%9C%80%E8%A6%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E8%AF%B7%E4%B8%BA%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0">条款46：需要类型转换时请为模板定义非成员函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE47%EF%BC%9A%E8%AF%B7%E4%BD%BF%E7%94%A8traits-classes%E8%A1%A8%E7%8E%B0%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF">条款47：请使用traits classes表现类型信息</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE48%EF%BC%9A%E8%AE%A4%E9%80%82template%E5%85%83%E7%BC%96%E7%A8%8B">条款48：认适template元编程</a></li>
</ul>
<!-- vim-markdown-toc -->
<p>C++<br>templates的最初发展动机很直接：让我们得以建立type-sfae的容器（vector、list、map等）。后来发现templates有能力完成愈多可能的变化。<font 
color=red>泛型编程</font>（<font color=green>generic<br>programming</font>）——<em>写出的代码和其所处理的对象类型彼此独立</em>（for_each、find、merge等）。最终人们发现C++<br>template机制自身是完整的<font color=red>图灵机</font>（<font 
color=green>Turing-complete</font>）。于是导出<font 
color=red>模板元编程</font>（<font color=green>template<br>metaprogramming</font>），创造出在C++编译器内执行并于编译完成时停止执行的程序。</p>
<h4 id="条款41：了解隐式接口和编译期多态"><a href="#条款41：了解隐式接口和编译期多态" class="headerlink" title="条款41：了解隐式接口和编译期多态"></a>条款41：了解隐式接口和编译期多态</h4><ol>
<li>面向对象编程世界总是以<font color=red>显示接口</font>（<font color=green>explicit interfaces</font>）和<font color=red>运行期多态</font>（<font color=green>runtime polymorphism</font>）解决问题。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Widget</span>();</span><br><span class="line">    <span class="function">virutal std::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;other)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(Widget &amp;w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>();</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 template及泛型编程的世界，显式接口和运行期多态仍然存在，但重要性降低。反倒是<font color=red>隐式接口</font>（<font color=green>implicit interfaces</font>）和<font color=red>编译期多态</font>（<font color=green>compile-time polymorphism</font>）移到前头。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T &amp;w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.<span class="built_in">normalize</span>();</span><br><span class="line">        temp.<span class="built_in">swap</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 这组表达式便是T必须支持的一组隐式接口（implicit interface）。凡涉及w相关的函数调用，如operator&gt;和operator!=，有可能造成template<font color=red>具体化</font>（<font color=green>instantiated</font>），使这些调用成功，这样的具现行为发生在编译期，这就是所谓的编译期多态（compile-time polymorphism）。</li>
<li>对classes而言接口是显式的（explicit），以函数签名为中心。多态则是通过virtual函数发生于运行期。对template参数而言，接口是隐式的（implicit），奠基于有效表达式。多态则是通过template具现化和函数重载解析（function overloading resolution）发生于编译期。</li>
</ol>
<h4 id="条款42：了解typename的双重意义"><a href="#条款42：了解typename的双重意义" class="headerlink" title="条款42：了解typename的双重意义"></a>条款42：了解typename的双重意义</h4><ol>
<li>template内出现的名称如果相依于某个template参数，称之为<font color=red>从属名称</font>（<font color=green>dependent names</font>）。如果从属名称在class内呈嵌套状，称之为<font color=red>嵌套从属名称</font>（<font color=green>nested dependent name</font>），也就是嵌套从属名称并且指涉某类型；否则一个并不依赖任何template参数的名称。这样的名称是<font color=red>非从属名称</font>（<font color=green>non-dependent names</font>）。</li>
<li>任何当你想要在template中指涉一个嵌套嵌套类型名称，必须在它的前一个位置放上关键字typename。这一规则的例外是，typename不可以出现在base classes list内的嵌套从属类型名称之前，也不可在member initialization list中作为base class修饰符。例如： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base class list中不允许typename</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// mem init list中不允许typename</span></span><br><span class="line">    <span class="function">expliit <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span> : Base&lt;T&gt;::Nested(x) //</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="comment">// 既不在base class list中也不在mem init list中，需要加上typename</span></span><br><span class="line">        <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// traits class相当于类型为IterT对象所指对象的类型，如果IterT是list&lt;string&gt;::iterator, temp的类型就是string</span></span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款43：学习处理模板化基类内的名称"><a href="#条款43：学习处理模板化基类内的名称" class="headerlink" title="条款43：学习处理模板化基类内的名称"></a>条款43：学习处理模板化基类内的名称</h4><ol>
<li>以下代码编译时出错： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printBase</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printDerived</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">printBase</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 问题在于当编译器遭遇class template derived定义式时，并不知道它继承什么样的class，它不知道T是个template参数，不到后来具现化无法确切知道它是什么。而不知道T是什么，也就不知道class base看起来像什么。</li>
<li>针对某个类产生一个特化版，需要在class定义式最前头加上“template&lt;&gt;”。这就是所谓的<font color=red>模板全特化</font>（<font color=green>total template specialization</font>）。对于某个被特化的base class templates，那个特化版本可能不提供和一般性template相同的接口，因此它往往拒绝在<font color=green>templatized base classes</font>（<font color=red>模板化基类</font>）内<strong>寻找</strong>继承而来的名称。就某种意义上来说，从Object Oriented C++跨进Template C++就不是畅通无阻了。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span><span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">printBase</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A::int special&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>为了进入templatized base classes，有三个办法：<ul>
<li>第一是在调用base class函数动作之前加上“this-&gt;”<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;<span class="built_in">printBase</span>();</span><br></pre></td></tr></table></figure></li>
<li>第二是使用using声明式。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> A&lt;T&gt;::<span class="built_in">printBase</span>();</span><br></pre></td></tr></table></figure></li>
<li>第三种是明白指出调用的函数位于base class内。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&lt;T&gt;::<span class="built_in">printBase</span>();</span><br></pre></td></tr></table></figure>
这是最不让人满意的揭发，如果被调用的是virtual函数，上述的<font color=red>明确资格修饰</font>（<font color=green>explicit qualification</font>）会关闭“virtual绑定行为”。</li>
</ul>
</li>
</ol>
<h4 id="条款44：将与参数无关的代码抽离templates"><a href="#条款44：将与参数无关的代码抽离templates" class="headerlink" title="条款44：将与参数无关的代码抽离templates"></a>条款44：将与参数无关的代码抽离templates</h4><ol>
<li>举个例子，用固定尺寸的正方矩阵编写一个template： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n * n矩阵</span></span><br><span class="line">tepmlate&lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 求逆矩阵</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">sm1.<span class="built_in">invert</span>();</span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">sm2.<span class="built_in">invert</span>();</span><br></pre></td></tr></table></figure>
 这个template接受一个类型参数T，还接受一个size_t的参数，这是<font color=red>非类型参数</font>（<font color=green>non-type parameter</font>）。这些函数并非完全相同，除了常量5和10的区别外完全相同，这就是template引出<strong>代码膨胀</strong>的经典例子。改进方式： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">SquareMatrixBase</span>(std::<span class="keyword">size_t</span> n, T *pMem) : <span class="built_in">size</span>(n), <span class="built_in">pData</span>(pMem) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataPtr</span><span class="params">(T *ptr)</span> </span>&#123; pData = ptr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">size_t</span> size;</span><br><span class="line">    T *pData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[n * n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态分配办法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, std::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SquareMatrix</span>() : SquareMatrixBase&lt;T&gt;(n, <span class="number">0</span>), <span class="built_in">pData</span>(<span class="keyword">new</span> T[n * n])</span><br><span class="line">    &#123; <span class="keyword">this</span>-&gt;<span class="built_in">setDataPtr</span>(pData.<span class="built_in">get</span>()); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    boost::scoped_array&lt;T&gt; pData; <span class="comment">// std::array??</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这个条款讨论的是<font color=green>non-type template parameters</font>（非类型模板参数）带来的膨胀，其实<font color=red>type parameters</font>（类型参数）也会导致膨胀。因此凡templates持有指针者应该对每个成员函数使用唯一一份底层实现。这意味着实现某些成员函数操作<font color=red>强型指针</font>（<font color=green>strongly typed pointers</font>，即T*），令它们调用<font color=red>无类型指针</font>（<font color=green>untyped pointers</font>，即void*）的函数。</li>
<li>因非类型模板参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。因类型参数而造成的代码膨胀，往往可降低，做法是让带有完全相同<font color=red>二进制表述</font>（<font color=green>binary representations</font>）的<font color=red>具体类型</font>（<font color=green>instantiation types</font>）共享实现码。</li>
</ol>
<h4 id="条款45：运用成员函数模板接受所有兼容类型"><a href="#条款45：运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45：运用成员函数模板接受所有兼容类型"></a>条款45：运用成员函数模板接受所有兼容类型</h4><ol>
<li>智能指针（Smart pointers）是“行为像指针“的对象，提供指针没有的机能。真实的指针支持隐式转换（inplicit conversions）。而用户自定义的智能指针模拟转换有点麻烦： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以other的heldPtr初始化this的heldPtr</span></span><br><span class="line">    <span class="function">tempalte&lt;<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">    <span class="title">SmartPtr</span><span class="params">(<span class="keyword">const</span> SmartPtr&lt;U&gt; &amp;oher)</span> : heldPtr(other.get()) &#123;</span> ... &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 根据对象u创建对象t，根据SmartPtr&lt;U&gt;创建SmartPtr<T>，同一个template不同具现体称为泛化（generalized）copy构造函数。以上使用member initialization list来初始化SmartPtr&lt;t&gt;内类型为T<em>的成员变量，并以类型为U</em>的指针为初值。</li>
<li>成员函数模板作用不限于构造函数。TR1的shared_ptr支持所有兼容它的内置指针、shared_ptrs、auto_ptrs、week_ptrs的构造行为以及赋值作用： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// copy构造函数</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr <span class="keyword">const</span> &amp;r);</span><br><span class="line">    <span class="comment">// copy assignment</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr <span class="keyword">const</span> &amp;r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任何兼容的内置指针</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class Y&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y *p)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// shared_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class Y&gt;</span></span><br><span class="line"><span class="function">    <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt; <span class="keyword">const</span> &amp;r)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// week_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;class Y&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(week_ptr&lt;Y&gt; <span class="keyword">const</span> &amp;r)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// auto_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;classs Y&gt;</span></span><br><span class="line"><span class="function">    explcit <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt; &amp;r)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="keyword">const</span> &amp;r);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt; &amp;r);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 在class内声明泛型copy构造函数（member template）并不会阻止编译期生成它们自己的copy构造函数（一个non-template）。</li>
</ol>
<h4 id="条款46：需要类型转换时请为模板定义非成员函数"><a href="#条款46：需要类型转换时请为模板定义非成员函数" class="headerlink" title="条款46：需要类型转换时请为模板定义非成员函数"></a>条款46：需要类型转换时请为模板定义非成员函数</h4><ol>
<li>参考条款24： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="keyword">const</span> T &amp;numerator = <span class="number">0</span>, <span class="keyword">const</span> T &amp;denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt; &amp;lhs, <span class="keyword">const</span> Rational&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational&lt;<span class="keyword">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;        <span class="comment">// 这个例子来自条款24</span></span><br><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = oneHalf * <span class="number">2</span>; <span class="comment">// 错误，无法通过编译。</span></span><br></pre></td></tr></table></figure>
 它给我们的启示是，模板化的Rational内的某些东西似乎和其non-template版本不同。编译期不知道它要调用哪个函数。operator*的第一个参数被声明为Rational&lt;T&gt;，而传递给operator*的的第一个实参的类型是Rational&lt;int&gt;，所以T是int。operator*的第二参数被声明为Rational<T>，但传递给operator*的第二实参的类型是int。你期望编译器使用Rational&lt;int&gt;的non-explicit构造函数将2转换为Rational&lt;int&gt;，但它不这么做。template实参推导过程中并不考虑采纳”通过构造函数而发生的“隐式类型转换。</li>
<li>只要利用一个事实，可以缓和编译器在template实参推导方面受到的挑战：<strong>template class内的friend声明式可以指涉某个特定函数</strong>。class templates并不依赖template实参推导（后者只施行于function templates身上），所以编译器总是能够在class Rational<T>具现化时得知T。令Rational<T> class声明适当的operator*为其friend函数，可简化整个问题： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 为了让这个函数自动具现化，在class内声明non-member函数的唯一方法是让它称为一个friend</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numerator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominaotr</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了让类型转换可能发生于所有实参身上，其实这个函数可以当作friend函数的辅助函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt; &amp;lhs, <span class="keyword">const</span> Rational&lt;T&gt; &amp;rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
 现在对operator*的混合式调用可以通过编译了，因为当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rationao&lt;int&gt;就被具化出来，friend函数也就被自动声明出来（这里的Rational&lt;T&gt;可以省略）。后者身为一个函数而非函数模板，因而编译器在调用它时使用隐式转换函数。</li>
</ol>
<h4 id="条款47：请使用traits-classes表现类型信息"><a href="#条款47：请使用traits-classes表现类型信息" class="headerlink" title="条款47：请使用traits classes表现类型信息"></a>条款47：请使用traits classes表现类型信息</h4><ol>
<li>STL迭代器有5种分类，每类迭代器之间都是继承关系： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// input迭代器只能向前移动，一次一步，只可读取，只能读一次。如istream_iterator</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="comment">// output迭代器一切只为输出，它向前移动，一次一步，只能涂写一次。如ostream_iterator</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="comment">// 这两类只能向前移动，而且只能读或写一些，它们只适合”一次性操作算法“（one-pass algorithms）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forward迭代器可以读或写多次，可施行于多次行操作算法（multi-pass algorithms）。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input _iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bidirectional迭代器除了可以向前移动，还可向后移动（set、multiset、map和multimap</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// random access迭代器除了可以向前向后，还可随机访问</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bdirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li>STL中有个工具性template，叫advance，用来将某个迭代器移动若干给定距离： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有工作都运行期，这这个typeid-based解法比traits解法效率低</span></span><br><span class="line"><span class="comment">// 48条款</span></span><br><span class="line"><span class="function">templaet&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (iter i a random access iterator) &#123;</span><br><span class="line">        iter += d;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 为了处理迭代器分类的相关信息，我们需要traits来在编译期间取得某些类型信息，而traits技术必须对<font oclor=red>内置</font>（<font color=green>built-in</font>）类型和<font color=red>用户自定义</font>（<font color=green>user-defined</font>）类型一样有效运行。这样的template在STL中有若干个，其中针对迭代器的有<code>iterator_traits</code>。<br> 它的运作方式是，它首先要求每个用户自定义的迭代器类型嵌套一个typedef，名为iterator_category，用来确认适当的<font color=red>卷标结构</font>（<font color=green>tag struct</font>）。<br> 例如，针对deque和双向list： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; ... &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; ... &gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator_traits只是鹦鹉学舌</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">    ..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 这对用户自定义类型行得通，对指针（也是一种迭代器）行不通。为了支持指针迭代器，iterator_traits针对指针类型提供了一个<font color=red>偏特化版本</font>（<font color=green>partial template specialization</font>）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterator_traits的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;</span>IterT*&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 有了std::iterator_traits后，可以对advance践行之前的伪码了，而为了接受不同类型的iterator_category对象，则需要<font color=red>重载</font>（<font color=green>overloading</font>）： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// random access迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, typenmae DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::random_access_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bidirectional迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::bidirectional_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++ iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT &amp;iter, DistT d, std::input_iterator_tag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Negative distance&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (d--) ++iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有了doAdvance重载版本，advance做的只是调用它们并传递对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (typeid(typename std::iterator_traits&lt;IterT&gt;::iterator_category) == typeid(std::random_access_iterator_tag))</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">doAdvance</span>(iter, d, <span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="built_in">iterator_category</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>STL中除了Iterator_traits供应iterator_category还供应另外四种迭代器：<code>value_type</code>、<code>char_traits</code>、<code>numeric_limits</code>等。STL中还有很多其他新的traits classes用以提供类型信息，如<code>is_fundamental&lt;T&gt;</code>（判断T是否为内置类型），<code>is_array&lt;T&gt;</code>（判断T是否为数组类型）以及<code>is_base_of&lt;T1, T2&gt;</code>（T1和T2相同，或T1是T2的base class）。</li>
</ol>
<h4 id="条款48：认适template元编程"><a href="#条款48：认适template元编程" class="headerlink" title="条款48：认适template元编程"></a>条款48：认适template元编程</h4><ol>
<li><font color=green>Template metaprogramming</font>(<font color=red>TMP</font>，<font color=red>模板元编程</font>)是编写template-based C++程序并执行于编译器的过程。</li>
<li>47条款中的伪码部分： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面对某些自定义类型，会编译失败</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT &amp;iter, DistT d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in"><span class="keyword">typeid</span></span>(<span class="keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category) == <span class="built_in"><span class="keyword">typeid</span></span>(std::random_access_iterator_tag)) &#123;</span><br><span class="line">        iter += d;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>TMP已被证明是”图灵完全“（Turing-complete）机器，针对TMP而涉及的程序库提供了更高级的语法。TMP并没有真正的循环结构，所有的循环效果都是由<font color=red>递归</font>（<font color=green>recursion</font>）完成。TMP主要是个函数时语言（functional language），而递归在这类语言是无法分割的，TMP循环并不涉及递归函数调用，而是涉及”<font color=red>递归模板具现化</font>“（<font color=green>recursive template instantiation</font>）。以下是示例源码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况下</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = n * Factorial&lt;n - <span class="number">1</span>&gt;::value &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 特殊情况下，当到0时</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;</span><span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span> value = <span class="number">1</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>TMP能够达到什么目标呢：<ol>
<li>确保度量单位正确。在科学和工程应用程序中，可以用TMP确保在编译期时确保所有度量单位组合正确，防范于未然。</li>
<li>优化矩阵运算。</li>
<li>生成用户定制之设计模式（custom design pattern）实现品。这项技术已被用来让若干templates实现出智能指针的行为策略（behavioral policies），用来在编译期间生成数以百计不同的智能指针类型。这项技术超越编程工艺如设计模式和智能指针，更广义成为<font color=green>generative programming</font>（<font color=red>殖生式编程</font>）的一个基础。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/6-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">6 继承与面向对象设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:45:21" itemprop="dateCreated datePublished" datetime="2020-06-14T13:45:21+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE32%EF%BC%9A%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB">条款32：确定你的public继承塑模出is-a关系</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE33%EF%BC%9A%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0">条款33：避免遮掩继承而来的名称</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE34%EF%BC%9A%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">条款34：区分接口继承和实现继承</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE35%EF%BC%9A%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9">条款35：考虑virtual函数以外的其他选择</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款32：确定你的public继承塑模出is-a关系"><a href="#条款32：确定你的public继承塑模出is-a关系" class="headerlink" title="条款32：确定你的public继承塑模出is-a关系"></a>条款32：确定你的public继承塑模出is-a关系</h4><ol>
<li><strong>public inheritance（公开继承）意味”<font color=red>is-a</font>“（是一种）的关系。</strong></li>
<li>令class D（”Derived”）以public形式继承class B（“Base”），意味着每个类型为D的对象同时也是一个类型为B的对象，反之不成立。B比D概念上更一般化，D比B更特殊化。</li>
<li>对于现实世界，我们可能对已有事物进行概念上的内涵和外延来抽象不同的状态和动作。企鹅是一种鸟，然而它不会飞，对于鸟会飞的先入为主的观念，可能会使实际偏颇。“企鹅不会飞”这一限制可由编译期强制实施，但若违反“企鹅尝试飞行，是一种错误”这一条规则，只有运行期才能检测出来。</li>
<li>is-a并非是唯一存在于classes之间的关系。另两个常见的关系是<font color=red>has-a</font>（有一个）和<font color=red>is-implemented-in-terms-of</font>（根据某物实现出）。</li>
</ol>
<h4 id="条款33：避免遮掩继承而来的名称"><a href="#条款33：避免遮掩继承而来的名称" class="headerlink" title="条款33：避免遮掩继承而来的名称"></a>条款33：避免遮掩继承而来的名称</h4><ol>
<li>derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或<font color=red>转交函数</font>（<font color=green>orwarding functions</font>）。</li>
</ol>
<h4 id="条款34：区分接口继承和实现继承"><a href="#条款34：区分接口继承和实现继承" class="headerlink" title="条款34：区分接口继承和实现继承"></a>条款34：区分接口继承和实现继承</h4><ol>
<li>public继承概念由两部分组成：<font color=red>函数接口</font>（<font color=green>function interfaces</font>）继承和<font color=red>函数实现</font>（<font color=green>function implementations</font>）继承。</li>
<li><strong>声明一个<font color=red>pure virtual</font>函数的目的式为了让derived classes只继承函数接口。声明纯朴的<font color=red>impure virtual</font>函数的目的，是让derived classes函数继承改函数的接口和缺省实现。声明<font color=red>non-virtual</font>函数的目的是为了令derived classes继承函数的接口及一份强制性实现。</strong></li>
</ol>
<h4 id="条款35：考虑virtual函数以外的其他选择"><a href="#条款35：考虑virtual函数以外的其他选择" class="headerlink" title="条款35：考虑virtual函数以外的其他选择"></a>条款35：考虑virtual函数以外的其他选择</h4><ol>
<li>令客户通过public non-virtual成员函数间接调用private virtual函数，称为<font color=red>non-virtual interface（NVI）</font>手法。它是Template Method设计模式的独特表现形式。</li>
<li>Strategy设计模式简单应用：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NVI写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="built_in">doHealthValue</span>();</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function Pointers写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>    <span class="comment">// forward declaration</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::fucntion写法</span></span><br><span class="line"><span class="comment">// 与FP写法不同的是，std::function对象相当于一个指向函数的泛化指针。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::function&lt;<span class="built_in"><span class="keyword">int</span></span> (<span class="keyword">const</span> Characater&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span> : healthFunc(hcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="built_in">healthFunc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthClacFunc healthFunc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 古典设计模式写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter &amp;gc)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">HealthCalcFunc defaultHealthCalc;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc *phcf = &amp;defaultHealthCalc)</span> : pHealthCalc(phcf) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthvalue</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> pHealthcalc-&gt;<span class="built_in">calc</span>(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc *pHealthcalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
```C++<br>// 有着更惊人的弹性</li>
</ol>
<p>// 健康计算函数<br>short calchealth(const GameCharacter&amp;);<br>// 为计算健康而设计的函数对象<br>struct HealthCalclator<br>{<br>    int operator()(const GameCharacter&amp;) const<br>    { … }</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/5-%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/5-%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">5 实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:44:50" itemprop="dateCreated datePublished" datetime="2020-06-14T13:44:50+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE26%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4">条款26：尽可能延后变量定义式的出现时间</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE27%EF%BC%9A%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C">条款27：尽量少做转型动作</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE28%EF%BC%9A%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86">条款28：避免返回handles指向对象内部成分</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE29%EF%BC%9A%E4%B8%BA%E2%80%9D%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84">条款29：为”异常安全“努力是值得的</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE30%EF%BC%9A%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96">条款30：透彻了解inlining的里里外外</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE31%EF%BC%9A%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E">条款31：将文件间的编译依存关系降至最低</a></li>
</ul>
<!-- vim-markdown-toc -->
<p>大多数情况下，适当提出classes或class templates定义以及functions和function<br>templates声明，是最花费心力的两件事。<em><strong>太快定义变量可能造成效率上的拖延；过度使用转型可能导致代码变慢又难维护，又找来微妙的理解错误；返回对象内部数据的handle可能会破坏封装并留给客户dangling<br>handles；未考虑异常带来的冲击则可能导致资源泄露和数据败坏；过度热心地inlining可能引起代码膨胀；过度耦合（coupling）则可能导致让人不满意的冗长build<br>times。</strong></em></p>
<h4 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h4><ol>
<li>当定义了一个类型带有构造函数或析构函数，就得付出构造成本和析构成本。如果函数可能抛出异常，最好将未使用的变量尽量延后声明（为何不声明定义分割是因为将函数构造出来再赋值比直接构造时指定初值效率低）。</li>
<li>对于在循环结构中定义在里头还是外头需要权衡：如果赋值成本比“构造+析构”成本高，那么倒不如在循环结构中定义。</li>
</ol>
<h4 id="条款27：尽量少做转型动作"><a href="#条款27：尽量少做转型动作" class="headerlink" title="条款27：尽量少做转型动作"></a>条款27：尽量少做转型动作</h4><ol>
<li>回顾转型语法：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old-style casts</span></span><br><span class="line">(T)<span class="function">expression</span></span><br><span class="line"><span class="function"><span class="title">T</span><span class="params">(expression)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// C++-style casts</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">    const_cast通常用来将对象常量行转除（cast away he constness）</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">const_cast</span>&lt;T&gt;<span class="params">(expression)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">    dynamic_cast主要用来执行安全向下转型（safe downcasting），用来决定某对象是否归属继承体系中的某个类型，它是唯一无法由旧式语法执行的动作，也很耗费重大运行成本的转型动作</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">dynamic_cast</span>&lt;T&gt;<span class="params">(expression)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">    reinterpret_cast意图执行低级转型，它取决于编译器，不可移植。它可以这么用，将pointer to int转型为一个int</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">reinterpret_cast</span>&lt;T&gt;<span class="params">(expression)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">    static_cast用来强迫隐式转换（implicit conversions），它基本什么都能做，就是无法将const转为non-const，这只有const_cast办得到。</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function">satic_cast&lt;T&gt;<span class="params">(expression)</span></span></span><br></pre></td></tr></table></figure>
有人觉得转型起始什么都没做，其实这是错误的观念：底层转型表述几乎会产生一些代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base *pb = &amp;d;</span><br></pre></td></tr></table></figure>
这里不过是建立一个base class指针指向一个derived class对象，但有时候两个指针值并不相同。这种情况下会有个<font color=red>偏移量</font>（<font color=green>offset</font>）在<strong>运行期</strong>被施行于Derived*指针身上，才取得正确Base*指针值。<br>我们很容易写出似是而非的代码（在其他语言可能是真的）。例如derived classes内的virtual函数代码调用base class对应函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    这段程序将*this转型为Window，它调用的不是当前对象上的函数，</span></span><br><span class="line"><span class="comment">    而是*this对象的baseclass部分的一个临时副本。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Winddow&gt;(*<span class="keyword">this</span>).<span class="built_in">onResize</span>();</span><br><span class="line">        <span class="comment">// 正确做法是：</span></span><br><span class="line">        Window::<span class="built_in">onResize</span>();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款28：避免返回handles指向对象内部成分"><a href="#条款28：避免返回handles指向对象内部成分" class="headerlink" title="条款28：避免返回handles指向对象内部成分"></a>条款28：避免返回handles指向对象内部成分</h4><ol>
<li>一个成员函数返回<font color=red>references</font>、<font color=red>pointers</font>和<font color=red>itertors</font>，这些统统都是所谓的<font color=red><strong>handles</strong></font>（号码牌，用来取得某个对象）。而一个返回“代表对象内部数据”的handle，随之而来的是降低对象封装性的风险。</li>
</ol>
<h4 id="条款29：为”异常安全“努力是值得的"><a href="#条款29：为”异常安全“努力是值得的" class="headerlink" title="条款29：为”异常安全“努力是值得的"></a>条款29：为”异常安全“努力是值得的</h4><ol>
<li>当异常被抛出时，带有<font oclor=red>异常安全性</font>（<font color=green>Exception safety</font>）的函数一般不泄露任何资源并不允许数据败坏。这样的函数可分为三种保证：基本型、强烈型和不抛出异常型。</li>
<li>强烈保证以copy-and-swap实现出来，保证一个动作要么全部完成，否则不进行任何变动。</li>
</ol>
<h4 id="条款30：透彻了解inlining的里里外外"><a href="#条款30：透彻了解inlining的里里外外" class="headerlink" title="条款30：透彻了解inlining的里里外外"></a>条款30：透彻了解inlining的里里外外</h4><ol>
<li>用<font color=red>inline</font>内嵌函数可以免除函数的调用成本，编译器最优化机制通常被设计来浓缩不含函数调用的代码。然而过多的inline可能导致增加<font color=red>目标码</font>（<font color=green>object coed</font>）大小。在内存有限 的机器上，过度热衷inlining会使程序体积太大，即使拥有虚内存，造成的代码膨胀会导致额外的<font color=red>换页行为</font>（<font color=green>paging</font>），降低指令<font color=red>高速缓存的命中率</font>（<font color=green>instruction cache hit rate</font>），以及伴随这些问题而来的效率损失。</li>
<li>Inline函数通常被置于头文件内，因为多数build environments在编译过程中进行inlining，在链接期完成inlining。inlining在多数C++程序中是编译期行为。</li>
<li>inline是一个向编译器发出的申请，而不是强制命令。大部分编译器拒绝过于复杂（如有循环和递归）的函数inlining。对于virtual函数也会，因为virtual意味着”wait，知道runtime才确定调用哪个函数“。</li>
</ol>
<h4 id="条款31：将文件间的编译依存关系降至最低"><a href="#条款31：将文件间的编译依存关系降至最低" class="headerlink" title="条款31：将文件间的编译依存关系降至最低"></a>条款31：将文件间的编译依存关系降至最低</h4><ol>
<li><code>#include</code>指示符提供的定义式和其含入文件之间形成了一种<font color=red>编译依存关系</font>（<font color=green>compilation dependency</font>）。如果这些头文件中有任何一个被改变，或者这些头文件所依赖的其他头文件有任何改变，那么每个含有class的文件就得重新编译。解决方案是通过<strong>前置声明</strong>配合指针或引用类型声明来减少编译依赖。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ichheit</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ichheit</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
