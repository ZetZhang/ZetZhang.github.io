<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("https://zetzhang.github.io/"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-circle.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content=".27t_lBZ4oZgg_">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content=".27t_lBZ4oZgg_">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ichheit">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>.27t_lBZ4oZgg_</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">.27t_lBZ4oZgg_</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/4-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/" class="post-title-link" itemprop="url">4 设计与声明</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:44:24" itemprop="dateCreated datePublished" datetime="2020-06-14T13:44:24+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE18%EF%BC%9A%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8">条款18：让接口容易被正确使用，不易被误用</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE19%EF%BC%9A%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type">条款19：设计class犹如设计type</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE20%EF%BC%9A%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value">条款20：宁以pass-by-reference-to-const替换pass-by-value</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE21%EF%BC%9A%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference">条款21：必须返回对象时，别妄想返回其reference</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE22%EF%BC%9A%E5%B0%86%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%9C%AAprivate">条款22：将成员变量声明未private</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE23%EF%BC%9A%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0">条款23：宁以non-member、non-friend替换member函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE24%EF%BC%9A%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0">条款24：若所有参数皆需类型转换，请为此采用non-member函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE25%EF%BC%9A%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0">条款25：考虑写出一个不抛出异常的swap函数</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款18：让接口容易被正确使用，不易被误用"><a href="#条款18：让接口容易被正确使用，不易被误用" class="headerlink" title="条款18：让接口容易被正确使用，不易被误用"></a>条款18：让接口容易被正确使用，不易被误用</h4><ol>
<li>除非有好理由，否则应该尽量令你的types的行为与内置types一致。“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除用户的资源管理责任。</li>
<li>std::shared_ptr支持定制型删除其（custom deleter）。这可防范DLL问题（在这个dll创建对象，在另一边dll删除），可被用来自动解除互斥锁等等。</li>
</ol>
<h4 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h4><ol>
<li>C++程序员许多时间主要用来扩张类型系统（type system）。这意味着他不仅是class设计者，还是type设计者。包括<em>重载（overloading）函数和操作符、控制内存的分配和归还、定义对象的初始化和终结</em>……所以应该带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研讨class设计。</li>
<li>设计高效的classes需要考虑：<ol>
<li><strong>新type的对象应该如何被创建和销毁？</strong>（operator new，operator new[]，operator delete和operator delete[]的设计）；</li>
<li><strong>对象的初始化和对象的复制有什么样的差别？</strong>（构造函数和复制（assigment）操作符的行为；</li>
<li><strong>新type的对象如果被passed by value（以值传递），意味着什么？</strong></li>
<li><strong>什么是新type的“合法值“？</strong> class必须维护的约束条件（invariants）（构造函数、赋值操作符和”setter“函数需要的错误检查工作。它影响函数的异常抛出、以及函数异常明细列（exception specifications）。</li>
<li><strong>新type需要配合某个继承图系（inheritance graph）吗？</strong> （必然受到那些classes设计的束缚）</li>
<li><strong>新type需要什么样的转换？</strong> （当需要隐式转换，必须写一个类型转换函数或者写一个non-explicit-one-argument（可被单一实参调用）构造函数）</li>
<li><strong>什么样的操作符和函数对此新type而言是合理的？</strong> </li>
<li><strong>什么样的标准函数应该驳回？</strong> （private）</li>
<li><strong>谁该取用新type的成员？</strong> （public、protected、private、friends）</li>
<li><strong>什么是新type的”未声明接口“（undeclared interface）？</strong> </li>
<li><strong>新type有多么一般化？</strong> 如果是定义一整个types家族，就需要定义一个class template）</li>
<li><strong>真的需要一个新type吗？</strong></li>
</ol>
</li>
</ol>
<h4 id="条款20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：宁以pass-by-reference-to-const替换pass-by-value"></a>条款20：宁以pass-by-reference-to-const替换pass-by-value</h4><ol>
<li>当一个函数以pass by value方式接受对象，它的成本是很高的，很短的声明周期使它调用构造函数和析构函数。以by reference方式传递参数可以避免<font color=red>slicing</font>（对象切割）问题（derived class对于base class来说的特化信息丢失）。</li>
<li>当使用内置类型有机会选择采用pass-by-value或pass-by-reference-to-const时，by value方式可能会效率高些，因为内置类型都相当小。一般可以合理假设”pass-by-value并不昂贵“的唯一对象就是内置类型和STL的迭代器和函数对象。</li>
</ol>
<h4 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h4><ol>
<li>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个eap-allocated对象，或返回pointer或reference指向一个local sattic对象而有可能同时需要多个这样的对象。</li>
</ol>
<h4 id="条款22：将成员变量声明未private"><a href="#条款22：将成员变量声明未private" class="headerlink" title="条款22：将成员变量声明未private"></a>条款22：将成员变量声明未private</h4><ol>
<li>成员变量的封装性与”成员变量的内容改变时所破坏的代码数量“成反比。取消一个public成员变量，所有使用它的客户码都会被破坏，；取消一个protected成员变量，所有使用它的derived classes都会被破坏。从封装的角度来看，其实只有两种访问权限：private（提供封装）和其他（不提供封装）。</li>
<li>将成员变量声明为private。可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li>
<li>protected并不比public更具封装性。</li>
</ol>
<h4 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h4><ol>
<li>如果某些东西被封装，越多东西被封装，就越多的弹性去改变它。</li>
<li>如果在一个member函数和一个non-member，non-friend函数之间做抉择，两者提供相同机能，那么较大封装性的是non-member non-friend函数，因为它不增加访问private成分的函数数量。</li>
<li>标准程序库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中包含std命名空间内的每一样东西，而是有数十个头文件，每个头文件声明std的某些机能。</li>
<li>将所有便利函数放在多个头文件但隶属同一个ing名空间，意味着客户可以轻松扩展这一组便利函数。它需要做的就是添加更多non-member non-friend函数到此命名空间内。</li>
</ol>
<h4 id="条款24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆需类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆需类型转换，请为此采用non-member函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rationalint numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">const</span> Rational oeprator*(<span class="keyword">const</span> Rational &amp;rhs) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当尝试混合式算式，只有一般行的通；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEighth</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEighth;  <span class="comment">// ok</span></span><br><span class="line">result = oneHalf * <span class="number">2</span>;                   <span class="comment">// ok</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;                   <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p><code>oneHalf</code>是一个内含<code>operator *</code>函数的class对象，而整数2并没有相应的class，也就没有<code>operator*</code>成员函数。但为什么第二个参数是2时可被接受？这里发生了<font color=red>隐式类型转换</font>（<font color=green>implicit type conversion</font>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">result = oneHalf * temp;</span><br></pre></td></tr></table></figure>
<p>而实际想要支持混合式算数运算，就让<code>operator*</code>称为一个non-member函数，允许编译器在每一个实参身上执行隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Rational</span>(lhs.<span class="built_in">numberator</span>() * rhs.<span class="built_in">numerator</span>(), lhs.<span class="built_in">denominator</span>() * rhs.<span class="built_in">denominator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此结论：如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是non-member。</p>
<h4 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h4><ol>
<li>一旦要置换两个类对象值，唯一需要做的就是置换其pImpl指针，但default swap算法不知道这点。确切实践思路的一个做法是将std::swap针对该class对象<font color=red>特化</font>（<font color=green>total template specialization</font>）：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.pImpl);   <span class="comment">// 置换指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">temlate&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget &amp;a, Widget &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">swap</span>(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
假设<code>Widget</code>和<code>WidgetImpl</code>都是class templates而非classes，可以尝试将它们的数据类型参数化：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>
在类内放个swap成员函数很简单，却在特化std::swap时遇上乱流：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt; Widget&lt;T&gt; &gt;(Widget&lt;T&gt; &amp;a, Widget&lt;T&gt; &amp;b) </span><br><span class="line">&#123; a.<span class="built_in">swap</span>(b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
看起来合理但不合法，这是企图<font color=red>偏特化</font>（<font color=green>partially specialize</font>）一个function template，但C++只允许对class template偏特化。有时候std的内容是标准委员会决定，如果希望软件有预期行为，最好不加新东西到std里头。为此，还是声明non-member swap让它调用member swap，但不再将non-member swap声明为std::swap特别版本或重载版本。<br>顺带一提，任何地点的任何代码打算置换两个Widget对象，因而调用swap，C++的名称查找法则（name lookup rules，或argument-dependent lookup和koenig lookup法则）会找到专属版本，那正是我们需要的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T &amp;obj1, T &amp;obj2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;    <span class="comment">// 令std::swap在此函数可用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">swap</span>(obj1, obj2);   <span class="comment">// 寻找最佳swap版本woc~</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
查找法则首先寻找global作用域或T所在命名空间内的T专属swap，找不到才使用std内的swap，这得感谢using声明式在函数内曝光。</li>
<li>成员版swap绝不可抛出异常，因为swap的一个最好的应用是帮助clasees或class templates提供异常安全性保障。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">3 资源管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:42:47" itemprop="dateCreated datePublished" datetime="2020-06-14T13:42:47+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE13%EF%BC%9A%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90">条款13：以对象管理资源</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE14%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA%EF%BC%9F%EF%BC%9F%EF%BC%9F">条款14：在资源管理类中小心copying行为？？？</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE15%EF%BC%9A%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE">条款15：在资源管理类中提供对原始资源的访问</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE16%EF%BC%9A%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F">条款16：成对使用new和delete时要采取相同形式</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE17%EF%BC%9A%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86newed%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">条款17：以独立语句将newed对象置入智能指针</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h4><ol>
<li>以对象管理资源的观念常被称为“<font color=red>资源取得时机便是初始化实际</font>”（<font color=green>Resource Acquisition Is Initialization; </font><font color=red>RAII</font>）。在获得的同时立刻被放进管理对象中。<code>auto_ptrs</code>有个不寻常的性质：若通过copy构造函数或copy assignment操作符复制，它们就会变成null，而复制所得的指针将取得资源的唯一拥有权，并在析构函数中释放资源。</li>
<li><code>auto_ptr</code>的替代方案是“<font color=red>引用计数型智能指针</font>”（<font color=green>reference-counting smart pointer；</font><font color=red>RCSP</font>）。它提供的行为类似<font color=red>垃圾回收</font>（<font color=green>garbage collection</font>）。</li>
</ol>
<h4 id="条款14：在资源管理类中小心copying行为？？？"><a href="#条款14：在资源管理类中小心copying行为？？？" class="headerlink" title="条款14：在资源管理类中小心copying行为？？？"></a>条款14：在资源管理类中小心copying行为？？？</h4><ol>
<li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li>
<li>普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法（reference counting）。</li>
</ol>
<h4 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h4><ol>
<li>除非发誓永不录用APIs，否则只得绕过资源管理对象（resource-managing objects）直接访问<font color=red>原始资源</font>（<font color=green>raw resources</font>）。要将RAII class对象转换为其所包含的原始资源。有两个做法：显式转换和隐式转换。前者通过get成员函数可获得指针；后者可行是因为RAII重载了<font color=red>指针取值</font>（<font color=green>pointer dereferencing</font>）操作符（operator-&gt;和operator*），它们允许隐式转化至底部原始指针。</li>
</ol>
<h4 id="条款16：成对使用new和delete时要采取相同形式"><a href="#条款16：成对使用new和delete时要采取相同形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同形式"></a>条款16：成对使用new和delete时要采取相同形式</h4><ol>
<li>当你使用new，有两件事发生。第一，内存被分配出来（operator new）；第二，针对此内存会有一个（或更多）构造函数被调用。当你使用delete，也有两件事发生；针对此内存会有一个（或更多）析构函数被调用，然后内存被释放（operator delete）。</li>
<li>new时使用[]，必须在相应调用delete时也使用[]。对于喜欢对数组形式做typedef动作的人，最好不要这样做，而C++ STL标准库中的容器templates，可将数组需求降至最低。</li>
</ol>
<h4 id="条款17：以独立语句将newed对象置入智能指针"><a href="#条款17：以独立语句将newed对象置入智能指针" class="headerlink" title="条款17：以独立语句将newed对象置入智能指针"></a>条款17：以独立语句将newed对象置入智能指针</h4><p>对于<code>processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), priority());</code>这行代码可以通过编译，然而上述调用可能泄露资源。因为它的执行顺序可能时</p>
<ol>
<li>执行“new Widget”</li>
<li>调用priority删除</li>
<li>调用std::shared_ptr构造函数  </li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;万一对priority的调用导致异常，“new Widget”返回的指针将会丢失，因为尚未置入std::shared_ptr内。解决方法是使用独立语句将创建Widget和置入指针两个步骤分割开来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line"><span class="built_in">processWidget</span>(pw, <span class="built_in">priority</span>());</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/2-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/" class="post-title-link" itemprop="url">2 构造、析构、赋值运算</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:41:30" itemprop="dateCreated datePublished" datetime="2020-06-14T13:41:30+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE05%EF%BC%9A%E4%BA%86%E8%A7%A3c++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0">条款05：了解C++默默编写并调用哪些函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE06%EF%BC%9A%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE07%EF%BC%9A%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">条款07：为多态基类声明virtual析构函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">条款08：别让异常逃离析构函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE09%EF%BC%9A%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0">条款09：绝不在构造和析构过程中调用virtual函数</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE10%EF%BC%9A%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference-to-*this">条款10：令operator=返回一个reference to *this</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE11%EF%BC%9A%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D">条款11：在operator=中处理“自我赋值”</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE12%EF%BC%9A%E8%B5%8B%E5%80%BC%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86">条款12：赋值对象时勿忘其每一个成分</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款05：了解C-默默编写并调用哪些函数"><a href="#条款05：了解C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用哪些函数"></a>条款05：了解C++默默编写并调用哪些函数</h4><ol>
<li>如果自己没声明，编译器会自动声明（编译器版本）的<font color=red>copy构造函数</font>、<font color=red>copy assignment操作符</font>和<font color=red>析构函数</font>。如果没有声明构造函数，编译器也会声明一个<font color=red>default构造函数</font>。</li>
<li>如果某个base classes将copy assignment操作符声明为private，编译器将拒绝为其derived classes生成一个copy assignment操作符。</li>
<li>如果一个类中有reference或pointer类型的数据。那么对于copy assignment操作符需要自己定义，而不是使用编译器生成版本。</li>
</ol>
<h4 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h4><ol>
<li>为了组织copying动作可以设计一个base class并且不予以实现：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Uncopyable</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Uncopyable</span>(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> :</span> <span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// class不再声明copy构造函数或copy assignment操作符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这行得通，甚至是member函数或friend函数——尝试拷贝HomeForSale对象，编译器便试图生成一个copy构造函数和一个copy assignment操作符，生成版会尝试调用base class的对应函数，而调用被拒绝，因为拷贝函数是private。</li>
</ol>
<h4 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h4><ol>
<li>给base class一个virtual析构函数，此后删除derived class对象就会销毁整个对象。如果class不含virtual函数，通常表示意图不被做一个base class。</li>
<li>想实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数该被调用。它由一个<font color=red>vptr</font>（<font color=green>virtual table pointer</font>）指向一个由函数指针构成的数组，称为<font color=red>vtbl</font>（<font color=green>virtual table</font>）；每个带有virtual函数的class都有一个相应的vtbl。当对象调用virtual函数时，编译器在其中寻找适当的函数指针。给base classes一个virtual析构函数这个规则只适用于<font color=green>polymorphic</font>（<font color=red>带多态性质的</font>）base classes身上。</li>
</ol>
<h4 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h4><ol>
<li>对于析构函数中可能抛出的异常，由两种办法可以避免。一是如果抛出异常就结束程序，通常通过在析构函数调用<code>abort</code>抢先制不明确行为于死地；二是吞下它。</li>
<li>如果用户需要对某个操作函数运行期间的异常做出反应，应该提供一个普通函数来操作。然后在结束时析构函数来判断二重保险。</li>
</ol>
<h4 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h4><ol>
<li>由于base class构造函数的执行更早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。如果此期间调用的virtual函数下降至derived classes阶层，那些成员变量尚未初始化，这将产生未定义行为。</li>
<li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class。</li>
</ol>
<h4 id="条款10：令operator-返回一个reference-to-this"><a href="#条款10：令operator-返回一个reference-to-this" class="headerlink" title="条款10：令operator=返回一个reference to *this"></a>条款10：令operator=返回一个reference to *this</h4><h4 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在operator=中处理“自我赋值”</h4><ol>
<li>如果operator=函数内的*this和赋值的来源是同一个对象，潜在的delete操作可能就摧毁了全部对象。因此需要注意在复制之前要么数据最好别删除，要么通过测试是否自我赋值。</li>
<li>在operator=函数内的替换方案最好是使用所谓的copy and swap技术。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款12：赋值对象时勿忘其每一个成分"><a href="#条款12：赋值对象时勿忘其每一个成分" class="headerlink" title="条款12：赋值对象时勿忘其每一个成分"></a>条款12：赋值对象时勿忘其每一个成分</h4><ol>
<li>当你编写一个copying函数，要确保复制所有local成员变量，且调用所有base calsses内的适当的copying函数。</li>
<li>对于为了消除复制代码的重复性，不该用copy assignment操作符调用copy构造函数，反之亦然。消除重复代码的做法是，建立一个新的成员函数给两者调用。这样的函数往往是private而且被命名为init。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/14/1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFC/" class="post-title-link" itemprop="url">1 让自己习惯C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-14 13:38:36" itemprop="dateCreated datePublished" datetime="2020-06-14T13:38:36+08:00">2020-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-01/" itemprop="url" rel="index"><span itemprop="name">2019.01</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E6%9D%A1%E6%AC%BE01%EF%BC%9A%E8%A7%86c++%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6">条款01：视C++为一个语言联邦</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE02%EF%BC%9A%E5%B0%BD%E9%87%8F%E4%BB%A5const%EF%BC%8Cenum%EF%BC%8Cinline%E6%9B%BF%E6%8D%A2#define">条款02：尽量以const，enum，inline替换#define</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE03%EF%BC%9A%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const">条款03：尽可能使用const</a></li>
<li><a href="#%E6%9D%A1%E6%AC%BE04%EF%BC%9A%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96">条款04：确定对象被使用前已先被初始化</a></li>
</ul>
<!-- vim-markdown-toc -->
<h4 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h4><ol>
<li>C++是一个<font color=red>多重范式编程语言</font>（<font color=green>multiparadigm programming language</font>），它是一个支持<font color= red>过程形式</font>（<font color=green>procedural</font>）、<font color=red>面向对象形式</font>（<font color=green>object-oriented</font>）、<font color= red>函数形式</font>（<font color=green>functional</font>）、<font color=red>泛型形式</font>（<font color=green>generic</font>）、<font color=red>元编程形式</font>（<font color=green>metaprogramming</font>）的语言。</li>
<li>为了理解C++可以从四个方面入手：<ul>
<li>C。区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型（built-in data types）、数组（arrays）、指针（pointers）。</li>
<li>Object-Oriented C++。classes（构造函数和析构函数），封装（encapsulation）、继承（inheritance）、多态（polymorphism）、virtual函数（动态绑定）。</li>
<li>Template C++。</li>
<li>STL。容器（containers）、迭代器（iterators）、算法（algorithms）以及函数对象（function objects）。</li>
</ul>
</li>
</ol>
<h4 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h4><ol>
<li><code>#define</code>记号也许在编译器开始处理源码前就被预处理器移走了。于是可能记号没有进入<font color=red>记号表</font>（<font color=green>symbol table</font>）内。</li>
<li>当我们以常量替换<code>#define</code>，如果要在头文件内定义一个常量<code>char*</code>-based字符串，必须写const两次（顶层const和底层const）：<code>const char* const authorName = &quot;Scott Meyers&quot;;</code>但通常用string对象更合宜；如果是class专属常量，为了确保常量至多只有一份，必须称为一个static成员。  </li>
<li>如果不想别人获得一个pointer或reference指向整数常量，enum可以帮助实现这个约束。</li>
<li>用<code>template&lt;typename T&gt;inline void callWithMax(cons T &amp;a, const T &amp;b);</code>来代替<code>#define</code>定义的仿函数，这种<font color=red>template inline函数</font>不仅获得宏带来的效率还有一般函数的所有可预料行为和类型安全性（type safety）。</li>
</ol>
<h4 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h4><ol>
<li>const多才多艺，可以在classes外部修饰global或namespace中的常量，或修饰文件、函数、或区块作用域（block scope）中被声明为static的对象。也可以修饰calsses内部的static和non-static成员变量。面对指针，可以指出指针自身、指针所指物，或两者都不是。</li>
<li>STL迭代器系是以指针塑膜出来，作用跟T*指针一样。声明迭代器为const表示迭代器不指向不同的东西（T *const指针）。但是希望迭代器所指的东西不可改动（模拟const T*指针），需要的是<font color=red><code>const_iterator</code></font>。</li>
<li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// operator[] for const 对象</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span>  </span><br><span class="line">    &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line">    <span class="comment">// operator[] for non-const对象</span></span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position)  </span><br><span class="line">    &#123; <span class="keyword">return</span> text[position]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TextBlock的operator[]可这么使用：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用non-const TextBlock::operator[]</span></span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// 调用const TextBlock::operator[]</span></span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：non-const operator[]的返回类型是reference to cahr，不是char。因为如果返回类型是个内置类型，那么改动返回值就不合法，即使合法，C++以by value返回对象意味着返回值是副本，而不是本身。</li>
<li><font color=red><code>mutable</code>成员变量</font>总是会被更改，即使在const成员函数内。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将op[]返回值的const转除；为*this加上const；调用const op[]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)</span><br><span class="line">                [position]</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h4><ol>
<li>永远在使用对象之前将它初始化。对于无任何成员的内置类型，必须手工完成，因为C++不保证初始化它们。</li>
<li>构造函数最好使用<font color=red>成员初值列</font>（<font color=green>member initialization list</font>）</li>
<li><font color=red>non-local static</font>对象被<font color=red>local static</font>对象替换。以“函数调用”替换“直接访问non-local static对象“。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSYstem</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span> ... &#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>(params)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::<span class="keyword">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisks</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">tempDir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Directory td;</span><br><span class="line">    <span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些<font color=red>reference-returning</font>函数往往十分单纯，这些函数”内涵static对象“的事实使它们在多线程系统中带有不确定性。此时的做法是：在程序的单线程启动阶段（single-threaded startup portion）手工调用所有reference-returning函数，可消除与初始化有关的”&lt;/font color=red&gt;竞速形势</font>（race conditions）“。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/13/%E4%B8%80%E4%BA%9B%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/%E4%B8%80%E4%BA%9B%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">一些调试工具命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-13 00:09:41" itemprop="dateCreated datePublished" datetime="2020-06-13T00:09:41+08:00">2020-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2020-04/" itemprop="url" rel="index"><span itemprop="name">2020.04</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><blockquote>
<ul>
<li>三剑客<a href="#grep">grep</a>、<a href="#sed">sed</a>、<a href="#awk">awk</a>的使用</li>
<li>网络分析工具<a href="#tcpdump">tcpdump</a>的使用</li>
<li>内存分析：<a href="#valgrind">valgrind</a></li>
<li>其他：netstat、lsof、nc、tcpcopy、prerf、sysctl、<a href="#strace">strace</a>、prove等</li>
<li>性能检测工具：<a href="#perf">perf</a>、ftrace、vmstat</li>
</ul>
</blockquote>
<hr>
<h3 id="Linux三剑客"><a href="#Linux三剑客" class="headerlink" title="Linux三剑客"></a>Linux三剑客</h3><hr>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a><span id = "grep">grep</span></h4><h5 id="用法：grep-OPTION-PATTERN-FILE"><a href="#用法：grep-OPTION-PATTERN-FILE" class="headerlink" title="用法：grep [OPTION...] PATTERN [FILE...]"></a>用法：<code>grep [OPTION...] PATTERN [FILE...]</code></h5><h5 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h5><ul>
<li>-b：每一行打印字符偏移量</li>
<li>-c：统计符合要求的行数</li>
<li>-E：使用egrep</li>
<li>-f：从文件中取匹配模板</li>
<li>-F：不使用正则快速搜索</li>
<li>-h：不显示文件名</li>
<li>-H：显式</li>
<li>-i：忽略大小写</li>
<li>-l：仅列出符合要求的文件，不列出具体行</li>
<li>-L：与-l相反</li>
<li>-n：显示符合要求的行及行号</li>
<li>-p：silence模式</li>
<li>-v：取反</li>
<li>-r：遍历子目录</li>
<li>-s：no-message</li>
<li>-w：匹配完整的词</li>
<li>-x：匹配完整的行</li>
<li>-An：</li>
<li>-Bn：</li>
<li>-Cn：</li>
<li>正则规则：<ul>
<li><code>[]</code>：表示集合中的内容，如<code>[abc]</code>匹配<code>a</code>或<code>b</code>或<code>c</code>。<ul>
<li><code>[^]</code>：取反</li>
<li><code>[a-z]</code>：小写字母</li>
<li><code>[A-Z]</code>：大写字母</li>
<li><code>[0-9]</code>：数字</li>
</ul>
</li>
<li><code>^</code>和<code>$</code>：表示行首和行位，<code>^$</code>表示空行</li>
<li><code>*</code>：通配符，表示多个重复</li>
<li><code>.</code>：单个。<code>.*</code>表示0个或多个</li>
<li><code>&#123;n, m&#125;</code>：个数范围，n个到m个之间，需要用<code>/</code>转义，egrep下不需要转义</li>
<li><code>egrep</code>：<ul>
<li><code>+</code>：类似<code>.</code>，1个或多个</li>
<li><code>?</code>：表示0个或多个</li>
<li><code>|</code>：表示关系，如<code>&#39;ab|cd|def&#39;</code>表示<code>ab</code>、<code>cd</code>或<code>def</code>的串</li>
<li><code>()</code>：将部分内容合成单元</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a><span id = "sed">sed</span></h4><h5 id="用法：sed-OPTION-SCRIPTorCOMMAND-FILE"><a href="#用法：sed-OPTION-SCRIPTorCOMMAND-FILE" class="headerlink" title="用法：sed [OPTION]... [SCRIPTorCOMMAND] [FILE]..."></a>用法：<code>sed [OPTION]... [SCRIPTorCOMMAND] [FILE]...</code></h5><h5 id="选项：-1"><a href="#选项：-1" class="headerlink" title="选项："></a>选项：</h5><ul>
<li>-e：执行多条命令</li>
<li>-f：引导sed脚本</li>
<li>-i：直接修改文件</li>
<li>-n：silent，搭配s替换p可以打印修改过的行</li>
<li>-h：帮助</li>
<li>-V：版本信息</li>
<li>action:<ul>
<li><code>a</code>：后插，<code>sed &#39;/text/a\newline&#39;</code> OR <code>sed &#39;/text/a newline&#39;</code></li>
<li><code>c</code>：取代，<code>sed &#39;3,4c\replaceline&#39;</code></li>
<li><code>d</code>：删除，<code>sed &#39;2,4d&#39;</code> OR <code>sed &#39;/text/&#39;d</code></li>
<li><code>g</code>：获取缓冲区内容替换文本</li>
<li><code>G</code>：获取缓冲区内容追加文本</li>
<li><code>h</code>：拷贝文本到缓冲区</li>
<li><code>H</code>：追加文本到缓冲区，保持和获取：<code>sed -e &#39;/text/h&#39; -e &#39;$G&#39; file</code></li>
<li><code>i</code>：前插，<code>sed &#39;/text/i\newthing&#39;</code></li>
<li><code>l</code>：列表不打印字符清单</li>
<li><code>n</code>：读取下一个命令，用新命令处理新行</li>
<li><code>p</code>：打印，<code>sed &#39;1p;3,4p&#39;</code></li>
<li><code>q</code>：打印到第n行退出</li>
<li><code>r</code>：从file读内容，<code>sed &#39;/text/r file&#39;</code></li>
<li><code>s</code>：取代（正则）<ul>
<li><code>^</code>、<code>$</code>、<code>.</code>、<code>*</code>、<code>[]</code>、<code>[^]</code></li>
<li><code>(..)</code>：匹配子串，保存字符如<code>s/(love)able/\1rs</code>：<code>loveable</code> -&gt; <code>lovers</code></li>
<li><code>&amp;</code>：拼接，<code>s/love/sb&amp;</code> -&gt; <code>love</code> -&gt; <code>sblove</code></li>
<li><code>&lt;</code>：匹配单词开始，如<code>/&lt;love/</code>表示love开头的单词的行</li>
<li><code>&gt;</code>：匹配单词结束，如<code>/love&gt;/</code></li>
<li><code>x&#123;m&#125;</code>：重复x有m次，<code>/0&#123;5&#125;</code></li>
<li><code>x&#123;m,&#125;</code>：重复x至少m次</li>
<li><code>x&#123;m, n&#125;</code>：重复x至少m到n次</li>
</ul>
</li>
<li><code>t</code>：if分支</li>
<li><code>g</code>：全面替换</li>
<li><code>w</code>：把行写入file，<code>sed &#39;/text/w file&#39;</code></li>
<li><code>x</code>：</li>
<li><code>y</code>：把字符翻译为另外的字符，不做正则</li>
<li><code>!</code>：后续命令作用于没有选中的行</li>
<li><code>#</code>：注释扩展到下个换行符前</li>
</ul>
</li>
</ul>
<hr>
<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a><span id = "awk">awk</span></h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8c6a0d0d4f0d">awk简明教程</a></p>
<h5 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h5><h5 id="awk-F-SEPSTRING-v-ASSIGNMENT-program-ARGUMENT"><a href="#awk-F-SEPSTRING-v-ASSIGNMENT-program-ARGUMENT" class="headerlink" title="awk [-F SEPSTRING] [-v ASSIGNMENT]... program [ARGUMENT...]"></a><code>awk [-F SEPSTRING] [-v ASSIGNMENT]... program [ARGUMENT...]</code></h5><h5 id="awk-F-SEPSTRING-f-PROFILE-f-v-ASSIGNMENT-ARGUMENT"><a href="#awk-F-SEPSTRING-f-PROFILE-f-v-ASSIGNMENT-ARGUMENT" class="headerlink" title="awk [-F SEPSTRING] -f PROFILE [-f]... [-v ASSIGNMENT]... [ARGUMENT...]"></a><code>awk [-F SEPSTRING] -f PROFILE [-f]... [-v ASSIGNMENT]... [ARGUMENT...]</code></h5><h5 id="选项：-2"><a href="#选项：-2" class="headerlink" title="选项："></a>选项：</h5><ul>
<li>-F fs：指定文件分隔符，fs是字符串或正则，如<code>-F:</code></li>
<li>-v var=value：定义变量</li>
<li>-f scripfile：从脚本中读取awk</li>
<li>-W：<ul>
<li><code>compact</code> or <code>traditional</code>：兼容模式运行awk，gawk将同awk，忽略扩展</li>
<li><code>copyleft</code> or <code>copyright</code>：版权信息</li>
<li><code>help</code> or <code>usage</code>：选项简短说明</li>
<li><code>lint</code> or <code>lint-old</code>：向传统unix移植结构警告</li>
<li><code>posix</code>：兼容模式不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符<strong>和</strong>=不能代替^和^=；fflush无效</li>
<li><code>re-interval</code>：允许间隔正则使用，POSIX字符类，括号表达式[[:alpha:]]</li>
<li><code>source PROG</code>：使用PROG作为源码，可搭配<code>-f</code><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$n</td>
<td align="left">记录的第n个字段，由FS分隔</td>
</tr>
<tr>
<td align="left">$0</td>
<td align="left">完整的输入记录</td>
</tr>
<tr>
<td align="left">ARGC</td>
<td align="left">命令行参数数量</td>
</tr>
<tr>
<td align="left">ARGIND</td>
<td align="left">命令行中当前文件位置</td>
</tr>
<tr>
<td align="left">ARGV</td>
<td align="left">命令行参数数组</td>
</tr>
<tr>
<td align="left">CONVFMT</td>
<td align="left">数字转换格式（%.6g）</td>
</tr>
<tr>
<td align="left">ENVIRON</td>
<td align="left">环境变量关联数组</td>
</tr>
<tr>
<td align="left">ERRNO</td>
<td align="left">系统错误</td>
</tr>
<tr>
<td align="left">FIELDWIDTHS</td>
<td align="left">字段宽度列表</td>
</tr>
<tr>
<td align="left">FILENAME</td>
<td align="left">当前文件名</td>
</tr>
<tr>
<td align="left">ENR</td>
<td align="left">同NR</td>
</tr>
<tr>
<td align="left">FS</td>
<td align="left">字段分隔符</td>
</tr>
<tr>
<td align="left">IGNORECASE</td>
<td align="left">为真则忽略大小写匹配</td>
</tr>
<tr>
<td align="left">NF</td>
<td align="left">记录中的字段数</td>
</tr>
<tr>
<td align="left">OFMT</td>
<td align="left">数字输出格式</td>
</tr>
<tr>
<td align="left">OFS</td>
<td align="left">输出字段分隔符（默认空格）</td>
</tr>
<tr>
<td align="left">ORS</td>
<td align="left">输出记录分隔符（默认换行）</td>
</tr>
<tr>
<td align="left">RLENGTH</td>
<td align="left">match函数匹配的字符串长度</td>
</tr>
<tr>
<td align="left">RS</td>
<td align="left">记录分隔符（默认换行）</td>
</tr>
<tr>
<td align="left">RSTART</td>
<td align="left">match函数匹配的第一个位置</td>
</tr>
<tr>
<td align="left">SUBSEP</td>
<td align="left">数组下标分隔符（默认\034）</td>
</tr>
</tbody></table>
<h5 id="通用正则表达式元字符"><a href="#通用正则表达式元字符" class="headerlink" title="通用正则表达式元字符"></a>通用正则表达式元字符</h5><table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\Y</td>
<td align="left">匹配单词开头或末尾的空字符串</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">匹配单词内空字符串</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">匹配单词开头</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">匹配单词末尾</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母数字组成的单词</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">匹配非字母数字组成的单词</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">字符串开头空字符串</td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left">字符换末尾空字符串</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a><span id = "tcpdump">tcpdump</span></h4><h3 id="其他一些工具"><a href="#其他一些工具" class="headerlink" title="其他一些工具"></a>其他一些工具</h3><h4 id="strace"><a href="#strace" class="headerlink" title="strace"></a><span id = "strace">strace</span></h4><h3 id="perf性能分析工具"><a href="#perf性能分析工具" class="headerlink" title="perf性能分析工具"></a><span id = "perf">perf</span>性能分析工具</h3><h4 id="调试关注点"><a href="#调试关注点" class="headerlink" title="调试关注点"></a>调试关注点</h4><ul>
<li>基于性能分析：可以<strong>算法优化</strong>、<strong>代码优化</strong></li>
<li>硬件资源使用：如cache访问次数、cache丢失次数、流水线停顿周期、前端总线访问次数等</li>
<li>操作系统资源：如系统调用次数、上下文切换次数、任务迁移次数</li>
<li>事件以下几种：<ul>
<li>Hardware Event：由PMU部件产生，特定条件下探测性能事件是否发生以及发生次数，如cache命中</li>
<li>Software Event：由内核产生的事件，分布各个功能模块，统计与操作系统相关的事件，如进程切换，tick数等</li>
<li>Tracepoint Event：由内核中静态tracepoint所触发的事件，tracepoint用来判断程序运行期间内核的行为细节，如slab分配器分配次数等</li>
<li>Tool Event：duration_time<h4 id="用法：perf-version-help-OPTIONS-COMMAND-ARGS"><a href="#用法：perf-version-help-OPTIONS-COMMAND-ARGS" class="headerlink" title="用法：perf [--version] [--help] [OPTIONS] COMMAND [ARGS]"></a>用法：<code>perf [--version] [--help] [OPTIONS] COMMAND [ARGS]</code></h4></li>
</ul>
</li>
<li>The most commonly used perf commands are:<ul>
<li><code>annotate</code>        Read perf.data (created by perf record) and display annotated code</li>
<li><code>archive</code>         Create archive with object files with build-ids found in perf.data file</li>
<li><code>bench</code>           General framework for benchmark suites</li>
<li><code>buildid-cache</code>   Manage build-id cache.</li>
<li><code>buildid-list</code>    List the buildids in a perf.data file</li>
<li><code>c2c</code>             Shared Data C2C/HITM Analyzer.</li>
<li><code>config</code>          Get and set variables in a configuration file.</li>
<li><code>data</code>            Data file related processing</li>
<li><code>diff</code>            Read perf.data files and display the differential profile</li>
<li><code>evlist</code>          List the event names in a perf.data file</li>
<li><code>ftrace</code>          simple wrapper for kernel’s ftrace functionality</li>
<li><code>inject</code>          Filter to augment the events stream with additional information</li>
<li><code>kallsyms</code>        Searches running kernel for symbols</li>
<li><code>kmem</code>            Tool to trace/measure kernel memory properties</li>
<li><code>kvm</code>             Tool to trace/measure kvm guest os</li>
<li><code>list</code>            List all symbolic event types</li>
<li><code>lock</code>            Analyze lock events</li>
<li><code>mem</code>             Profile memory accesses</li>
<li><code>record</code>          Run a command and record its profile into perf.data</li>
<li><code>report</code>          Read perf.data (created by perf record) and display the profile</li>
<li><code>sched</code>           Tool to trace/measure scheduler properties (latencies)</li>
<li><code>script</code>          Read perf.data (created by perf record) and display trace output</li>
<li><code>stat</code>            Run a command and gather performance counter statistics</li>
<li><code>test</code>            Runs sanity tests.</li>
<li><code>timechart</code>       Tool to visualize total system behavior during a workload</li>
<li><code>top</code>             System profiling tool.</li>
<li><code>version</code>         display the version of perf binary</li>
<li><code>probe</code>           Define new dynamic tracepoints</li>
<li><code>trace</code>           strace inspired tool<h4 id="功能分类"><a href="#功能分类" class="headerlink" title="功能分类"></a>功能分类</h4><h5 id="全局性概况"><a href="#全局性概况" class="headerlink" title="全局性概况"></a>全局性概况</h5></li>
</ul>
</li>
<li><code>list</code>：查看系统支持的性能事件</li>
<li><code>bench</code>：对系统性能摸底</li>
<li><code>test</code>：对系统健全性测试</li>
<li><code>stat</code>：对全局性能进行统计<h5 id="全局细节"><a href="#全局细节" class="headerlink" title="全局细节"></a>全局细节</h5></li>
<li><code>top</code>：实时查看系统进程函数占用率情况</li>
<li><code>probe</code>：自定义动态事件<h5 id="特定功能分析"><a href="#特定功能分析" class="headerlink" title="特定功能分析"></a>特定功能分析</h5></li>
<li><code>kmem</code>：支队slab子系统性能分析</li>
<li><code>kvm</code>：针对kvm虚拟化分析</li>
<li><code>lock</code>：分析锁性能</li>
<li><code>mem</code>：分析内核调度器性能</li>
<li><code>trace</code>：记录系统调用轨迹<h5 id="记录与分析"><a href="#记录与分析" class="headerlink" title="记录与分析"></a>记录与分析</h5></li>
<li><code>record</code>：记录信息到perf.data<br>(FrameGraph)[<a target="_blank" rel="noopener" href="https://gitee.com/mirrors/FlameGraph.git]">https://gitee.com/mirrors/FlameGraph.git]</a><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用perf录制数据并使用FrameGraph查看火焰图</span></span><br><span class="line"><span class="comment"># 录制程序十秒</span></span><br><span class="line">$ perf record -F 99 -a -g -- sleep 10</span><br><span class="line"><span class="comment"># 数据展开</span></span><br><span class="line">$ perf script | ../stackcollapse-perf.pl &gt; out.perf-folded</span><br><span class="line"><span class="comment"># 生成svg矢量图</span></span><br><span class="line">$ ../flamegraph.pl out.perf-folded &gt; perf-kernel.svg</span><br></pre></td></tr></table></figure></li>
<li><code>report</code>：生成报告</li>
<li><code>diff</code>：对两个记录进行diff</li>
<li><code>evlist</code>：列出记录的性能事件</li>
<li><code>annotate</code>：显式perf.data函数代码</li>
<li><code>archive</code>：将相关符号打包，方便其他机器进行分析</li>
<li><code>script</code>：将perf.data输出可读性文本<h5 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h5></li>
<li><code>timechart record</code>：记录事件</li>
<li><code>timechart</code>：生成output.svg文档</li>
</ul>
<h4 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看程序的pid、ppid、pgid、sid、comm信息</span></span><br><span class="line">$ ps -C program o pid,ppid,pgid,sid,comm</span><br><span class="line"><span class="comment"># 查看进程层次关系</span></span><br><span class="line">$ ps -ejH</span><br><span class="line">$ ps axjf</span><br></pre></td></tr></table></figure>

<h3 id="valgrind"><a href="#valgrind" class="headerlink" title="valgrind"></a><span id = "grep">valgrind</span></h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.valgrind.org/docs/manual/manual-core.html#manual-core.report">使用手册</a></p>
</blockquote>
<h4 id="用法：valgrind-VALGRIND-OPTIONS-programing-PROG-OPTIONS"><a href="#用法：valgrind-VALGRIND-OPTIONS-programing-PROG-OPTIONS" class="headerlink" title="用法：valgrind [VALGRIND_OPTIONS] programing [PROG_OPTIONS]"></a>用法：valgrind [VALGRIND_OPTIONS] programing [PROG_OPTIONS]</h4><h5 id="基本选项"><a href="#基本选项" class="headerlink" title="基本选项"></a>基本选项</h5><ul>
<li><p><code>-h</code>：帮助</p>
</li>
<li><p><code>-q</code>：静默模式</p>
</li>
<li><p><code>-v</code>：输出额外的信息，如加载的共享对象，检测和执行引擎进度，和异常行为警告，重复选项会增加详细程序</p>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><h5 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h5></li>
<li><p>使用<code>-g</code>有助于获得直接指向源代码行的消息</p>
</li>
<li><p>如果使用C++，使用<code>-fno-inline</code>可以轻松看到函数调用链，或者使用valgrind选项<code>--read-inline-info=yes</code>让valgrind读取内联信息</p>
</li>
<li><p>开启<code>-O1</code>以上程序优化会导致memcheck误报未定义等错误，尽量不优化，且开启<code>-Wall</code></p>
<h5 id="注释输出"><a href="#注释输出" class="headerlink" title="注释输出"></a>注释输出</h5></li>
<li><p>默认valgrind将消息输出文件描述符2（stderr），如果要写入其他文件描述符，可以使用<code>--log-fd=&lt;n&gt;</code>来指定fd减少干扰项</p>
</li>
<li><p>为了减少干扰项，最好通过<code>-log-file=&lt;filename&gt;</code>将调试日志写到指定文件</p>
</li>
<li><p>最少干扰是通过<code>--log-socket=&lt;ip:port&gt;</code>指定网络套接字进行输出，可以省略端口号，将默认使用端口1500，默认值由<code>VG_CLO_DEFAULT_LOGPORT</code>定义。而valgrind监听端则使用<code>valgrind-listener</code>来进行监听，连接的切断listener并不会杀死valgrind，而是会自动切换回写入stderr</p>
<ul>
<li><code>valgrind-listener</code>接受多大50个valgrinded进程同时连接，它接收三个选项：<ul>
<li><code>-e --exit-at-zero</code>：当连接进程数为0时退出，否则将永远运行</li>
<li><code>--max-connect=&lt;n&gt;</code>：进程上限，默认50，可以自动设限</li>
<li><code>portnumber</code>：更改默认端口（1500）</li>
</ul>
</li>
</ul>
</li>
<li><p>检测重复错误会有大量开销，valgrind会在发现1000个不同的错误或总共发现10000000个错误后停止错误收集，为了避免中断，可以使用<code>--error-limit=no</code>选项</p>
</li>
<li><p>错误检查工具会检测系统中预装系统库的很多问题，如果不想看到这些错误，可以使用<code>--gen-suppressions=yes</code>选项进行消除。如果使用了<code>-v</code>选项，则在程序结束时打印已使用抑制行</p>
</li>
<li><p><code>--tool=&lt;toolname&gt;</code>：可以决定运行哪个valgrind工具。默认为<code>memcheck</code>，除此之外还有<code>cachegrind</code>、<code>callgrind</code>、<code>helgrind</code>、<code>drd</code>、<code>massif</code>、<code>dhat</code>、<code>bouchey</code>、<code>none</code>、<code>exp-sgcheck</code>、<code>exp-bbv</code>等</p>
</li>
</ul>
<h4 id="一些技巧记录"><a href="#一些技巧记录" class="headerlink" title="一些技巧记录"></a>一些技巧记录</h4><ul>
<li>显式本地IP：<code>curl myip.ipip.net</code></li>
<li>查找结构体：<code>grep -Rn --include=&quot;*.h&quot; --include=&quot;*.c&quot; &#39;struct ether_header&#39; /usr</code></li>
<li>查找宏定义：<code>grep -Rn --include=&quot;*.h&quot; --include=&quot;*.c&quot; &#39;#define PCAP_ERRBUF_SIZE&#39; /usr</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B0%96%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B0%96%E7%AB%AF/" class="post-title-link" itemprop="url">第七章 站在对象模型的尖端</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-12 23:03:38" itemprop="dateCreated datePublished" datetime="2020-06-12T23:03:38+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-06/" itemprop="url" rel="index"><span itemprop="name">2019.06</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#7.1-template">7.1 Template</a><ul>
<li><a href="#template%E7%9A%84%E2%80%9C%E5%AE%9E%E4%BE%8B%E5%8C%96%E2%80%9D%E8%A1%8C%E4%B8%BA%EF%BC%88template-instantiation%EF%BC%89">Template的“实例化”行为（Template Instantiation）</a></li>
<li><a href="#template%E7%9A%84%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%EF%BC%88error-reporting-within-a-template%EF%BC%89">Template的错误报告（Error Reporting within a Template）</a></li>
<li><a href="#template%E4%B8%AD%E7%9A%84%E5%90%8D%E7%A7%B0%E5%86%B3%E8%AE%AE%E6%B3%95%EF%BC%88name-resolution-within-a-template%EF%BC%89">Template中的名称决议法（Name Resolution within a Template）</a></li>
<li><a href="#member-function%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%A1%8C%E4%B8%BA%EF%BC%88member-function-instantiation%EF%BC%89">Member Function的实例化行为（Member Function Instantiation）</a></li>
</ul>
</li>
<li><a href="#7.2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88exception-handing%EF%BC%89">7.2 异常处理（Exception Handing）</a><ul>
<li><a href="#exception-handing%E5%BF%AB%E9%80%9F%E6%A3%80%E9%98%85">Exception Handing快速检阅</a></li>
<li><a href="#%E5%AF%B9exception-handing%E7%9A%84%E6%94%AF%E6%8C%81">对Exception Handing的支持</a></li>
<li><a href="#%E5%86%B3%E5%AE%9Athrow%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E5%9C%A8%E4%B8%80%E4%B8%AAtry%E5%8C%BA%E6%AE%B5%E4%B8%AD">决定throw是否发生在一个try区段中</a></li>
<li><a href="#%E5%B0%86exception%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%AF%8F%E4%B8%80%E4%B8%AAcatch%E5%AD%90%E5%8F%A5%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%81%9A%E6%AF%94%E8%BE%83">将exception的类型和每一个catch子句的类型做比较</a></li>
<li><a href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%99%85%E5%AF%B9%E8%B1%A1%E5%9C%A8%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E8%A2%AB%E6%8A%9B%E5%87%BA%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E4%BA%8B%EF%BC%9F">当一个实际对象在程序执行时被抛出，会发生什么事？</a></li>
</ul>
</li>
<li><a href="#7.3-%E6%89%A7%E8%A1%8C%E6%9C%9F%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%EF%BC%88runtime-type-identification%EF%BC%8Crtti%EF%BC%89">7.3 执行期类型识别（Runtime Type Identification，RTTI）</a><ul>
<li><a href="#type-safe-downcast%EF%BC%88%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%EF%BC%89">Type-Safe Downcast（保证安全的向下转换操作）</a></li>
<li><a href="#type-safe-dynamic-cast%EF%BC%88%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%E5%8A%A8%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%89">Type-Safe Dynamic Cast（保证安全的动态转换）</a></li>
<li><a href="#reference%E5%B9%B6%E4%B8%8D%E6%98%AFpointers">Reference并不是Pointers</a></li>
<li><a href="#typeid%E8%BF%90%E7%AE%97%E7%AC%A6">Typeid运算符</a></li>
</ul>
</li>
<li><a href="#7.4-%E6%95%88%E7%8E%87%E6%9C%89%E4%BA%86%EF%BC%8C%E5%BC%B9%E6%80%A7%E5%91%A2%EF%BC%9F">7.4 效率有了，弹性呢？</a><ul>
<li><a href="#%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB%E5%87%BD%E6%95%B0%E5%BA%93%EF%BC%88dynamic-shared-libraries%EF%BC%89">动态共享函数库（Dynamic Shared Libraries）</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%EF%BC%88shared-memory%EF%BC%89">共享内存（Shared Memory）</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<ul>
<li>有三个著名的C++语言扩充性质，它们都会影响C++对象。分别是<font color=red>template</font>、<font color=red>exception handing（<strong>EH</strong>）</font>和<font color=red>runtime type identification（<strong>RTTI</strong>）</font>（RTTI可以想象成EH的一个副作用）。</li>
</ul>
<h4 id="7-1-Template"><a href="#7-1-Template" class="headerlink" title="7.1 Template"></a>7.1 Template</h4><ul>
<li>template原本被视为是对container classes的支持，但现在成为STL的基础。它也被用于<strong>属性混合</strong>（如内存分配机制）或<strong>互斥（mutual exclusion）机制</strong>（使用于线程同步化控制）。它设置被用于<strong>template metaprograms</strong>技术：class expression templates将在编译时期而非执行期被评估（evaluated），因而带来效率提升。</li>
</ul>
<h5 id="Template的“实例化”行为（Template-Instantiation）"><a href="#Template的“实例化”行为（Template-Instantiation）" class="headerlink" title="Template的“实例化”行为（Template Instantiation）"></a>Template的“实例化”行为（Template Instantiation）</h5><ul>
<li>下面的template Point class：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Status</span> &#123;</span> unallocated, normalized &#125;;</span><br><span class="line">    <span class="built_in">Point</span>(Type x = <span class="number">0.0</span>, Type y = <span class="number">0.0</span>, Type z = <span class="number">0.0</span>);</span><br><span class="line">    ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Piont&lt;Type&gt; *freeList;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> chunkSize;</span><br><span class="line">    Type _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  实际程序中，static data members并不可用，nested enum或enumerators也一样。它们每个<font color=red>只能通过template Point class的某个实例来存取或操作</font>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line">Point&lt;<span class="keyword">float</span>&gt;::Status s;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line">Point::Status s;</span><br></pre></td></tr></table></figure>
  如果定义一个指针，指向特定实例：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point&lt;<span class="keyword">float</span>&gt; *ptr = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
  什么也没发生。<strong>因为指向class object的指针，本身并不是class object，编译器不需要直到与该class有关的任何members数据或object布局数据</strong>。如果不是pointer而是reference，又如何：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Point&lt;<span class="keyword">float</span>&gt; &amp;ref = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 内部扩展</span></span><br><span class="line"><span class="function">Point&lt;<span class="keyword">float</span>&gt; <span class="title">temporary</span><span class="params">(<span class="keyword">float</span>(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="keyword">const</span> Point&lt;<span class="keyword">float</span>&gt; &amp;ref = temporary;</span><br></pre></td></tr></table></figure>
  所以一个class object的定义，不论是由编译器暗中地做或是程序员显式地做，都会导致template class的实例化。也就是Point中的三个nonstatic members都会被绑定。然而member functions（未被使用过的）不应该被实例化。只有在需要时才实例化。但编译器不遵循这项要求，所以由使用者来主导<font color=red>实例化</font>（<font color=green>instantiation</font>），主要有两个原因：<ol>
<li><strong>空间和时间效率的考虑</strong>。</li>
<li><strong>尚未实现的机能</strong>。</li>
</ol>
</li>
</ul>
<h5 id="Template的错误报告（Error-Reporting-within-a-Template）"><a href="#Template的错误报告（Error-Reporting-within-a-Template）" class="headerlink" title="Template的错误报告（Error Reporting within a Template）"></a>Template的错误报告（Error Reporting within a Template）</h5><h5 id="Template中的名称决议法（Name-Resolution-within-a-Template）"><a href="#Template中的名称决议法（Name-Resolution-within-a-Template）" class="headerlink" title="Template中的名称决议法（Name Resolution within a Template）"></a>Template中的名称决议法（Name Resolution within a Template）</h5><ul>
<li>template的两种意义：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope of the template definition</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopeRules</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invariant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        _member = <span class="built_in">foo</span>(_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">type <span class="title">type_dependent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">foo</span>(_member);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _val;</span><br><span class="line">    type _member;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// scope of the template declareation</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">foo</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="comment">// scope of the template instantiation</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">ScopeFules&lt;<span class="keyword">int</span>&gt; sr0;</span><br></pre></td></tr></table></figure>
  <strong>Template中，一个nonmember name的决议结果，是根据name的使用是否与实例化该template的参数类型有关而决定的。如果无关，就以scope of the template declareation决定name，否则以scope of the template instantiation决定name。</strong><br>  ScopeFules template中有两个foo()调用操作。它会调用foo(double)的版本，<strong>此外，_val的类型是int。因为函数的决议结果只和函数的原型（signature）有关，和函数的返回值没有关系</strong>。因此_member的类型不会影响哪一个foo()实例被选中。在scope中，只有一个foo()候选者。调用操作由scope of the template declareation决议。如果按以下方式：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sr0.<span class="built_in">type_dependent</span>();</span><br></pre></td></tr></table></figure>
  它由scope of the template instantiation决议。它会调用int版本，被type把持。<br>  这意味着编译器必须保持两个scope contexts：<ol>
<li><strong>“scope of the template “，用于专注一般的template class</strong>。</li>
<li><strong>“scope of the template instantiation”，用于专注特定的实例</strong>。</li>
</ol>
</li>
</ul>
<h5 id="Member-Function的实例化行为（Member-Function-Instantiation）"><a href="#Member-Function的实例化行为（Member-Function-Instantiation）" class="headerlink" title="Member Function的实例化行为（Member Function Instantiation）"></a>Member Function的实例化行为（Member Function Instantiation）</h5><ul>
<li>对于template function的实例化（instantiation）。编译器提供了两个策略：一个是<font color=red>编译时期策略</font>，程序代码在program text file中备妥可用；另一个是<font color=red>链接时期策略</font>。</li>
<li>如果virtual function被实例化（instantiated），其实例化点紧跟在class的实例化点后。</li>
<li>template instantiation似乎拒绝全面自动化，虽然工作做对了，但产生出来的object files重新编译成本可能太高，以手动方式在个别object module中完成预先实例化操作（pre-instantiation）是唯一有效率的方法。</li>
</ul>
<h4 id="7-2-异常处理（Exception-Handing）"><a href="#7-2-异常处理（Exception-Handing）" class="headerlink" title="7.2 异常处理（Exception Handing）"></a>7.2 异常处理（Exception Handing）</h4><ul>
<li>想要支持exception handing，编译器的主要工作就是找出catch子句，以处理被抛出的exception。这需要<strong>追踪</strong>程序堆栈中的每个函数的目前作用区域，同时编译器需要提供某种<strong>查询</strong>exception objects的方法，以直到实际类型（RTTI）。还需要某种机制<strong>管理</strong>被抛出的object，包括产生、存储、析构、清理和一般存取。</li>
</ul>
<h5 id="Exception-Handing快速检阅"><a href="#Exception-Handing快速检阅" class="headerlink" title="Exception Handing快速检阅"></a>Exception Handing快速检阅</h5><ul>
<li>exception handing由三个主要组件构成：throw子句、catch子句和try区段。当一个exception被抛出去，控制权会从函数调用中释放出来，并寻找吻合的catch子句。如果没有，则调用terminate()中断例程。当控制权被放弃后，堆栈中每个函数调用也被推理（popped up）。</li>
</ul>
<h5 id="对Exception-Handing的支持"><a href="#对Exception-Handing的支持" class="headerlink" title="对Exception Handing的支持"></a>对Exception Handing的支持</h5><ul>
<li>当exception发生时，编译系统完成以下事情：<ol>
<li>检验发生throw操作的函数。</li>
<li>决定throw操作是否在try区段中。</li>
<li>把exception type拿来和每个catch子句比较。</li>
<li>流程控制交到吻合的匹配的catch子句手中。</li>
<li>如果throw不发生在try区段中，或没有catch子句吻合。那么：<ol>
<li>摧毁active local objects。</li>
<li>堆栈中将函数unwind掉</li>
<li>进行堆栈的下一个函数，然后重复2·5。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h5 id="决定throw是否发生在一个try区段中"><a href="#决定throw是否发生在一个try区段中" class="headerlink" title="决定throw是否发生在一个try区段中"></a>决定throw是否发生在一个try区段中</h5><ul>
<li>一个函数可以想象为好几个区域：<ul>
<li>try区段以外的区域，没有active local objects。</li>
<li>try区段以外的区域，但有一个（或以上）的active local objects需要析构。</li>
<li>try区段以内的区域。</li>
</ul>
</li>
</ul>
<h5 id="将exception的类型和每一个catch子句的类型做比较"><a href="#将exception的类型和每一个catch子句的类型做比较" class="headerlink" title="将exception的类型和每一个catch子句的类型做比较"></a>将exception的类型和每一个catch子句的类型做比较</h5><ul>
<li>对于每个被抛出来的exception，编译器产生一个类型描述器，对exception的类型进行编码。如果那是derived type，编码内容包含所有base class的类型信息。</li>
<li>类型描述器（type derscriptor）是必要的。因为exception是在执行期被处理的，object必须有自己的类型信息。RTTI正是因为支持EH而获得的副产品。</li>
</ul>
<h5 id="当一个实际对象在程序执行时被抛出，会发生什么事？"><a href="#当一个实际对象在程序执行时被抛出，会发生什么事？" class="headerlink" title="当一个实际对象在程序执行时被抛出，会发生什么事？"></a>当一个实际对象在程序执行时被抛出，会发生什么事？</h5><h4 id="7-3-执行期类型识别（Runtime-Type-Identification，RTTI）"><a href="#7-3-执行期类型识别（Runtime-Type-Identification，RTTI）" class="headerlink" title="7.3 执行期类型识别（Runtime Type Identification，RTTI）"></a>7.3 执行期类型识别（Runtime Type Identification，RTTI）</h4><h5 id="Type-Safe-Downcast（保证安全的向下转换操作）"><a href="#Type-Safe-Downcast（保证安全的向下转换操作）" class="headerlink" title="Type-Safe Downcast（保证安全的向下转换操作）"></a>Type-Safe Downcast（保证安全的向下转换操作）</h5><h5 id="Type-Safe-Dynamic-Cast（保证安全的动态转换）"><a href="#Type-Safe-Dynamic-Cast（保证安全的动态转换）" class="headerlink" title="Type-Safe Dynamic Cast（保证安全的动态转换）"></a>Type-Safe Dynamic Cast（保证安全的动态转换）</h5><h5 id="Reference并不是Pointers"><a href="#Reference并不是Pointers" class="headerlink" title="Reference并不是Pointers"></a>Reference并不是Pointers</h5><h5 id="Typeid运算符"><a href="#Typeid运算符" class="headerlink" title="Typeid运算符"></a>Typeid运算符</h5><h4 id="7-4-效率有了，弹性呢？"><a href="#7-4-效率有了，弹性呢？" class="headerlink" title="7.4 效率有了，弹性呢？"></a>7.4 效率有了，弹性呢？</h4><h5 id="动态共享函数库（Dynamic-Shared-Libraries）"><a href="#动态共享函数库（Dynamic-Shared-Libraries）" class="headerlink" title="动态共享函数库（Dynamic Shared Libraries）"></a>动态共享函数库（Dynamic Shared Libraries）</h5><h5 id="共享内存（Shared-Memory）"><a href="#共享内存（Shared-Memory）" class="headerlink" title="共享内存（Shared Memory）"></a>共享内存（Shared Memory）</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E6%84%8F%E5%AD%A6/" class="post-title-link" itemprop="url">第六章 执行期语意学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-12 23:02:33" itemprop="dateCreated datePublished" datetime="2020-06-12T23:02:33+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-06/" itemprop="url" rel="index"><span itemprop="name">2019.06</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#6.1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%EF%BC%88object-construction-and-destruction%EF%BC%89">6.1 对象的构造和析构（Object Construction and Destruction）</a><ul>
<li><a href="#%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%EF%BC%88global-objects%EF%BC%89">全局对象（Global Objects）</a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E9%9D%99%E6%80%81%E5%AF%B9%E8%B1%A1%EF%BC%88local-static-objects%EF%BC%89">局部静态对象（Local Static Objects）</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%EF%BC%88array-of-objects%EF%BC%89">对象数组（Array of Objects）</a></li>
<li><a href="#default-constructors%E5%92%8C%E6%95%B0%E7%BB%84">Default Constructors和数组</a></li>
</ul>
</li>
<li><a href="#6.2-new%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6">6.2 new和delete运算符</a><ul>
<li><a href="#%E9%92%88%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84new%E8%AF%AD%E6%84%8F">针对数组的new语意</a></li>
<li><a href="#placement-operator-new%E7%9A%84%E8%AF%AD%E6%84%8F">Placement Operator new的语意</a></li>
</ul>
</li>
<li><a href="#6.3-%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1%EF%BC%88temporary-objects%EF%BC%89">6.3 临时性对象（Temporary Objects）</a><ul>
<li><a href="#%E4%B8%B4%E6%97%B6%E6%80%A7%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%B7%E6%80%9D%EF%BC%88%E7%A5%9E%E8%AF%9D%E3%80%81%E4%BC%A0%E8%AF%B4%EF%BC%89">临时性对象的迷思（神话、传说）</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<ul>
<li>有个简单的式子：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (yy == xx.<span class="built_in">getValue</span>())) ...</span><br></pre></td></tr></table></figure>
  其中xx和yy的定义：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>();</span><br><span class="line">    ~<span class="built_in">Y</span>();</span><br><span class="line">    <span class="keyword">bool</span> oeprator==(<span class="keyword">const</span> Y&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>();</span><br><span class="line">    ~<span class="built_in">X</span>();</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">Y</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// conversion运算符</span></span><br><span class="line">    <span class="function">X <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  当使用equality（等号）运算符时，xx被resolves为“被overloaded的Y成员实例”。下面是该式子的转换：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolution of intended operator</span></span><br><span class="line"><span class="keyword">if</span> (yy.<span class="keyword">operator</span>==(xx.<span class="built_in">getValue</span>()))</span><br></pre></td></tr></table></figure>
  Y的等号运算符需要一个类型为Y的参数，而getValue()传回的是一个类型为X的object。这时提供<font color=red>conversion运算符</font>，把一个X object转换为一个Y object，它<strong>施行于getValue()的返回值身上</strong>。下面是第二次转换：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conversion of getValue()&#x27;s return value</span></span><br><span class="line"><span class="keyword">if</span> (yy.<span class="keyword">operator</span>==(xx.<span class="built_in">getalue</span>().<span class="keyword">operator</span> <span class="built_in">Y</span>()))</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-1-对象的构造和析构（Object-Construction-and-Destruction）"><a href="#6-1-对象的构造和析构（Object-Construction-and-Destruction）" class="headerlink" title="6.1 对象的构造和析构（Object Construction and Destruction）"></a>6.1 对象的构造和析构（Object Construction and Destruction）</h4><ul>
<li>一般constructor和destructor的安插都如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    <span class="comment">// point.point::Point();</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// point.point::~Point();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  如果一个区段或函数有一个以上的离开点，情况就会混乱一些，Destructor必须被放在每一个离开点（object还存活）之前。</li>
</ul>
<h5 id="全局对象（Global-Objects）"><a href="#全局对象（Global-Objects）" class="headerlink" title="全局对象（Global Objects）"></a>全局对象（Global Objects）</h5><ul>
<li>C++保证在第一次使用global数据前之前，将它构造出来，而在结束前把identity摧毁掉。<strong>如果global object如果有constructor和destructor的话，它需要静态的初始化操作和内存释放操作</strong>。所有的global obejct都被放置在程序的data segment中。如果不显式指定值，则内存内容为0（C略有不同，C并不自动设定初值）。C语言中一个global object只能被一个常量表达式（可在编译时期求值）设定初值。虽然class object在编译时期可以被放置data segment中并且内容为0，<strong>但constructor一直要到程序启动（startup）时才会实施。而必须对放置program data segment中的object的初始化表达式做评估（evaluate），这就是一个object需要静态初始化的原因</strong>。</li>
<li><font color=red><strong>munch</strong></font><strong>是一个可移植但成本颇高的静态初始化（以及内存释放）方法</strong>。munch策略：<ol>
<li><strong>为每个需要静态初始化的文件产生<font color=red>__sti()函数</font>(sti是static initialization)，内含constructor调用操作或inline expansions</strong>。一个global对象identity会在matrix.c中产生： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__sti_matrix_c__identity() &#123;</span><br><span class="line">    identity.Matrix::<span class="built_in">Matrix</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 matrix_c是文件名编码，_identity表示文件中所定义的static object。</li>
<li><strong>在每个需要静态的内存释放操作（static deallocation）的文件中，产生一个<font color=red>__std()函数</font>(std是static deallocation)，内含必要的destructor调用操作，或是inline expansions</strong>。比如以上identity对象会调用Matrix destructor。</li>
<li>**提供一组<font color=red>rumtime library “munch”函数</font>：一个_mani()函数(call __sti()，一个exit()函数(call __std())**。</li>
</ol>
</li>
<li><em>最后一个需要解决的问题是，如何收集程序中各个object files的__sti()函数和__std()函数。解决方法是使用<font color=red>nm命令</font>，nm会dump出object file的<font color=red>符号表格项目</font>（<font color=green>symbol table entries</font>）。<strong>nm</strong>施行于可执行文件上，输出<strong>piped into</strong>到munch程序中。munch程序则搜寻__sti或__std开头的名称，然后把函数名称加到<strong>jump table</strong>中，然后把表格写到<font colorr=ed>program text</font>文件中，CC命令被重新激活，将内含表格的文件编译，整个可执行文件被重新链接。_main()和exit()在各个表格上走访一遍，轮流调用每一个项目（代表一个函数地址）</em>。但这方法离正统计科太远了……</li>
<li>当特性平台的C++编译器出现，更有效率的方法也随之出现，因为各平台上扩充链接器和目的文件格式（object file format），以直接支持静态初始化和内存释放操作。例如System V的Executable and Linking Format(ELF)被扩充以增加支持.init和.fini两个sections，两个sections内含的对象所需的信息，分别对应静态初始化和释放操作。编译器特定的startup函数会完成平台特定的支持。</li>
<li>使用被静态初始化的objects，<font color=red><strong>有缺点</strong></font>。如果exception handing被支持，那些objects将不能被放置于try区段之内。因为任何的throw操作必然将触发exception handing library的默认terminate()函数以致于结束程序，这对于被静态调用的constructors可能是特别无法接受的。<font color=red><strong>另一个缺点</strong></font>是为了控制跨模块静态初始化的objects的依赖顺序，而形成的复杂度。建议根本不要用需要静态初始化的global objects（虽然这建议不普遍为C程序员接受）。</li>
</ul>
<h5 id="局部静态对象（Local-Static-Objects）"><a href="#局部静态对象（Local-Static-Objects）" class="headerlink" title="局部静态对象（Local Static Objects）"></a>局部静态对象（Local Static Objects）</h5><ul>
<li>假设有以下程序片段：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Matrix&amp; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Matrix mat_identity;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> mat_identity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <font color=red>Local static class object</font>保证了什么样的语意？<ul>
<li><strong>mat_identity的constructor只能执行一次，虽然函数可能被调用多次</strong>。</li>
<li><strong>mat_identity的destructor只能施行一次，虽然函数可能会被调用多次</strong>。</li>
</ul>
</li>
<li>编译器的无条件构造对象会导致即使函数不曾被调用过也被程序起始时被初始化。cfont的做法是，用一个临时性对象保护mat_identity的初始化操作。第一次调用时，临时对象被评估为false，constructor被调用，然后临时对象改为true。而destructor判断则反过来。困难的是，没办法在静态的内存释放函数中存取local对象。取出local object的地址就好了……</li>
</ul>
<h5 id="对象数组（Array-of-Objects）"><a href="#对象数组（Array-of-Objects）" class="headerlink" title="对象数组（Array of Objects）"></a>对象数组（Array of Objects）</h5><ul>
<li>假如有数组定义：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
  如果Point没有定义constructor也没有定义destructor，那么工作不会比（<font color>build-in</font>）类型的数组更多。然而它的确定义了一个default destructor，所以这个操作轮流施行每个元素上。cfont中，使用一个叫vec_new()的函数，产生以class object构造成的数组。一些新编译器则提供了两个函数，一个分别处理有和没有内含virtual base class的class。vec_vnew()用于内含virtual base class函数的class。当然不同平台有差异：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vec_new</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> *array,        <span class="comment">// 数组起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">size_t</span> elem_size,   <span class="comment">// class object的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">int</span> elem_count,     <span class="comment">// 元素个数</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> (*constructor)(<span class="keyword">void</span>*), <span class="comment">// 函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*, <span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
  <strong>参数array如果持有不具名数组地址（knots），就是0，意味着数组经由应用程序new运算符动态配置于heap中</strong>。<br>  下面是编译器可能针对10个Point元素所做的vec_new()调用操作：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">vec_new</span>(&amp;knots, <span class="built_in"><span class="keyword">sizeof</span></span>(Point), <span class="number">10</span>, &amp;Point::Point, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
  如果Point定义了一个destructor，当knots结束时destructor也施行于10个Point元素身上。这时经由一个类似vec_delete()的<font color=red>runtime library</font>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">vec_delete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> *array,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">size_t</span> elem_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> elem_count,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*, <span class="keyword">char</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
  对于以下的组成方式：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point knots[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="built_in">Point</span>(),</span><br><span class="line">    <span class="built_in">Point</span>(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>),</span><br><span class="line">    <span class="number">-1.0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  对于明显获得初值的元素，vec_new()不再有必要。对于尚未初始化的元素，施行方式则像没有explicit initialization list的class elemnts一样：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line">Point knots[<span class="number">10</span>];</span><br><span class="line">Point::<span class="built_in">Point</span>(&amp;knots[<span class="number">0</span>]);</span><br><span class="line">Point::<span class="built_in">Point</span>(&amp;knots[<span class="number">1</span>], <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.5</span>);</span><br><span class="line">Point::<span class="built_in">Point</span>(&amp;knots[<span class="number">2</span>], <span class="number">-1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line"><span class="comment">// 初始化剩余7个元素</span></span><br><span class="line"><span class="built_in">vec_new</span>(&amp;knots+<span class="number">3</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Point), <span class="number">7</span>, &amp;Point:Piont, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Default-Constructors和数组"><a href="#Default-Constructors和数组" class="headerlink" title="Default Constructors和数组"></a>Default Constructors和数组</h5><h4 id="6-2-new和delete运算符"><a href="#6-2-new和delete运算符" class="headerlink" title="6.2 new和delete运算符"></a>6.2 new和delete运算符</h4><ul>
<li>运算符new的使用，看起来似乎是单一运算，像这样：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
  它由两个<font color=red>步骤完成</font>：<ol>
<li><strong>通过new运算符函数实例，分配内存</strong>。</li>
<li><strong>为配置的内存初始化</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">if</span> (pi = __new(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)))</span><br><span class="line">    *pi = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
pi所指对象的生命因delete而结束。所有后继对pi的参考操作不再保证有良好的行为。虽然地址上的对象不再合法，地址本身仍然代表一个合法的程序空间。因此pi能继续被使用，但不是个合法的编程风格。</li>
</ol>
</li>
<li>以constructor分配一个class object，情况类似：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ponit3d *origin = <span class="keyword">new</span> Point3d;</span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line">Point3d *origin;</span><br><span class="line"><span class="keyword">if</span> (origin = __new(<span class="built_in"><span class="keyword">sizeof</span></span>(Point3d)))</span><br><span class="line">    origin = Point3d::<span class="built_in">Point3d</span>(origin);</span><br><span class="line"><span class="comment">// 如果有exception hading，情况会复杂</span></span><br><span class="line"><span class="keyword">if</span> (origin = __new(<span class="built_in"><span class="keyword">sizeof</span></span>(Point3d))) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        origin = Point3d::<span class="built_in">Point3d</span>(origin);</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> ( ... ) &#123;</span><br><span class="line">        __delete(origin);</span><br><span class="line">        <span class="keyword">throw</span>;  <span class="comment">// 继续抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  Destructor情况类似：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> origin;</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line"><span class="keyword">if</span> (origin != <span class="number">0</span>) &#123;</span><br><span class="line">    Point3d::~<span class="built_in">Point3d</span>(origin);</span><br><span class="line">    __delete(origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果有exception handing</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
  new运算符实现：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">void</span> *last_alloc;</span><br><span class="line">    <span class="keyword">while</span> (!(last_alloc = <span class="built_in">malloc</span>(size)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_new_handler)</span><br><span class="line">            (*_new_handler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_alloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  虽然这么写是合法的：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> T[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
  <strong>但语言要求每次new调用都返回独一无二的指针。解决问题的传统方法是传回一个指针，指向一个默认为1-byte的内存区块（这就是为什么程序代码中size被设为1的原因）</strong>。这个程序的有趣之处在于，它允许使用者提供一个属于自己的_new_handler()函数。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> vodi <span class="keyword">operator</span> <span class="title">edlete</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        <span class="built_in">free</span>((<span class="keyword">char</span>*)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="针对数组的new语意"><a href="#针对数组的new语意" class="headerlink" title="针对数组的new语意"></a>针对数组的new语意</h5><ul>
<li>new一个数组；  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line"><span class="keyword">int</span> *p_array = (<span class="keyword">int</span>*)__new(<span class="number">5</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
  vec_new()不会被调用，因为它主要功能是把default constructor施行于class objects所组成的数组的每个元素身上。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point3d *p_array = <span class="keyword">new</span> Point3d[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line">Point3d *p_array;</span><br><span class="line">p_array = <span class="built_in">vec_new</span>(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(Point3d), <span class="number">10</span>, &amp;Point3d::Point3d, &amp;Point3d::~Point3d);</span><br></pre></td></tr></table></figure></li>
<li>应该如何记录元素个数？一个方法是为vec_new()传回的每个内存块配置一个额外的word，然后元素个数藏在word中，这叫<font color=red>cookie</font>。原始编译器有两个用来存取cookie：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *pv;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __insert_new_array(PV array_key, <span class="keyword">int</span> elem_count);</span><br><span class="line"><span class="comment">// 表格中取出并移除array_key，传回不是elem_count则传回-1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> __remove_old_array(PV array_key);</span><br><span class="line"><span class="comment">// cfront vec_new()</span></span><br><span class="line">PV __vec_new(PV ptr_array, <span class="keyword">int</span> elem_count, <span class="keyword">int</span> size, PV construct)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果ptr_array是0，从heap中配置数组。</span></span><br><span class="line">    <span class="keyword">int</span> alloc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> array_sz = elem_count == <span class="number">0</span>)</span><br><span class="line">        ptr_array = <span class="built_in">PV</span>(<span class="keyword">new</span> <span class="keyword">char</span>[array_sz]);</span><br><span class="line">    <span class="keyword">if</span> (ptr_array == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 把数组元素个数放到cache中</span></span><br><span class="line">    <span class="keyword">int</span> status = __insert_new_array(ptr_array, elem_count);</span><br><span class="line">    <span class="keyword">if</span> (status === <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc)</span><br><span class="line">            <span class="keyword">delete</span> ptr_array;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (construct) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">char</span>* elem = (<span class="keyword">char</span>*)ptr_array;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">char</span>* lim = elem + array_sz;</span><br><span class="line">        <span class="comment">// PF是typedef，代表函数指针</span></span><br><span class="line">        <span class="keyword">register</span> PF fp = <span class="built_in">PF</span>(constructor);</span><br><span class="line">        <span class="keyword">while</span> (elem &lt; lim) &#123;</span><br><span class="line">            (*fp)((<span class="keyword">void</span>*)elem);</span><br><span class="line">            <span class="comment">// 下一个元素</span></span><br><span class="line">            elem += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PV</span>(ptr_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Placement-Operator-new的语意"><a href="#Placement-Operator-new的语意" class="headerlink" title="Placement Operator new的语意"></a>Placement Operator new的语意</h5><ul>
<li>有一个预先定义好的重载的（overloaded）new运算符，称为<font colorr=red><strong>placement oeprator new</strong></font>。它需要第二个参数，类型为void*，调用方式如下:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point2w *ptw = <span class="built_in"><span class="keyword">new</span></span>(arena) Point2w;</span><br></pre></td></tr></table></figure>
  arena指向内存中的区块，用来放置新的Point2w object。placement operator new的实现方法很平凡：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  placement new operator的强大之处在于，编译系统保证object的constructor会施行于其上：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point2w *ptw = (Point2w*)arena;</span><br><span class="line"><span class="keyword">if</span> (ptw != <span class="number">0</span>)</span><br><span class="line">    ptw-&gt;Point2w::<span class="built_in">Point2w</span>();</span><br></pre></td></tr></table></figure>
  对于arena表现的真正指针的类型，derived class很明显不在支持之列。对于derived class，或是其他没有关联的类型，行为虽然并非不合法，却也未经定义：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以这么配置</span></span><br><span class="line"><span class="keyword">char</span> *arena = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in"><span class="keyword">sizeof</span></span>(Point2w)];</span><br><span class="line"><span class="comment">// 相同object可以这么获得</span></span><br><span class="line">Point2sw *arena = <span class="keyword">new</span> Point2w;</span><br><span class="line"><span class="comment">// 一般placement new operator并不支持多态。</span></span><br><span class="line"><span class="comment">// 如果derived class比base class大，Point3w的constructor会导致严重破坏。</span></span><br><span class="line">Point2w *p2w = <span class="built_in"><span class="keyword">new</span></span> (arena) Point3w;</span><br></pre></td></tr></table></figure>
  Placement new operator引入C++2.0时，最晦涩难懂的问题就是：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span> <span class="keyword">int</span> j; <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base &#123; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">f</span>();      <span class="comment">// Base::f()被调用</span></span><br><span class="line">    b.~<span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">new</span>(&amp;b) Derived;    </span><br><span class="line">    b.<span class="built_in">f</span>();      <span class="comment">// 哪个f()被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-3-临时性对象（Temporary-Objects）"><a href="#6-3-临时性对象（Temporary-Objects）" class="headerlink" title="6.3 临时性对象（Temporary Objects）"></a>6.3 临时性对象（Temporary Objects）</h4><ul>
<li><p>如果有函数：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure>
<p>  那么两个此对象的a和b进行<code>a+b;</code>。会产生临时变量放置传回的对象。详细过程是产生临时性对象，放置结果，使用T的copy constructor，把临时性对象当作c的初始值。当然，视operator+()定义而定，NRV优化可能实施起来。这导致直接求表达式结果，避免执行copy constructor和具名对象的destructor。至于会用哪种方式初始化，C++ Standard允许编译器有临时性对象的完全自由度：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T c = a + b;</span><br><span class="line"><span class="comment">// 而其中的加法运算符被定义为</span></span><br><span class="line">T <span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">T T::<span class="keyword">operator</span>+(<span class="keyword">const</span> T&amp;);</span><br></pre></td></tr></table></figure>
<p>  那么实现根本<font color=red>不产生临时性变量</font>。如果以：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a + b;</span><br></pre></td></tr></table></figure>
<p>  不能够忽略，它会导致下面结果：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T temp;</span><br><span class="line">temp.<span class="keyword">operator</span>+(a, b);   （<span class="number">1</span>）</span><br><span class="line">c.<span class="keyword">operator</span>=(temp);      （<span class="number">2</span>）</span><br><span class="line">temp.T::~<span class="built_in">T</span>();</span><br></pre></td></tr></table></figure>
<p>  （1）那行意味着为构造的临时对象赋值给operator+()。意思是要么<strong>表达式结果被copy constructed到临时对象中</strong>，要么<strong>以临时对象取代NRV</strong>。然而不管哪一种情况都有问题。运算符函数并不为外加参数调用destructor（它期望新内存），所以需要在调用前先调用destructor。然而，<strong>转换语意被用来把copy assignment运算符的隐式调用操作和destructor和copy constructor来代替assignment操作</strong>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.T::~<span class="built_in">T</span>();</span><br><span class="line">c.T::<span class="built_in">T</span>(a + b);</span><br></pre></td></tr></table></figure>
<p>  而以上操作都可以由使用者供应，而且它还会产生临时变量。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T c = a + b;</span><br><span class="line"><span class="comment">// 上面的比下面的操作更有效率被编译器转化</span></span><br><span class="line">c = a + b;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种形式是，没有目标对象：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br><span class="line"><span class="comment">// 不论怎么种情况</span></span><br><span class="line">String v;</span><br><span class="line">v = s + t + u;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + t);</span><br></pre></td></tr></table></figure>
<p>  都会产生临时对象，与s+t相关联。上述的printf可能不保证安全，因为它的正确性和s+t何时被摧毁有关。（malloc(0)）。例如对于该算式的一个可能的pre-Standard转换，可能造成重大灾难：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="comment">// 临时性对象被摧毁得太快（太早）了。</span></span><br><span class="line">String temp1 = <span class="keyword">operator</span>+(s, t);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *temp2 = temp1.<span class="keyword">operator</span> <span class="keyword">const</span> <span class="keyword">char</span>*();</span><br><span class="line">temp1.~<span class="built_in">String</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, temp2);  <span class="comment">// temp2来自何方？</span></span><br></pre></td></tr></table></figure>
<p>  一种转换方式是在调用printf()之后实施String destructor。<font color=red>标准规格上</font>说：<font color=red><strong>临时性对象的被摧毁，应该是对完整表达式（full-expression）求值过程种的最后一个步骤。该完整表达式造成临时对象的产生</strong></font>。<strong>完整表达式是被包裹的表达式种最外围的那个表达式</strong>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tertiary full expression with 5 sub-expressions</span></span><br><span class="line">((objA &gt; <span class="number">1024</span>) &amp;&amp; (objB &gt; <span class="number">1024</span>)) ? objA + objB : <span class="built_in">foo</span>(objA, objB);</span><br></pre></td></tr></table></figure>
<p>  五个子算式内含在“？：完整表达式”中。<strong>任何子表达式所产生的任何临时对象，都应该在完整表达式被求值完成后，才可以毁去</strong>。  p273</p>
</li>
<li><p>临时性对象的生命规则有两个例外：</p>
<ul>
<li><strong>第一个例外发生在表达式被用来初始化一个object时</strong>。如果某个对象progNameVersion的初始化需要调用copy constructor，那么临时性对象的析构就不是我们期望的。C++ Standard要求说：<font color=red><strong>凡持有表达式执行结果的临时性对象，应该存留到object的初始化操作完成为止</strong></font>。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* progNameVersion = progName + progVersion;</span><br><span class="line"><span class="comment">// C++ pseudo Code</span></span><br><span class="line">String temp;</span><br><span class="line"><span class="keyword">operator</span>+(temp, progName, progVersion);</span><br><span class="line">progNmaeVersion = temp.String::<span class="keyword">operator</span> <span class="keyword">char</span>*();</span><br><span class="line">temp.String::~<span class="built_in">String</span>();</span><br></pre></td></tr></table></figure>
  progNameVersion指向未定义的heap内存。</li>
<li><strong>第二个例外是当一个临时性对象被一个reference绑定时</strong>，例如：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> String &amp;space = <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">// 产生代码</span></span><br><span class="line"><span class="comment">// C++ pseudo Code</span></span><br><span class="line">String temp;</span><br><span class="line">temp.String::<span class="built_in">String</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">const</span> String &amp;space = temp;</span><br></pre></td></tr></table></figure>
  很明晰那，临时性对象被摧毁，reference就没什么用了。所以Standard说：<br>  <font color=red><strong>如果临时性对象被绑定与reference，对象将残留，直到reference的生命结束，直到临时对象的生命范畴（scope）结束</strong></font>。</li>
</ul>
</li>
</ul>
<h5 id="临时性对象的迷思（神话、传说）"><a href="#临时性对象的迷思（神话、传说）" class="headerlink" title="临时性对象的迷思（神话、传说）"></a>临时性对象的迷思（神话、传说）</h5>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E6%84%8F%E5%AD%A6/" class="post-title-link" itemprop="url">第五章 构造、析构、拷贝语意学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-12 22:59:07" itemprop="dateCreated datePublished" datetime="2020-06-12T22:59:07+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-06/" itemprop="url" rel="index"><span itemprop="name">2019.06</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%88presence-of-a-pure-virtal-function%EF%BC%89">纯虚函数的存在（Presence of a Pure Virtal Function）</a></li>
<li><a href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AD%98%E5%9C%A8(presence-of-a-pure-virtual-function)">纯虚函数的存在(Presence of a Pure Virtual Function)</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E8%A7%84%E6%A0%BC%E7%9A%84%E5%AD%98%E5%9C%A8%EF%BC%88presence-of-a-virtual-specification%EF%BC%89">虚拟规格的存在（Presence of a Virtual Specification）</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E8%A7%84%E6%A0%BC%E4%B8%ADconst%E7%9A%84%E5%AD%98%E5%9C%A8">虚拟规格中const的存在</a></li>
<li><a href="#%E9%87%8D%E6%96%B0%E8%80%83%E8%99%91class%E7%9A%84%E5%A3%B0%E6%98%8E">重新考虑class的声明</a></li>
<li><a href="#5.1-%E2%80%9D%E6%97%A0%E7%BB%A7%E6%89%BF%E2%80%9D%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">5.1 ”无继承”情况下的对象构造</a><ul>
<li><a href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88abstract-data-type%EF%BC%89">抽象数据类型（Abstract Data Type）</a></li>
<li><a href="#%E4%B8%BA%E7%BB%A7%E6%89%BF%E5%81%9A%E5%87%86%E5%A4%87">为继承做准备</a></li>
</ul>
</li>
<li><a href="#5.2-%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB%E4%B8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">5.2 继承体系下的对象构造</a><ul>
<li><a href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%88virtual-inheritance%EF%BC%89">虚拟继承（Virtual Inheritance）</a></li>
<li><a href="#vptr%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88the-semantics-of-the-vptr-initialization%EF%BC%89">vptr初始化语意学（The Semantics of the vptr Initialization）</a></li>
</ul>
</li>
<li><a href="#5.3-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88object-copy-semantics%EF%BC%89">5.3 对象复制语意学（Object Copy Semantics）</a></li>
<li><a href="#5.4-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%95%88%E8%83%BD%EF%BC%88object-efficiency%EF%BC%89">5.4 对象的效能（Object Efficiency）</a></li>
<li><a href="#5.5-%E6%9E%90%E6%9E%84%E8%AF%AD%E6%84%8F%E5%AD%A6%EF%BC%88semantics-of-destruction%EF%BC%89">5.5 析构语意学（Semantics of Destruction）</a></li>
</ul>
<!-- vim-markdown-toc -->
<h5 id="纯虚函数的存在（Presence-of-a-Pure-Virtal-Function）"><a href="#纯虚函数的存在（Presence-of-a-Pure-Virtal-Function）" class="headerlink" title="纯虚函数的存在（Presence of a Pure Virtal Function）"></a>纯虚函数的存在（Presence of a Pure Virtal Function）</h5><ul>
<li>考虑abstract base class声明:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Abstract_base</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _mumble; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这个class被设计为一个抽象的base class(其中有pure virtual function,使得Abstract_base不可能有实例),但需要一个显式的构造函数以初始化data member _mumble。如果没有初始化操作，derived class的局部性对象_mumble及那个无法决定初值。</li>
</ul>
<h5 id="纯虚函数的存在-Presence-of-a-Pure-Virtual-Function"><a href="#纯虚函数的存在-Presence-of-a-Pure-Virtual-Function" class="headerlink" title="纯虚函数的存在(Presence of a Pure Virtual Function)"></a>纯虚函数的存在(Presence of a Pure Virtual Function)</h5><ul>
<li>pure virtual function只能被<font color=red>静态地调用</font>（<font  color=green>invoked statically</font>），不能经由虚拟机制调用。<strong>而pure virtual destructor，class设计者一定得定义它。因为每个derived class class以及base class destructor。只要缺乏定义，就会导致链接失败</strong>。</li>
</ul>
<h5 id="虚拟规格的存在（Presence-of-a-Virtual-Specification）"><a href="#虚拟规格的存在（Presence-of-a-Virtual-Specification）" class="headerlink" title="虚拟规格的存在（Presence of a Virtual Specification）"></a>虚拟规格的存在（Presence of a Virtual Specification）</h5><ul>
<li>如果决定把Abstract_base::mumble()设计为virtual function，那是糟糕的选择，因为其函数定义内容并不与类型有关，因而几乎不会被后继的derived class改写。</li>
</ul>
<h5 id="虚拟规格中const的存在"><a href="#虚拟规格中const的存在" class="headerlink" title="虚拟规格中const的存在"></a>虚拟规格中const的存在</h5><ul>
<li>决定要给virtual function是否需要const，是一件繁琐的事情。如果声明为const，意味着subclass实例可能被无穷次数地使用。不把函数声明为const，意味和函数不能获得一个const reference或const pointer。头大的是，声明函数为const，才发现derived instance必须修改某一data member。解决办法就是不再用const就是了。</li>
</ul>
<h5 id="重新考虑class的声明"><a href="#重新考虑class的声明" class="headerlink" title="重新考虑class的声明"></a>重新考虑class的声明</h5><ul>
<li>综上所述，这才是比较适当的一种设计：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Abstract_base</span>();   <span class="comment">// nonpure virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">interface</span><span class="params">()</span> </span>= <span class="number">0</span>;   <span class="comment">// nonconst</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">mumble</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _mumble; &#125; <span class="comment">// nonvirtual</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Abstract_base</span>(<span class="keyword">char</span> *pc =ss <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">char</span> *_mumble;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-1-”无继承”情况下的对象构造"><a href="#5-1-”无继承”情况下的对象构造" class="headerlink" title="5.1 ”无继承”情况下的对象构造"></a>5.1 ”无继承”情况下的对象构造</h4><ul>
<li><p>考虑程序片段：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Point global;                   <span class="comment">//1</span></span><br><span class="line">                                <span class="comment">//2</span></span><br><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">()</span>                  <span class="comment">//3</span></span></span><br><span class="line"><span class="function"></span>&#123;                               <span class="comment">//4</span></span><br><span class="line">    Point local;                <span class="comment">//5</span></span><br><span class="line">    Point *heap = <span class="keyword">new</span> Point;    <span class="comment">//6</span></span><br><span class="line">    *heap = local;              <span class="comment">//7 </span></span><br><span class="line">    <span class="comment">// ... stuff ...            //8</span></span><br><span class="line">    <span class="keyword">delete</span> heap;                <span class="comment">//9</span></span><br><span class="line">    <span class="keyword">return</span> local;               <span class="comment">//10</span></span><br><span class="line">&#125;                               <span class="comment">//11</span></span><br></pre></td></tr></table></figure>
<p>  L1、L5、L6分别为：<strong>global内存配置</strong>、<strong>local内存配置</strong>和<strong>heap内存配置</strong>。一个object的声明，是该object的一个执行期属性。local object的生命从L5定义开始，L10为止。global object的生命和这个程序的生命相同。heap object的生命从被new运算符配置出来开始，到delete运算符摧毁结束。<br>  下面是Point的第一次声明，写成C程序。这是一种Plain OI’ Data声明形式：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">    Point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果用C++来编译这代码，<strong>编译器会为Point声明一个trivial default constructor、一个trivial destructor、一个trivial copy constructor，以及一个trivial copy assignment operator</strong>。但实际上，编译器会分析这个声明，并<font color=red>贴上POD标签</font>。</p>
</li>
<li><p>当编译器遇到这样的定义：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global;                   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>  观念上Point的trival constructor和destructor会被产生并调用，constructor在程序起始（<font color=red>startup</font>）被调用，而destructor在程序的<font color=red>exit()</font>处被调用。然而事实上trivial members要么没定义，要么没被调用。<br>  在C中，global被视为一个<font color=red>临时性的定义</font>，因为它没有显式的初始化操作。它可以在程序中发生多次。实例<strong>会被折叠起来，只留下一个，放在程序data segment中</strong>。这块空间称为<font color=red><strong>BSS</strong></font>，这是Block Started by Symbol缩写。<br>  C++并不支持临时性定义。虽然它可以判断class object或是POD。global在C++中被视为完全定义（会阻止多个定义）。C和C++的差异是，BSS data segment在C++中相对不重要。<font color=red><strong>所有的全局变量都被以“初始化过的数据”来对待</strong></font>。<br>  至于foobar()函数的L5，既没有构造也没有被析构，不过可能没有经过初始化就会成BUG（L7）。至于heap object：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point *heap = <span class="keyword">new</span> Point;    <span class="comment">//6</span></span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line">Point *heap = __new(<span class="built_in"><span class="keyword">sizeof</span></span>(Point));</span><br><span class="line"><span class="comment">// 有初始化过就没问题</span></span><br><span class="line">*heap = local;              <span class="comment">//7 </span></span><br></pre></td></tr></table></figure>
<p>  事实上L7会产生编译警告，观念上，这样的指定操作会触发trivial copy assignment operator做拷贝搬运操作。而实际上object是POD，所以assignment只是像C那样纯粹bitwise搬运。</p>
</li>
</ul>
<h5 id="抽象数据类型（Abstract-Data-Type）"><a href="#抽象数据类型（Abstract-Data-Type）" class="headerlink" title="抽象数据类型（Abstract Data Type）"></a>抽象数据类型（Abstract Data Type）</h5><ul>
<li>以下是Point声明，提供了完整封装性，但没有提供virtual function：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>) : _x(x), _y(y), _z(z) &#123;&#125;</span><br><span class="line">    <span class="comment">// no copy constructor, copy operator</span></span><br><span class="line">    <span class="comment">// or destructor defined ...</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y, _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这里还是三个连续的float，不论private或public存取层或是member function都不会占用额外的对象空间。没有定义copy constructor或copy operator，因为有<strong>default bitwise semantics</strong>足够了，也不需要destructor。对于实例：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point global; <span class="comment">// Point::Point(0.0, o.0, 0.0);</span></span><br></pre></td></tr></table></figure>
  有了default constructor，global被定义在全局范畴，初始化操作将延迟到程序启动（startup）。<br>  如果要将class中的所有成员设定常量初值，给予一个<font color=red>explicit initialization list</font>会比较有效率（相比constructor的inline expansion而言）。但它有三项缺点：<ol>
<li>只有当class members都是public，才会奏效。</li>
<li>只能指定常量，因为在编译器就能评估求值。</li>
<li>由于编译器并不自动施行，初始化行为可能性很高。</li>
</ol>
</li>
</ul>
<h5 id="为继承做准备"><a href="#为继承做准备" class="headerlink" title="为继承做准备"></a>为继承做准备</h5><ul>
<li>第三个Point声明，为继承性质和某些操作的<font color=red>动态决议</font>（<font color=green>dynamic resolution</font>）做准备，目前限制z成员做存取操作：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>) : _x(x), _y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// no destructor, copy constructor, or</span></span><br><span class="line">    <span class="comment">// copy operator defined ... </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  virtual functions的导入在这里附带一个virtual destructor的声明在这个例子里，并无好处。除此之外，每个class object多负担一个vptr之外，virtual function的导入也引发编译器对Point class产生的膨胀作用：<ul>
<li><strong>定义的constructor附带了一些代码，以便vptr初始化</strong>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="function">Point* <span class="title">Point::Point</span><span class="params">(Point *<span class="keyword">this</span>, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> : _x(x), _y(y)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line">    <span class="comment">// 设定object的vptr</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point = __vtbl__Point;</span><br><span class="line">    <span class="comment">// 扩展member initialization list</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_y = y;</span><br><span class="line">    <span class="comment">// 传回this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>合成一个copy constructor和copy assignment operator，而且操作不是trivial（implicit destructor仍然是）</strong>。如果Point object被初始化或以derived class object赋值，那么以为基础（bitwise）的操作可能对vptr带来非法设定：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="comment">// copy constructor 内部合成</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point* <span class="title">Point::Point</span><span class="params">(Point*<span class="keyword">this</span>, <span class="keyword">const</span> Point &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// object的vptr</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point = __vtbl__Point;</span><br><span class="line">    <span class="comment">// copy</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编译器在优化状态会把object内容连续拷贝到另一个object，而不是精准memberwise。<strong>L7的memberwise赋值操作可能出发copy assignment operator的合成，及调用<font color=red>inline expansion</font>（行内扩张）：以this取代heap，以rhs取代local</strong>。<br>戏剧性的冲击在L10。由于copy constructor的出现，foobar()可能转化为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point local;</span><br><span class="line">    local.Point::<span class="built_in">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// heap</span></span><br><span class="line">    <span class="comment">// copy constructor</span></span><br><span class="line">    __result.Point::<span class="built_in">Point</span>(local);</span><br><span class="line">    <span class="comment">// local destructor</span></span><br><span class="line">    <span class="comment">// Point::derstructor</span></span><br><span class="line">    <span class="comment">// local.Point::~Point();</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果NRV优化，转化为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">foobar</span><span class="params">(Point &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __result.Point::<span class="built_in">Point</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// heap</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="5-2-继承体系下的对象构造"><a href="#5-2-继承体系下的对象构造" class="headerlink" title="5.2 继承体系下的对象构造"></a>5.2 继承体系下的对象构造</h4><ul>
<li><p>当定义一个object：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T object;</span><br></pre></td></tr></table></figure>
<p>  如果T有constructor，它会被调用。除此之外，constructor调用伴随了什么？constructor可能内含大量隐藏码，因为<font color=red><strong>编译器会扩充每个constructor</strong></font>：</p>
<ol>
<li>在member initialization list中的data members初始化操作会被放进constructor函数本体，以声明顺序为顺序。</li>
<li>如果member没有在member initialization list中，但这个member有default constructor，那么被调用。</li>
<li>在那之前，如果class object有vptr，必须被设定初值指向适当vtbls。</li>
<li>在那之前，base class constructors必须被调用，以base class声明顺序为顺序。<ul>
<li><strong>如果base class被列入member initialization list中，那么任何显式参数都传递进去</strong>。</li>
<li><strong>如果base class没有被列入member initialization list中，而它有default constructor（或default memberwie copy constructor），那么调用它</strong>。</li>
<li><strong>如果base class是多层继承下的第二或后继base class，那么调整this指针</strong>。</li>
</ul>
</li>
<li>在那之前，所有virtual base class constructors必须被调用，从左到右，从深到浅：<ul>
<li><strong>如果class被列入member initialization list中，那么任何显式指定的参数，都传递进去。如果没有列入list中，而class有default constructor，调用它</strong>。</li>
<li><strong>class中的每个virtual base class subobject的偏移地址（offset）必须在执行期可被存取</strong>。</li>
<li><strong>如果class object是最底层（most-derived）的class，其constructors可能被调用；用以支持者行为的机制必须放出来</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p>以Point为例，探讨constructors扩充的必要性：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp;);            <span class="comment">// copy constructor</span></span><br><span class="line">    Point&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point&amp;); <span class="comment">// copy assignment operator</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();               <span class="comment">// virtual derstructor</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point _begin, _end;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">Line</span>(<span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Point&amp;);</span><br><span class="line">    <span class="built_in">draw</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  。。。。。。。。</p>
</li>
</ul>
<h5 id="虚拟继承（Virtual-Inheritance）"><a href="#虚拟继承（Virtual-Inheritance）" class="headerlink" title="虚拟继承（Virtual Inheritance）"></a>虚拟继承（Virtual Inheritance）</h5><ul>
<li>考虑下面虚拟继承，继承自Point：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>) : <span class="built_in">Point</span>(x, y), _z(z) &#123;&#125;</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">const</span> Point3d &amp;rhs) : <span class="built_in">Point</span>(rhs), _z(rhs._z) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Point3</span>();</span><br><span class="line">    Point3d&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Point3d&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _z; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  传统的constructor扩充并没有用，因为virtual base class的共享性之故：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不合法</span></span><br><span class="line"><span class="function">Point3d* <span class="title">Point3d::Point3d</span><span class="params">(Point3d *<span class="keyword">this</span>, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Piont3d = __vtbl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d__Point = __vtbl_Point3d_Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_z = rhs._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  看出什么错误了吗？  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Point3d -- virtual --- Point</span><br><span class="line">Vertex -- virtual --- Point</span><br><span class="line">Vertex3d -- public --- Point3d</span><br><span class="line">Vertex3d -- public --- Vertex</span><br><span class="line">pVertex -- public --- Vertex3d</span><br></pre></td></tr></table></figure>
  Vertex的constructor必须调用Point constrcutor。然而当Point3d和Vertex为Vertex3d的subobjects时，则调用操作不一定发生。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point3d的constructor扩充内容</span></span><br><span class="line"><span class="function">Point3d* <span class="title">Point3d::Point3d</span><span class="params">(Point3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__most_derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d = __vtbl_Point3d;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point3d__Point = __vtbl_Point3d__Point;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_Z = ths._z;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  Vertex3d调用Point3d和Vertex的constructor时，会把__most_derived参数设为false，于是就压制了对两个constructors中对Point constructor的调用操作。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vertex3d* <span class="title">Vertex3d::Vertex3d</span><span class="params">(Vertex3d *<span class="keyword">this</span>, <span class="keyword">bool</span> __most_derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__most_derived != <span class="literal">false</span>) </span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point3d::<span class="built_in">Point3d</span>(<span class="literal">false</span>, x, y, z);</span><br><span class="line">        <span class="keyword">this</span>-&gt;Vertex::<span class="built_in">Vertex</span>(<span class="literal">false</span>, x, y);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  这个策略得以保持语义正确。当定义一个<strong>Point3d</strong>时，Point3d constructor可以正确调用Point virtual base class subobject。当定义<strong>Vertex3d时</strong>时，Vertex3d constructor正确调用Point constructor。Point3d和Vertex的constructor不会对Point调用。这种把一个constructor分裂为二的做法，可以带来速度的提升。？？</li>
</ul>
<h5 id="vptr初始化语意学（The-Semantics-of-the-vptr-Initialization）"><a href="#vptr初始化语意学（The-Semantics-of-the-vptr-Initialization）" class="headerlink" title="vptr初始化语意学（The Semantics of the vptr Initialization）"></a>vptr初始化语意学（The Semantics of the vptr Initialization）</h5><ul>
<li>当我们定义PVertex object时，constructors的调用顺序是：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Point</span>(x, y);</span><br><span class="line"><span class="built_in">Point3d</span>(x, y, z);</span><br><span class="line"><span class="built_in">Vertex</span>(x, y, z);</span><br><span class="line"><span class="built_in">Vertex3d</span>(x, y, z);</span><br><span class="line"><span class="built_in">PVertex</span>(x, y, z);</span><br></pre></td></tr></table></figure>
</li>
<li>假设继承体系中每个class都定义一个virtual function size()，返回class的大小。而这个继承体系中的每个constructors内含调用操作：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Point3d::<span class="built_in">Point3d</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) : _x(x), _y(y), _z(z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (spyOn)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Within Point3d::Piont3d()&quot;</span> &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; <span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <strong>在一个class的constructor（和destructor）中，经由构造中的对象来调用virtual function，其函数实例是在此class中有作用的那个</strong>。如果调用操作限制必须在constructor（或destructor）中直接调用，那么答案十分明显；将每个调用以静态方式决议它，不要用到虚拟机制。如果是在Point3d constructor中，就显式调用Point3d::size()。  </li>
<li>如果size()之中又调用一个virtual function，这个调用也必须决议为Point3d的函数实例。因此在执行constructor时，必须限制一组virtual functions候选名单。为了控制class中有所作用的函数，编译系统需要控制住vptr的初始化和设定操作，vptr初始化操作怎么处理，得视vptr在constructor中应该在什么时候被初始化而定。 <strong>在base class constructors调用操作之后，在member iniaialization list中members初始化操作前</strong>。它解决了class中限制一组virtual functions名单的问题。如果每个constructor都一直等待其base class constructors执行完毕之后才设定对象的vptr，那么每次都能调用正确的virtual function实例。<br><font color=red>constructor的执行算法</font>通常如下：<ol>
<li><strong>在derived class constructor中，所有virtual base classes及上层base class的constructors会被调用</strong>。</li>
<li>**对象的vptr(s)会被初始化，指向相关virtual table(s)**。</li>
<li><strong>如果有member initialization list，将在constructor内扩展开来</strong>。这在vptr被设定之后才做，以免virtual member function被调用。</li>
<li><strong>最后才执行程序员所提供的代码</strong>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PVertex::<span class="built_in">PVertex</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z) : _next(<span class="number">0</span>), <span class="built_in">Vertex3d</span>(x, y, z), <span class="built_in">Point</span>(x, y)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (spyOn)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Within PVertex::PVertex()&quot;</span> &lt;&lt; <span class="string">&quot;size: &quot;</span> &lt;&lt; <span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="function">PVertex* <span class="title">PVertex::PVertex</span><span class="params">(PVertex *<span class="keyword">this</span>, <span class="keyword">bool</span> __most__derived, <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 条件式地调用virtual base constructor</span></span><br><span class="line">    <span class="keyword">if</span> (__most__derived != <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;Point::<span class="built_in">Point</span>(x, y);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 无条件调用上一层base</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex3d::<span class="built_in">Vertex3d</span>(x, y, z);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将相关的vptr初始化</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_PVertex = __vtbl_PVertex;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__vptr_Point__PVertex = __vtbl_Point__PVertex;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 程序员缩写的代码</span></span><br><span class="line">    <span class="keyword">if</span> (spyOn)</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Within PVertex::PVertex()&quot;</span> </span><br><span class="line">            &lt;&lt; <span class="string">&quot;size: &quot;</span></span><br><span class="line">            <span class="comment">// 经由虚拟机制调用</span></span><br><span class="line">            &lt;&lt; (*<span class="keyword">this</span>-&gt;__vptr__PVertex[<span class="number">3</span>].faddr)(<span class="keyword">this</span>)</span><br><span class="line">            &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 传回被构造的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>下面是vptr必须被设定的两种情况：<ol>
<li>当一个完整的对象被构造起来时。如果我们声明一个Point对象，则Point constructor必须设定其vptr。</li>
<li>当一个subobject constructor调用一个virtual function（不论是直接调用还是间接调用）时。<br>p218</li>
</ol>
</li>
</ul>
<h4 id="5-3-对象复制语意学（Object-Copy-Semantics）"><a href="#5-3-对象复制语意学（Object-Copy-Semantics）" class="headerlink" title="5.3 对象复制语意学（Object Copy Semantics）"></a>5.3 对象复制语意学（Object Copy Semantics）</h4><ul>
<li><p>当我们设计一个class，并以一个class object指定给另一个class object时，我们有三种<font color=red>选择</font>：</p>
<ol>
<li><strong>什么都不做，施行默认行为</strong>。</li>
<li><strong>提供一个explicit copy assignment operator</strong>。</li>
<li><strong>显式地拒绝把一个class object指定给另一个class object</strong>。</li>
</ol>
<p>  当选择不准将一个class object指定给另一个class object时，只要<strong>把copy assignment operator声明为priavte，并且不提供其定义</strong>就可以了。设为private，就不再允许于任何地点（除了在<font color=red>member functions</font>以及该<font color=red>class的friends之中</font>）做<font color=red>赋值</font>（<font color=green>assign</font>）操作。</p>
</li>
<li><p>需要验证copy assignment operator的语意，利用Point class来帮助讨论：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Piont</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// ... 没有virtual function</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对于默认行为是否足够，如果要支持的只是一个简单的拷贝操作，那么默认行为不但足够而且有效率，而且没有理由再自己提供一个copy assignment operator。<br>  如果不对Point供应一个copy assignment operator，光是以来memberwise copy，编译器不会产生实例。编译器不会产生出一个实例，因为<strong>class有了bitwise copy语义，所以implicit copy assignment operator被视为毫无用处，也不会被合成出来</strong>。copy assignment operators并不表示bitwisecopy semantics是nontrivial，只有nontrivial instances才会被合成出来。因此，对于Point class，这样的赋值操作：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point a, b;</span><br><span class="line">...</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure>
<p>  由bitwise copy完成，期间并没有copy assignment oeprator被调用。注意，我们还是可能提供一个copy constructor，为的是把<font color=green>name return value</font>（<font color=red>NRV</font>）优化打开。copy constructor的出现不意味着也也要提供一个copy assignment operator。</p>
</li>
<li><p>如果该operator在继承之下呢？</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Point&amp; Point::<span class="keyword">operator</span>=(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    _x = p._x;</span><br><span class="line">    _y = p._y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚拟继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Point &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果没有定义copy assignmnet operator，根据合成规则的第二项和第四项。合成的东西看起来这样：</span></span><br><span class="line"><span class="keyword">inline</span> Point3d&amp; Point3d::<span class="keyword">operator</span>=(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Piont3d &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// call base class</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// memberwise copy the derived class members</span></span><br><span class="line">    _z = p._z;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  它缺乏一个member assignment list（平行于member initialization list的东西）。缺少copy assignment list，看起来是小事，但如果没有它，编译器一般就没有办法压抑上一层base class的copy operators被调用。例如Vertex copy operator，Vertex虚拟继承自Point：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Vertex : virtual public Point</span></span><br><span class="line"><span class="keyword">inline</span> Vertex&amp; Vertex::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    _next = v._next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从Point3d和Vertex派生Vertex3d，下面是其copy assignment operator</span></span><br><span class="line"><span class="keyword">inline</span> Vertex3d&amp; Vertex3d::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex3d &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::<span class="keyword">operator</span>=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::oeprator=(v);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  编译器怎么能在Point3d和Vertex的copy assignment operators中压抑Point的copy assignment operators呢？有一种方法可以保证most-derived class会（完成）virtual base class subobject的copy行为，就是在derived class的copy assignment operator函数实例的最后，显式调用oeprator：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Vertex3d&amp; Vertex3d::<span class="keyword">operator</span>=(<span class="keyword">const</span> Vertex3d &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;Point3d::oeprator=(v);</span><br><span class="line">    <span class="keyword">this</span>-&gt;Vertex::oeprator=(v);</span><br><span class="line">    <span class="comment">// must place this last if your compiler does</span></span><br><span class="line">    <span class="comment">// not suppress intermediate class invocations</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;Point::<span class="keyword">operator</span>=(v);</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  它不能够省略subobjects的多重拷贝，但可以保证语意。建议尽可能不要允许一个virtual base class的拷贝操作，甚至一个比较奇怪的建议：不要在任何virtual base class中声明数据。</p>
</li>
</ul>
<h4 id="5-4-对象的效能（Object-Efficiency）"><a href="#5-4-对象的效能（Object-Efficiency）" class="headerlink" title="5.4 对象的效能（Object Efficiency）"></a>5.4 对象的效能（Object Efficiency）</h4><ul>
<li>测试。</li>
</ul>
<h4 id="5-5-析构语意学（Semantics-of-Destruction）"><a href="#5-5-析构语意学（Semantics-of-Destruction）" class="headerlink" title="5.5 析构语意学（Semantics of Destruction）"></a>5.5 析构语意学（Semantics of Destruction）</h4><ul>
<li><p>如果class没有定义destructor，那么只有在class内含的member object（抑或是class的base class）拥有destructor的情况下，编译器才会自动合成一个来。当从父类派生子类（即使是一种虚拟派生关系）时，如果没有声明一个estructor，编译器就没有必要合成一个destructor。没有任何理由说在delete一个对象之前得先讲内容清除干净。在一个对象的生命之前，没有任何class使用层面的程序操作是必要的，因此也就不需要要给destructor。  </p>
</li>
<li><p>一个由程序员定义的<font color=red><strong>destructor被扩展的方式类似constructors被扩展的方式</strong></font>，但顺序相反：</p>
<ol>
<li><strong>destructor的函数本体现在被执行，也就是说vptr会在程序员的代码执行前被重设（reset）</strong>。</li>
<li><strong>如果class拥有member classs objects，而后者会拥有destructors，那么它们会以生命顺序的相反顺序被调用</strong>。</li>
<li><strong>如果object内含一个vptr，那么首先重设（reset）相关的vtbl。指向适当的base class的vtbl</strong>。</li>
<li><strong>如果由任何直接的（上一层）nonvirtual base classes拥有destrucotr，它们会以其声明顺序的相反顺序被调用</strong>。</li>
<li><strong>如果有任何virtual base classes拥有destructor，那么也会以原来的构造顺序的相反顺序被调用</strong>。</li>
</ol>
</li>
<li><p>跟constructor一样，对destructor的一种最佳实现策略就是维护两份destrucotr实例：</p>
<ol>
<li>一个complete object实例，先设定好vptr(s)，并调用virtual base classes destructors。</li>
<li>一个base class subobject实例：除非在destructor函数中调用一个virtual function，否则不会调用virtual base class destructors并设定vptr。</li>
</ol>
</li>
<li><p><font color=red>一个object的声明结束于其destructor开始执行之时</font>。    </p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0-Function%E8%AF%AD%E6%84%8F%E5%AD%A6/" class="post-title-link" itemprop="url">第四章 Function语意学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-12 22:55:35" itemprop="dateCreated datePublished" datetime="2020-06-12T22:55:35+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-06/" itemprop="url" rel="index"><span itemprop="name">2019.06</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#4.1-member%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">4.1 Member的各种调用方式</a><ul>
<li><a href="#nonstatic-member-functions%EF%BC%88%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%89">Nonstatic Member Functions（非静态成员函数）</a><ul>
<li><a href="#%E5%90%8D%E7%A7%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%EF%BC%88name-mangling%EF%BC%89">名称的特殊处理（Name Mangling）</a></li>
</ul>
</li>
<li><a href="#virtual-member-functions%EF%BC%88%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%89">Virtual Member Functions（虚拟成员函数）</a></li>
<li><a href="#static-member-functions%EF%BC%88%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%89">Static Member Functions（静态成员函数）</a></li>
</ul>
</li>
<li><a href="#4.2-virtuar-member-functions%EF%BC%88%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%89">4.2 Virtuar Member Functions（虚拟成员函数）</a><ul>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84virtual-functions">多重继承下的Virtual Functions</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%9A%84virtual-functinos">虚拟继承下的Virtual Functinos</a></li>
</ul>
</li>
<li><a href="#4.3-%E5%87%BD%E6%95%B0%E7%9A%84%E6%95%88%E8%83%BD">4.3 函数的效能</a></li>
<li><a href="#4.4-%E6%8C%87%E5%90%91member-function%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%88pointer-tomember-functions%EF%BC%89">4.4 指向Member Function的指针（Pointer-toMember Functions）</a><ul>
<li><a href="#%E6%94%AF%E6%8C%81%E2%80%9C%E6%8C%87%E5%90%91virtual-member-functions%E2%80%9D%E7%9A%84%E6%8C%87%E9%92%88">支持“指向Virtual Member Functions”的指针</a></li>
<li><a href="#%E5%9C%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B9%8B%E4%B8%8B%EF%BC%8C%E6%8C%87%E5%90%91member-functions%E7%9A%84%E6%8C%87%E9%92%88">在多重继承之下，指向Member Functions的指针</a></li>
<li><a href="#%E2%80%9D%E6%8C%87%E5%90%91member-functions%E4%B9%8B%E6%8C%87%E9%92%88%E7%9A%84%E6%95%88%E7%8E%87">”指向Member Functions之指针的效率</a></li>
</ul>
</li>
<li><a href="#4.5-inline-functions">4.5 Inline Functions</a><ul>
<li><a href="#%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%EF%BC%88formal-arguments%EF%BC%89">形式参数（Formal Arguments）</a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88local-variables%EF%BC%89">局部变量（Local Variables）</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<ul>
<li>看以下代码,会发生什么:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Point3d obj;</span><br><span class="line">POint3d *ptr = &amp;obj;</span><br><span class="line">obj.<span class="built_in">normalize</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">normalize</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// declaretion</span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::normalie</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="built_in">magnitude</span>();</span><br><span class="line">    Point3d normal;</span><br><span class="line">    normal._x = _x/mag;</span><br><span class="line">    normal._y = _y/mag;</span><br><span class="line">    normal._z = _z/mag;</span><br><span class="line">    <span class="keyword">return</span> normal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point3d::magnitude</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_x * _x + _y * _y + _z * _z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  答案是不知道。<strong>C++支持三种类型的member function：static、nonstatic和virtual</strong>，我们蹦确定normalize()和magnitude()两函数是否为virtual或nonvirtual，但可以确定它不是static。因为<ul>
<li>它直接存取nonstatic数据。</li>
<li>它被声明为const。是的，static member functions不可能做到这两点。</li>
</ul>
</li>
</ul>
<h4 id="4-1-Member的各种调用方式"><a href="#4-1-Member的各种调用方式" class="headerlink" title="4.1 Member的各种调用方式"></a>4.1 Member的各种调用方式</h4><ul>
<li><p><strong>原始的“C with Class”只支持nonstaic member functions</strong>。它收到很多质疑：</p>
<blockquote>
<p>有一种常见的观点，认为virtual functions只不过是一种蹩脚的函数指针，没有什么用……其意思主要就是，virtual functions是一种没有效能的形式。</p>
</blockquote>
</li>
<li><p>Static member functions是最后被引入的一种函数类型。</p>
</li>
</ul>
<h5 id="Nonstatic-Member-Functions（非静态成员函数）"><a href="#Nonstatic-Member-Functions（非静态成员函数）" class="headerlink" title="Nonstatic Member Functions（非静态成员函数）"></a>Nonstatic Member Functions（非静态成员函数）</h5><ul>
<li>C++的设计准则之一就是：static member function至少必须和一般的nonmember function有相同的效率。然而，举个例子：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nonmember</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">magnitude3d</span><span class="params">(<span class="keyword">const</span> Point3d *_this)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(_this-&gt;_x * _this-&gt;_x + </span><br><span class="line">                _this-&gt;_y * _this-&gt;_y +</span><br><span class="line">                _this-&gt;_z * _this-&gt;_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  乍见似乎member function比较没有效率，它经由参数取坐标，而member function却直截了当用坐标成员。然而<font color=red><strong>实际上member function被内化为nonmember的形式</strong></font>。下面是转化步骤：<ol>
<li><strong>改写函数的signature（函数原型）以安插要给额外的参数到member function中，用以提供一个存取管道，使class object将此函数调用。这个额外的参数使this指针</strong>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-const nonstatic member</span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::magnitude</span><span class="params">(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 如果function是const</span></span></span><br><span class="line"><span class="function"><span class="comment">// const nonstatic member</span></span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::magnitude</span><span class="params">(<span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span></span><br></pre></td></tr></table></figure></li>
<li><strong>将每一个对nonstatic data member的存取操作变为经由this指针来存取</strong>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="keyword">this</span>-&gt;_x * <span class="keyword">this</span>-&gt;_x +</span><br><span class="line">                <span class="keyword">this</span>-&gt;_y * <span class="keyword">this</span>-&gt;_y +</span><br><span class="line">                <span class="keyword">this</span>-&gt;_z * <span class="keyword">this</span>-&gt;_z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>将member function重新写成一个外部函数。函数名经过“mangling”处理，使它在程序中成为独一无二的词汇：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="title">magnitude__7Point3dFv</span><span class="params">(<span class="keyword">register</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>开章的normalize()函数会转化成以下形式，假设声明了Pointe3d copy constructor，而named returned value（NRV）的优化也施行了：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++伪码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize__7Point3dFv</span><span class="params">(<span class="keyword">register</span> <span class="keyword">const</span> POint3d *<span class="keyword">const</span> <span class="keyword">this</span>, Point3d &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="keyword">this</span>-&gt;<span class="built_in">magniude</span>();</span><br><span class="line">    <span class="comment">// default constructor</span></span><br><span class="line">    __result.Point3d::<span class="built_in">Point3d</span>();</span><br><span class="line">    __result._x = <span class="keyword">this</span>-&gt;_x/mag;</span><br><span class="line">    __result._y = <span class="keyword">this</span>-&gt;_y/mag;</span><br><span class="line">    __result._z = <span class="keyword">this</span>-&gt;_z/mag;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有效率的方式</span></span><br><span class="line"><span class="function">Pointe3d <span class="title">Point3d::normalize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="built_in">magnitude</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Point3d</span>(_x/mag, _y/mag, _z/mag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize__7Point3dFv</span><span class="params">(<span class="keyword">register</span> <span class="keyword">const</span> Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, Point3d &amp;__result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="keyword">this</span>-&gt;<span class="built_in">magnitude</span>();</span><br><span class="line">    <span class="comment">// __result return value</span></span><br><span class="line">    __result.Point3d::<span class="built_in">Point3d</span>(<span class="keyword">this</span>-&gt;_x/mag, <span class="keyword">this</span>-&gt;_y/mag, <span class="keyword">this</span>-&gt;_z/mag);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="名称的特殊处理（Name-Mangling）"><a href="#名称的特殊处理（Name-Mangling）" class="headerlink" title="名称的特殊处理（Name Mangling）"></a>名称的特殊处理（Name Mangling）</h6><ul>
<li>一般而言，member的名称前面会被加上class名称，形成独一无二的命名：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> ival; ... &#125;;</span><br><span class="line"><span class="comment">// ival可能为</span></span><br><span class="line"><span class="comment">// ival__3Bar</span></span><br></pre></td></tr></table></figure>
  为什么这么做呢？考虑这样的派生操作:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123; <span class="keyword">public</span>: <span class="keyword">int</span> ival; ... &#125;;</span><br><span class="line"><span class="comment">// Foo对象内部结合了base class和derived class两者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ival__3Bar;</span><br><span class="line">    <span class="keyword">int</span> ival__3Foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  不管要处理哪个ival，通过<font color=red>name mangling</font>都能指出来。由于member functions可能被重载（overloaded），所以更需要广泛的mangling手法：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转化为：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">X__5PointFf</span><span class="params">(<span class="keyword">float</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X__5PointFv</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>把参数和函数名称编码在一起，编译器就在不同的编译模块之间达成了一种有限形式的<font color=red>类型检验</font><strong>。如果两个实例拥有独一无二的name mangling，任何不正确的调用操作在链接时会因无法resolved而失败。这就是确保<font color=red>类型安全的链接行为</font>（<font color=green>type-safe linkage</font>）。它只能捕捉到函数的标记（</strong>signature，函数名称+参数个数+参数类型）错误</strong>，而返回类型错误检查不出来。而一种demangling工具，用来拦截名称并转换回去。它向使用者隐藏了内部名称，使得出错时能得到一个友好的信息返回。</li>
</ul>
<h5 id="Virtual-Member-Functions（虚拟成员函数）"><a href="#Virtual-Member-Functions（虚拟成员函数）" class="headerlink" title="Virtual Member Functions（虚拟成员函数）"></a>Virtual Member Functions（虚拟成员函数）</h5><ul>
<li><strong>如果normalize()是</strong>virtual member function，那么以下调用：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">normalie</span>();</span><br></pre></td></tr></table></figure>
  会被转化为：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>])(ptr);</span><br></pre></td></tr></table></figure>
  其中：<ul>
<li><strong>vptr由编译器产生，一个指向vtbl的指针</strong>。</li>
<li><strong>1是索引值</strong>。</li>
<li><strong>ptr是this指针</strong>。</li>
</ul>
</li>
<li>类似道理，<strong>如果magnitude()也是</strong>virtual function，它在normalize()之中的调用操作被转换如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register float mag = magnitude();</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">float</span> mag = (*<span class="keyword">this</span>-&gt;vptr[<span class="number">2</span>])(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
  此时，由于Point3d::magnitude()是在Point3d::normalize()中被调用的，而后者已经由虚拟机之而决议（reslove）妥当，<font color=red>显式的调用Point3d实例会比较有效率</font>，并因此压制由于虚拟机之而产生的不必要重复调用操作：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// explicitly invocation</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">float</span> mag = Point3d::<span class="built_in">magnitude</span>();</span><br></pre></td></tr></table></figure>
  <strong>如果magnitude()声明为inline函数，会更有效率。因为使用class scope operator显式调用virtual function，resolve方式和nonstatic member function一样</strong>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">float</span> mag = <span class="built_in">magnitude__7Point3dFv</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
  这时对于以下调用：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Point3d obj;</span></span><br><span class="line">obj.<span class="built_in">normalize</span>();</span><br></pre></td></tr></table></figure>
  如果编译器转化为：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*obj.vptr[<span class="number">1</span>])(&amp;obj);</span><br></pre></td></tr></table></figure>
  <strong>虽然语义正确，却没有必要</strong>。所以上述经由obj调用的函数实例只可以是<font color=red>Point3d:normalize()</font>。”经由class object调用virtual function”，这种操作总是被编译器像对待一般nonstatic member function一样resolved：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">normalize__7Point3Fv</span>(&amp;obj);</span><br></pre></td></tr></table></figure>
  这项工程的另一个利益是，<font color=red><strong>virtual function的inline函数实例可以被扩展（expanded）开来，因而提供极大的效率利益</strong></font>。</li>
</ul>
<h5 id="Static-Member-Functions（静态成员函数）"><a href="#Static-Member-Functions（静态成员函数）" class="headerlink" title="Static Member Functions（静态成员函数）"></a>Static Member Functions（静态成员函数）</h5><ul>
<li>如果Point3d::normalize()是一个static member function，下面两个调用的转化：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="built_in">normalize</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">normalize</span>();</span><br><span class="line"><span class="comment">// 将被转化为一般的nonmember函数调用</span></span><br><span class="line"><span class="comment">// obj.normalize();</span></span><br><span class="line"><span class="built_in">normalize__7Point3dSFv</span>();</span><br><span class="line"><span class="comment">// ptr-&gt;nomalize();</span></span><br><span class="line"><span class="built_in">normalize__7Point3dSFv</span>();</span><br></pre></td></tr></table></figure>
  在引进static member functions之前，你很少看到这种怪异写法：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Point3d*)<span class="number">0</span>)-&gt;<span class="built_in">object_count</span>();</span><br></pre></td></tr></table></figure>
  在引进<font color=red>static member functions</font>之前，C++语言要求member functions必须<strong>经由class的object来调用</strong>。而实际上，<strong>只有当一个或多个nonstatic data members在member function中被直接存取时，才需要class object</strong>。如果没有任何一个members被直接存取，就不需要this指针，也就不需要通过一个class object来调用member function。<br>  这一来存取static data members时产生了一些不规则性。如果class的static data member声明为nonpublic，那么就必须提供member functions来存取member。这时很显然，虽然补考class object来存取static member，但<strong>存取函数却得绑定一个class object上</strong>。<br>  独立于class object之外的存取操作很重要，尤其在没有class object存在的情况。<font color=red><strong>程序方法上的解决之道</strong></font>是把0强制转换为一个class指针：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object_count</span>((Point3d*)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
  <font color=red><strong>至于语言层面上的解决之道</strong></font>，是引进的static member functions。<font color=red>它的主要特性是没有this指针</font>。以下是次要特性：<ul>
<li><strong>它不能直接存取class中的nonstatic members</strong>。</li>
<li><strong>它不能被声明为const、volatile或virtual</strong>。</li>
<li><strong>它不需要经由class object才被调用——虽然大部分时候它是这样被调用的</strong>。</li>
</ul>
</li>
<li>如果去一个static member funciton的地址，获得的将是在内存中的位置，也就是其地址。由于static member function没有this指针，所以地址类型不是一个指向class member funciton的指针，而是一个<font color=red>nonmember函数指针</font>：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;Point3d::<span class="built_in">object_count</span>();</span><br><span class="line"><span class="comment">// 会得到数值，类型是</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 而不是</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(Point3d::*)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
  因为static member function缺乏this指针，所以差不多等同于nonmember function。它有个意想不到的好处：<strong>成为callback函数</strong>。</li>
</ul>
<h4 id="4-2-Virtuar-Member-Functions（虚拟成员函数）"><a href="#4-2-Virtuar-Member-Functions（虚拟成员函数）" class="headerlink" title="4.2 Virtuar Member Functions（虚拟成员函数）"></a>4.2 Virtuar Member Functions（虚拟成员函数）</h4><ul>
<li><p>我们已经知道了virtual function的一般实现模型：每个class中有个vtbl，其中包含着virtual function的地址，而每个object有vptr，指向vtbl的存在。</p>
</li>
<li><p>为了支持virtual function机制，对于多态对象必须有某种形式上的<font color=red>执行期类型判断法</font>（<font color=green>runtime type resolution</font>）。也就是下面调用需要ptr在执行期有某些信息，才能找到并调用z()：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br></pre></td></tr></table></figure>
<p>  这份信息不能加在ptr身上，它增加了空间负担，即使不使用多态；第二它打断了与C程序间的链接兼容性。我们需要一个更好的规范，一个以class的使用为基础，而不在乎关键词是class或struct的规范。并且必须在<font color=red>执行期多态</font>（<font color=green>runtime polymorphism</font>）时才需要这份信息</p>
</li>
<li><p>C++中多态表示以一个public base class的指针（reference），寻址出一个derived class object的意思。经由指针，可以在程序中任何地方采用public derived类型，这种多态形式是<font color=red>消极的</font>（<font color=green>passive</font>），可以在编译期完成，除了virtual base class的情况。当指出的对象被使用时，才变成<font color=red>积极的</font>（<font color=green>active</font>）。</p>
</li>
<li><p>在<font color=green>runtime type identification</font>（<font color=red>RTTI</font>）性质在1993年被引入前，C++对于积极多态（active polymorphsim）的唯一支持，<strong>就是对virtual function call的resolution操作。有了RTTI，能够在执行期查询一个多态的pointer或多态的reference了</strong>：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 积极多态的例子</span></span><br><span class="line">ptr-&gt;<span class="built_in">z</span>();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (Point3d *p3d = <span class="keyword">dynamic_cast</span>&lt;Point3d*&gt;(ptr))</span><br><span class="line">    <span class="keyword">return</span> p3d-&gt;_z;</span><br></pre></td></tr></table></figure>
<p>  z()是一个virtula function。是什么信息让我们在执行期调用正确呢？，我们需要知道：</p>
<ul>
<li><strong>ptr所指对象的真实类型</strong>。</li>
<li><strong>z()实例的位置，以便能够调用它</strong>。</li>
</ul>
<p>  实现上，可以在class object身上增加两个members：</p>
<ol>
<li><strong>一个字符串或数字</strong>，表示class的类型；</li>
<li><strong>一个指针</strong>。指向表格，表格中有个virtual function的执行期地址。</li>
</ol>
<p>  表格中的virtual functions地址是怎么建构起来的呢？<strong>virtual function（可由object被调用）在编译期获知</strong>。这个地址是固定的，执行期不增添也不替换。完全由编译器掌控，不需要执行期介入。而<strong>执行期只是备妥了函数地址</strong>，并未被找到。找到那些地址。两个步骤完成任务：</p>
<ol>
<li><font color=red><strong>为了找到表格，class object被安插了编译器内部产生的指针，指向该表格</strong></font>。</li>
<li><font color=red><strong>为了找到函数地址，每个virtual function被指派为一个表格索引值</strong></font>。</li>
</ol>
<p>  以上的工作都由编译器完成。<font color=red><strong>执行期要做的，只是在特定的virtual table slot中激活virtual funciton</strong></font>。  </p>
<p>  一个class只有一个vtbl。每个table内含对应object的active virtual functions函数实例的地址，这些active virtual functions包括：</p>
<ul>
<li><strong>class所定义的函数实例</strong>。它会overriding存在的base class virtual function函数实例。</li>
<li><strong>继承自base class的函数实例</strong>。这是在derived class决定不改写virtual function时才出现的情况。</li>
<li><strong>一个pure_virtual_called()函数实例</strong>。</li>
</ul>
</li>
<li><p>每个virtula function都被指派一个固定的索引值：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Point&amp; <span class="title">mult</span><span class="params">(<span class="keyword">float</span>)</span> </span>= <span class="number">0</span>; <span class="comment">// puree virtual function</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">float</span> _x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  virtual destructor被指派slot 1，而mult()被指派slot2，y()被指派slot3，z()被指派slot4。在单一继承体系中，virtual<br>  fucntion机制行为十分良好，有效率且容易塑造出模型。而在多重继承或虚继承中，对virtual functinos的支持就没那么好了。</p>
</li>
</ul>
<h5 id="多重继承下的Virtual-Functions"><a href="#多重继承下的Virtual-Functions" class="headerlink" title="多重继承下的Virtual Functions"></a>多重继承下的Virtual Functions</h5><ul>
<li><p>多重继承中支持virtual functions，<font color=red>复杂度围绕在<strong>第二个及后继base class</strong>身上，以及<strong>”必须在执行期调整this指针“</strong>这一点</font>:</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Derived -- public --- Base1</span><br><span class="line">Derived -- public --- Base2</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>();</span><br><span class="line">    virtula ~<span class="built_in">Base1</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speakClearly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base1* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Base1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base2</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Base2* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Base2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Derived* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> data_Derived;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它的困难度主要体现在Base2 subobject身上，有三个问题需要解决：*<font color=red>（1）virtual destructor*</font>，<font color=red><em>（2）被继承的Base2::mumble()</em></font>，<font color=red><em>（3）clone()函数实例</em></font>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pbase2 = nwe Derived;</span><br><span class="line"><span class="comment">// 编译时期代码</span></span><br><span class="line"><span class="comment">// 转移以支持第二个base class</span></span><br><span class="line">Derived *temp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = temp ? temp + <span class="built_in"><span class="keyword">sizeof</span></span>(Base1) : <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>  如果没有这样的调整，任何非多态的应用都将失败：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pbase2被指定一个Derived对象，这也应该没有问题</span></span><br><span class="line">pbase2-&gt;data_Base2;</span><br><span class="line"><span class="comment">// 当程序员要删除pbase2所指的对象时</span></span><br><span class="line"><span class="comment">// 需要调用正确的virtual destructor函数实例，pbase2可能需要调整</span></span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></table></figure>
<p>  一般规则时，<strong>经由第二或后继base class的指针（reference）来调用derived class virtual funciton。其所连带的必要this指针调整操作，必须在执行期完成</strong>。也就是offset的大小，offset加到this指针上的程序代码，必须由编译器在某个地方插入。</p>
<blockquote>
<p>cfont编译器中的方法是将vtbl加大，容纳所需的this指针，每个virtual table slot不再是指针，而是一个集合体，内含<font color=red>offset</font>以及地址：</p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*pbase2-&gt;vptr[<span class="number">1</span>])(pbase2);</span><br><span class="line"><span class="comment">// 改变为</span></span><br><span class="line">(*pbase2-&gt;vptr[<span class="number">1</span>].faddr)(pbase2 + pbase2-&gt;vptr[<span class="number">1</span>].offset);</span><br></pre></td></tr></table></figure>
<p>  其中faddr内含virtual function地址，offset内含this指针调整值。这个做法的缺点是，不管什么virtual function都得进行offset调整。<br>  比较有效率的解决方法是利用所谓的thunk（是一段assembly代码）：<font color=red>（1）适当的offset调整this指针</font>，<font color=red>（2）跳到virtual function去</font>，如：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pbase2_dtor_thunk:</span><br><span class="line">    <span class="keyword">this</span> += <span class="built_in"><span class="keyword">sizeof</span></span>(base1);</span><br><span class="line">    Derived::~<span class="built_in">Derived</span>(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>  Thunk技术允许vtbl slot继续内含简单指针，因此空间上不需要任何负担。slots的地址直接指向virtual function，也可以指向相关的thunk。</p>
</li>
<li><p>调整this指针的的第二个额外负担就是，由于<font color=red>（1）经由derived class（或base class）调用</font>，<font color=red>（2）经由第二（或后继）base class调用</font>，同一函数在vtbl可能需要多次对应的slots：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base1 *pbase1 = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2 *pbase2 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="keyword">delete</span> pbase1;</span><br><span class="line"><span class="keyword">delete</span> pbase2;</span><br></pre></td></tr></table></figure>
<p>  两个相同的derived destructor，但需要不同的vtbl slots：</p>
<ol>
<li>pbase1不需要调整this指针。vtbl slot需放置真正destructor地址。</li>
<li>pbase2需要调整this指针。vtbl slot需相关的thunk地址。  </li>
</ol>
<p>  <strong>多重继承下，derived class内含n-1个额外的vtbl，n表示上一层base classes的个数</strong>。对于本例的Derived而言，会有两个vtbl被编译器产生出来：</p>
<ol>
<li><strong>一个主要实例，与Base1共享</strong>。</li>
<li><strong>一个次要实例，与Base2有关</strong>。</li>
</ol>
<p>  用以支持一个clas拥有多个vtbl的传统方法是，将每个tables以外部对象的形式产生出来，并给予独一无二的名称：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vtbl__Derived;          <span class="comment">// 主</span></span><br><span class="line">vtbl__Base2__Derived;   <span class="comment">// 次</span></span><br></pre></td></tr></table></figure>
<p>  于是当你将Derived对象地址指定给<font color=red><strong>Base1指针或Derived指针时</strong></font>，被处理的vtbl时主要表格vtbl__Derived。当讲Derived对下给你地址指定给<font color=red><strong>Base2指针时</strong></font>，被处理的vtbl时次要表格vtbl__Base2_Derived。</p>
</li>
<li><p>由于<font color=red>执行期链接器</font>（<font color=green>runime linkers</font>）的降临（可以支持动态共享函数库），符号名称的链接可能变得非常缓慢。为了调节执行期编译器的效率，Sun编译器将多个vtbl连锁为一个：<strong>指向次要表格的指针，可由主要表格表格名称加上一个offset获得，这样的策略下，每个class只有一个具名的vtbl</strong>。</p>
</li>
<li><p>有三种情况，第二或后继的base class会影响virtual functions的支持。</p>
<ol>
<li><font color=red><strong>通过一个指向第二个base class的指针，调用derived class virtual function</strong></font>。</li>
<li><font color=red><strong>通过一个指向derived class的指针，调用第二个base class中的一个继承而来的virtual funciton</strong></font>。</li>
<li><font color=red><strong>允许一个virtual function的返回值类型有所变化，可能是base type，也可能是publicly derived type</strong></font>。这一点经由Derived::clone()函数实例来说明。clone函数的Derived版本传回一个Derived class指针，默默地改写了它们两个base class函数实例。当通过指向第二个base class的指针来调用clone()时，this指针的offset问题诞生了：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base2 *pb1 = <span class="keyword">new</span> Derived;</span><br><span class="line"><span class="comment">// 调用Derived* Derived::clone()</span></span><br><span class="line"><span class="comment">// 返回值必须被调整，以指向Base2 subobject</span></span><br><span class="line">Base2 *pb2 = pb1-&gt;<span class="built_in">clone</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>当函数被认为足够小的时候，Sun编译器会提供一个split functions技术，以相同的算法产生两个函数。这样不论通过Base1指针还是通过Derived指针调用函数，都不需要调整返回值，而通过Base指针所调用的时另一个函数，并在返回前，为指针加上必要的offset。如果函数不小，会给函数中其中一个进入点，进入点需要三个指令。</p>
</li>
<li><p>thunk则是函数一开始先（1）调整this指针，然后才（2）执行程序员所写的函数码；无需调整函数调用操作。</p>
</li>
<li><p>Microsoft用adderss points来取代thunk策略，即overriding function期待获得的是引入该virtual function的class的地址，这就是函数的address point。</p>
</li>
</ul>
<h5 id="虚拟继承下的Virtual-Functinos"><a href="#虚拟继承下的Virtual-Functinos" class="headerlink" title="虚拟继承下的Virtual Functinos"></a>虚拟继承下的Virtual Functinos</h5><ul>
<li>考虑下面的virtual base class派生体系：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Point2d --- Point3d</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point2d</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> virtula Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>, <span class="keyword">float</span> = <span class="number">0.0</span>);</span><br><span class="line">    ~<span class="built_in">Point3d</span>();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  当一个virtual base class从另一个virtual base class派生而来，并且两者都支持virtual functions和nonstatic data members时，编译器对于virtual base class的支持简直就像进了了迷宫一样。所以建议是，<font color=red><strong>不要再一个virtual base class中声明nonstatic data members</strong></font>。如果这么做，你会距离复杂的深渊愈来愈近。</li>
</ul>
<h4 id="4-3-函数的效能"><a href="#4-3-函数的效能" class="headerlink" title="4.3 函数的效能"></a>4.3 函数的效能</h4><ul>
<li>下面这组测试，在编译器上计算两个3D点，其中用到一个nonmember friend function，一个member function，以及一个virtual member function。p170</li>
</ul>
<h4 id="4-4-指向Member-Function的指针（Pointer-toMember-Functions）"><a href="#4-4-指向Member-Function的指针（Pointer-toMember-Functions）" class="headerlink" title="4.4 指向Member Function的指针（Pointer-toMember Functions）"></a>4.4 指向Member Function的指针（Pointer-toMember Functions）</h4><ul>
<li>去一个nonstatic data member 的地址，得到的结果是该<font color=red>member在class布局中的bytes位置（再+1）</font>。可以想象它是一个不完整的值，它需要被绑定于某个class object的地址上，才能够被存取。<br>  取一个nonstatic member function的地址，如果该函数是nonvirtual，得到的结果是它在<font color=red>内存中真正的地址</font>。然而也是不完全的，也需要绑定于某个class object的地址上，才能够通过它调用函数。回顾一下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">double</span></span> (Point::*pmf)();</span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="built_in"><span class="keyword">double</span></span> (Point::*coord)() = &amp;Point::x;</span><br><span class="line">coord = &amp;Point::y;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">(origin.*coord)();</span><br><span class="line">(ptr-&gt;*coord)();</span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line">(coord)(&amp;origin);</span><br><span class="line">(<span class="built_in">coord</span>(ptr);</span><br></pre></td></tr></table></figure>
  <font color=red>指向member function的指针的声明语法，以及指向member selection运算符的指针，作用是作为this指针的空间保留着。这就是为什么static member function（没有this指针）的类型是”函数指针“，而不是指向member function的指针的原因。</font>    使用一个member function指针，如果并不用于virtual functions、virtual base class或multiple base classes等情况的画，并不会比使用一个nonmember function指针的成本更高。上述三种情况对于member function指针的类型及调用都太过复杂。对于没有以上情况的class而言，编译器可以为它们提供<strong>相同的效率</strong>。</li>
</ul>
<h5 id="支持“指向Virtual-Member-Functions”的指针"><a href="#支持“指向Virtual-Member-Functions”的指针" class="headerlink" title="支持“指向Virtual Member Functions”的指针"></a>支持“指向Virtual Member Functions”的指针</h5><ul>
<li>考虑下面程序片段：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">float</span></span> (Point::*pmf)() = &amp;Point::z;</span><br><span class="line">Point *ptr = <span class="keyword">new</span> Point3d;</span><br></pre></td></tr></table></figure>
  pmf，一个指向member function的指针，被设值为Point::z()（一个virtual function）的地址。如果由ptr调用z()，被调用的是Point3d::z()，但如果从pmf间接调用z()，正常运行吗？yes。<br>  对于一个virtual function取其地址，所能获得的只是一个索引值。对于一个指向member function的指针<font color=red>评估求值</font>（<font color=green>evaluated</font>），会因为该值由两种意义而复杂化，调用也有别于常规，<code>float (Point::*pmf)();</code>必须允许此函数能够寻址出nonvirtual x()和virtual z()两个member functions：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两者都可以指定给pmf</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point::x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Point::z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
  只不过其中一个代表<font color=red>内存地址</font>，另一个代表<font color=red>vtbl中的索引值</font>。为了使pmf能够（1）持有两种数值，（2）能区别代表内存地址还是vtbl中的索引值：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true is non-virtual invocation</span></span><br><span class="line"><span class="comment">// false is virtual invocation</span></span><br><span class="line">(((<span class="keyword">int</span>)pmf) &amp; ~<span class="number">127</span>) ? (*pmf)(ptr) : (*ptr-&gt;vptr[(<span class="keyword">int</span>)pmf](ptr));</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="在多重继承之下，指向Member-Functions的指针"><a href="#在多重继承之下，指向Member-Functions的指针" class="headerlink" title="在多重继承之下，指向Member Functions的指针"></a>在多重继承之下，指向Member Functions的指针</h5><ul>
<li>为了让member functions的指针能够支持多重继承和虚拟继承，设计了一个结构体：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">mptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> delta;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ptrtofunc   faddr;</span><br><span class="line">        <span class="keyword">int</span>         v_offset;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <strong>index和faddr分别持有vtbl slot和nonvirtual member function address（当index不指向vtbl时，设为-1）</strong>，像以下调用：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(ptr-&gt;*pmf)();</span><br><span class="line"><span class="comment">// 变成</span></span><br><span class="line">(pmf.index &lt; <span class="number">0</span>)</span><br><span class="line">? <span class="comment">// non-virtual invocation</span></span><br><span class="line">(*pm.faddr)(ptr)</span><br><span class="line">: <span class="comment">// virtual invocation</span></span><br><span class="line">(*ptr-&gt;vptr[pmf.index](ptr));</span><br></pre></td></tr></table></figure>
  这个方法受到的批评是，每个调用操作都得付出成本。Microsoft把检查拿掉，导入一个vcall thunk，它会选出并调用相关vtbl中的slot。    这个结构体的另一个副作用是，当传递一个不变值的指针给member function时，需要产生临时变量：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> Point3d <span class="title">foo</span><span class="params">(<span class="keyword">const</span> Point3d&amp;, Point3d (Point3d::*)())</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">const</span> Point3d &amp;p)</span> </span>&#123;</span><br><span class="line">    Point3d pt = <span class="built_in">foo</span>(p, &amp;Point3d::normal);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;Point3d::normal value</span></span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">10727417</span>&#125;</span><br><span class="line"><span class="comment">// 将变成</span></span><br><span class="line">__mptr temp = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">10727417</span>&#125;</span><br><span class="line"><span class="built_in">foo</span>(p, temp);</span><br></pre></td></tr></table></figure>
  回到开头那个结构体。delta字段表示this指针的offset值，而v_offset字段放的是一个virtual base class的vptr位置。如果vptr被编译器放在class对象起头处，这个字段就没必要了。它只在多重继承或虚拟继承情况下才有必然性。有些编译器根据不同的class特征提供多种memer functions的指向方式。如Microsoft：<ol>
<li><strong>单一继承实例</strong>（有vcall thnuk地址或是函数地址）；</li>
<li><strong>多重继承实例</strong>（有faddr和delta两个members）；</li>
<li><strong>虚拟继承实例</strong>（4个members）。</li>
</ol>
</li>
</ul>
<h5 id="”指向Member-Functions之指针的效率"><a href="#”指向Member-Functions之指针的效率" class="headerlink" title="”指向Member Functions之指针的效率"></a>”指向Member Functions之指针的效率</h5><ul>
<li>又是测试。p180</li>
</ul>
<h4 id="4-5-Inline-Functions"><a href="#4-5-Inline-Functions" class="headerlink" title="4.5 Inline Functions"></a>4.5 Inline Functions</h4><ul>
<li><p>一个Point class的加法运算符的可能实现内容：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> oint <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp;, <span class="keyword">const</span> Point&amp;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point &amp;lhs, <span class="keyword">const</span> Point &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Point new_pt;</span><br><span class="line">    new_pt._x = lhs._x + rhs._x;</span><br><span class="line">    new_pt._y = lhs._y + rhs._y;</span><br><span class="line">    <span class="keyword">return</span> new_pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void Point::x(float new_x) &#123; _x = new_x; &#125;</span></span><br><span class="line"><span class="comment">// float Point::x() &#123; return _x; &#125;</span></span><br><span class="line">new_pt.<span class="built_in">x</span>(lhs.<span class="built_in">x</span>() + rhs.<span class="built_in">x</span>());</span><br></pre></td></tr></table></figure>
<p>  以上通过将存取函数声明为inline，不但可以保持直接存取的高效率，而且加法运算符不再需要被声明为Point的friend。<br>  然而不能够强迫任何函数都变成inline。<font color=red>关键词inline（或者class declaration中的member function或friend function的定义）只是一项请求</font>。如果请求被接受，编译器就认为它可以用一个表达式（expression）合理地将这个函数扩展开来。cfront有一套复杂的测试方法，通常是用来计算assignments、function calls、virtual function calls等操作的次数。<strong>每个expression种类都有一个权值</strong>，<font color=red>inline函数的复杂度就以这些操作的总和来决定</font>。</p>
</li>
<li><p>一般处理一个inline函数有两个阶段：</p>
<ol>
<li><strong>分析函数定义，决定函数的intrinsic inline ability</strong>。如果函数因<font color=red>复杂度</font>或<font color=red>构建问题</font>不可成为inline，它会被转为一个static函数，并在被编译模块内产生对应的函数定义。在一个支持模块个别编译的环境中，编译器几乎没有什么权宜之计。理想情况下，链接器会将被产生出来的重复东西清理掉，但调试信息不会。UNIX环境的strip命令可以。</li>
<li><strong>真正的inline函数扩展操作是在调用的那一点上，这会带来参数的求值操作（ealuation）以及临时性对象的管理</strong>。</li>
</ol>
</li>
<li><p>在将要扩展的点上，cfront编译器中，<strong>inline函数如果只有一个表达式，而又有后续操作，则不会扩展开来</strong>。</p>
</li>
</ul>
<h5 id="形式参数（Formal-Arguments）"><a href="#形式参数（Formal-Arguments）" class="headerlink" title="形式参数（Formal Arguments）"></a>形式参数（Formal Arguments）</h5><ul>
<li><strong>inline扩展期间每个形式参数都被对应的实际参数取代。如果实际参数是一个常量表达式（constant expression），可以在替换之前完成求值操作（evaluations）；如果是个有副作用的表达式，那么需要引入临时性对象；如果既不是常量表达式，也不是带有副作用的表达式，那么就直接代替它。</strong>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j ? i : j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minval;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">2048</span>;</span><br><span class="line">    minval = <span class="built_in">min</span>(val1, val2);       <span class="comment">// 1</span></span><br><span class="line">    minval = <span class="built_in">min</span>(<span class="number">1024</span>, <span class="number">2048</span>);       <span class="comment">// 2</span></span><br><span class="line">    minval = <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">bar</span>() + <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line">minval = val1 &lt; val2 ? val1 : val2; <span class="comment">// 1</span></span><br><span class="line">minval = <span class="number">1024</span>;                      <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">int</span> t1;</span><br><span class="line"><span class="keyword">int</span> t2;</span><br><span class="line">minval = (t1 = <span class="built_in">foo</span>()), (t2 = <span class="built_in">bar</span>() + <span class="number">1</span>), t1 &lt; t2 ? t1 : t1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="局部变量（Local-Variables）"><a href="#局部变量（Local-Variables）" class="headerlink" title="局部变量（Local Variables）"></a>局部变量（Local Variables）</h5><ul>
<li>如果在inline定义中加入局部变量：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minval = i &lt; j ? i : j;</span><br><span class="line">    <span class="keyword">return</span> minval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> local_var;</span><br><span class="line">    itn minval;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    minval = <span class="built_in">min</span>(val1, val2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> local_var;</span><br><span class="line">    <span class="keyword">int</span> minval;</span><br><span class="line">    <span class="comment">// inlnie函数的局部变量处以mangling操作</span></span><br><span class="line">    <span class="keyword">int</span> __min_lv-minval;</span><br><span class="line">    minval = </span><br><span class="line">        (__min_lv-minval = </span><br><span class="line">            val1 &lt; val2 ? val1 : val2),</span><br><span class="line">            __min_lv_minval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  一般inline函数中的每个局部变量都必须放在<font color=red>封闭的区段</font>中，拥有独一无二的名称。因为如果inline函数以<font color=red>分离的多个式子</font>（<font color=green>discrete statements</font>）被扩展多次，那么只需要一组局部变量，就可以重复使用。<br>  inline函数中的局部变量，加上有副作用的参数，可能会<strong>导致大量临时性对象的产生</strong>。特别是如果以单一表达式（expression）被扩展多次的话：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">minval = <span class="built_in">min</span>(avl1, val2) + <span class="built_in">min</span>(<span class="built_in">foo</span>(), <span class="built_in">foo</span>()+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="comment">// 为局部变量产生临时变量</span></span><br><span class="line"><span class="keyword">int</span> __min_lv_minval_00;</span><br><span class="line"><span class="keyword">int</span> __min_lv_minval_01;</span><br><span class="line"><span class="comment">// 为放置副作用产生临时变量</span></span><br><span class="line"><span class="keyword">int</span> t1;</span><br><span class="line"><span class="keyword">int</span> t2;</span><br><span class="line">minval = ((__min_lv_minval_00 = </span><br><span class="line">            val1 &lt; val2 ? val1 : val2),</span><br><span class="line">            __min_lv_minval_00)</span><br><span class="line">          +</span><br><span class="line">          ((__min_lv_minval_01 = (t1 = <span class="built_in">foo</span>()),</span><br><span class="line">            (t1 = <span class="built_in">foo</span>() + <span class="number">1</span>),</span><br><span class="line">            t1 &lt; t2 ? t1 : t2),</span><br><span class="line">            __min_lv_minval__01);</span><br></pre></td></tr></table></figure>
  Inline函数对封装提供了必要的支持，可以有效存取class的nonpublic数据。它同时是C程序中大量使用#define的一个安全代替品——特别如果宏中的参数有副作用的话。然而被调用太多次的话，会产生大量的扩展码，使<strong>程序大小暴涨</strong>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/12/%E7%AC%AC%E4%B8%89%E7%AB%A0-Data%E8%AF%AD%E4%B9%89%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ichheit">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content=".27t_lBZ4oZgg_">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/12/%E7%AC%AC%E4%B8%89%E7%AB%A0-Data%E8%AF%AD%E4%B9%89%E5%AD%A6/" class="post-title-link" itemprop="url">第三章 Data语义学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-12 22:53:24" itemprop="dateCreated datePublished" datetime="2020-06-12T22:53:24+08:00">2020-06-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-09 16:26:07" itemprop="dateModified" datetime="2021-09-09T16:26:07+08:00">2021-09-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2019-06/" itemprop="url" rel="index"><span itemprop="name">2019.06</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#3.1-data-member%E7%9A%84%E7%BB%91%E5%AE%9A%EF%BC%88the-binding-of-a-data-member%EF%BC%89">3.1 Data Member的绑定（The Binding of a Data Member）</a></li>
<li><a href="#3.2-data-member%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%88data-member-layout%EF%BC%89">3.2 Data Member的布局（Data Member Layout）</a></li>
<li><a href="#3.3-data-member%E7%9A%84%E5%AD%98%E5%8F%96">3.3 Data Member的存取</a><ul>
<li><a href="#static-data-members">Static Data Members</a></li>
<li><a href="#nonstatic-data-members">Nonstatic Data Members</a></li>
</ul>
</li>
<li><a href="#3.4-%E2%80%9C%E7%BB%A7%E6%89%BF%E2%80%9D%E4%BA%8Edata-member">3.4 “继承”于Data Member</a><ul>
<li><a href="#%E5%8F%AA%E8%A6%81%E7%BB%A7%E6%89%BF%E4%B8%8D%E8%A6%81%E5%A4%9A%E6%80%81%EF%BC%88inheritance-without-polymorphism%EF%BC%89">只要继承不要多态（Inheritance without Polymorphism）</a></li>
<li><a href="#%E5%8A%A0%E4%B8%8A%E5%A4%9A%E6%80%81%EF%BC%88adding-polymorphism%EF%BC%89">加上多态（Adding Polymorphism）</a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%EF%BC%88multiple-inheritance%EF%BC%89">多重继承（Multiple Inheritance）</a></li>
<li><a href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF%EF%BC%88virtual-inheritance%EF%BC%89">虚拟继承（Virtual Inheritance）</a></li>
</ul>
</li>
<li><a href="#3.5-%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%88object-member-efficiency%EF%BC%89">3.5 对象成员的效率（Object Member Efficiency）</a></li>
<li><a href="#3.6-%E6%8C%87%E5%90%91data-members%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%88poniter-to-data-members%EF%BC%89">3.6 指向Data Members的指针（Poniter to Data Members）</a><ul>
<li><a href="#%E2%80%9C%E6%8C%87%E5%90%91members%E7%9A%84%E6%8C%87%E9%92%88%E2%80%9D%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%98">“指向Members的指针”的效率问题</a></li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->
<ul>
<li>一个空的class如：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeof X == 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> &#125;;                    <span class="comment">// sizeof X == 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;  <span class="comment">// sizeof X == 8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;  <span class="comment">// sizeof X == 8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;<span class="comment">// sizeof X == 12</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Y --- X</span><br><span class="line">Z --- X</span><br><span class="line">A --- Y</span><br><span class="line">A --- Z</span><br></pre></td></tr></table></figure>
  <font color=red><strong>事实上并不是空的，它有一个隐藏的1byte大小，那是编译器安插进去的一个char</strong></font>。有机器上Y、Z得出大小是8。这个值的大小和机器有关，也和编译器有关：<ol>
<li><strong>语言本身所造成的额外负担（overhead）</strong>。当语言支持virtual base classes时，会导致额外负担。在derived中，反映在某种形式的<font color=red>指针</font>身上，它或者指向virtual base class subobject，或指向一个相关表格；表格中是virtual base class subobject地址。</li>
<li><strong>编译器对于特殊情况所提供的优化处理</strong>。</li>
<li><strong>Allgnment的限制</strong>。大部分机器结构体大小会收到alignment的限制（内存对齐），使它们能够更有效率在内存中被存取。<font color=red>alignment就是将数值调整到某数的整数倍</font>。</li>
</ol>
</li>
<li><font color=red>Empty virtual base class</font>已经成为C++OO设计的一个特有术语了。他提供一个<font color=red>virtual interface</font>，没有定义任何数据。</li>
<li>对于class A竟然大小为12这个结果。记住，<font color=red><strong>一个virual base class sbobject只会在derived class中存在一份实例</strong></font>，不管它在继承体系中出现多少次。它的大小由以下决定：<ol>
<li><strong>被大家共享的唯一一个Class X，大小为1byte</strong>。</li>
<li><strong>Base class Y，减去因virtual base class X二配置的大小，结果是4bytes</strong>。</li>
<li><strong>class A自己的大小：0byte</strong>。</li>
<li><strong>class A的alignment数量</strong>。</li>
</ol>
</li>
<li>C++对象模型尽量以空间优化和存取速度优化的考虑来表现nonstatic data members，并且保持和C语言struct数据配置的兼容性。至于static data members，则被放置在程序的一个global data segment中，不会影响个别的class object大小。在程序之中，不管class被产生出多少个objects（经由直接产生或间接产生），static data members永远只存在一份实例。但是一个template class的static data members的行为稍有不同。</li>
<li>每一个class object必须有足够的大小容纳所有的nonstatic data members，因为它可能比你想象的还大，原因是：<ul>
<li><strong>编译器自动加上额外的data members</strong>，用以支持某些特性（virtual）。</li>
<li><strong>因为alignment的需要</strong>。</li>
</ul>
</li>
</ul>
<h4 id="3-1-Data-Member的绑定（The-Binding-of-a-Data-Member）"><a href="#3-1-Data-Member的绑定（The-Binding-of-a-Data-Member）" class="headerlink" title="3.1 Data Member的绑定（The Binding of a Data Member）"></a>3.1 Data Member的绑定（The Binding of a Data Member）</h4><ul>
<li>早期C++有两种防御性程序设计风格：<ol>
<li>把所有data members放在class声明处，以确保正确的绑定： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="comment">// ...etc</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>把所有的inline functions，不管大小都放在class声明之外： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// ...etc</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">Point3d::X</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 但这种<strong>设计风格在C++2.0之后就不存在了</strong>。这个古老的语言规则称为“<font color=red>member rwriting rule</font>”。大概意思是“一个inline函数实体，在整个class声明未被完全看见之前，不会被评估求值（evaluated）的”。也就是说： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对于函数本体的分析延迟，直到class声明右大括号出现才开始</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> cons </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 分析在这里进行</span></span><br></pre></td></tr></table></figure>
 因此一个inline member function躯体之内的data member绑定操作，会在整个class声明完成之后才发生。但这对member function的argument list并不是真的。argument list中的名称会在第一次遇到的时候被适当resolved完成。因此extern和nested type names之间的非直觉绑定操作还是会发生。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// length is resolved for global</span></span><br><span class="line">    <span class="comment">// _val is resolved for Point3d::_val</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">(length val)</span> </span>&#123; _val = val; &#125;</span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// length必须在class对他第一个参考操作前被看见</span></span><br><span class="line">    <span class="comment">// 这样的声明使之前操作不合法</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line">    length _val;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 上述的语言状况，仍然需要某种防御性程序风格：<font color=red><strong>请总是把“nested type 声明”放在class的起始处</strong></font>。这样做才能保证非直觉绑定的正确性。</li>
</ol>
</li>
</ul>
<h4 id="3-2-Data-Member的布局（Data-Member-Layout）"><a href="#3-2-Data-Member的布局（Data-Member-Layout）" class="headerlink" title="3.2 Data Member的布局（Data Member Layout）"></a>3.2 Data Member的布局（Data Member Layout）</h4><ul>
<li>已知一组data members：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    staic List&lt;Point3d*&gt; *freeList;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> chunkSize  <span class="number">250</span>;</span><br><span class="line">    <span class="keyword">float</span> z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <font color=red><strong>Nonsatic data members在class object中的排列顺序和其被声明的顺序一样</strong>。</font>任何中介的static data members都不会放进对象布局之中。上述例子中，每个Point3d对象是由三个float组成的。static data members存放在程序的<font color=red>data segment</font>中，和个别class objects无关。<br>  C++ Standard要求，在同一个access section（private、public、protected等区段）中，members的排列只需要符合“较晚出现的members在class object中有较高的地址”这一条件就可以了。下面这个template funciton，接受两个data members，然后<strong>判断谁先出现在class object中</strong>。如果两个members都是不同的access sections中的第一个被声明者，函数就会判断哪个section先出现：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class class_type, class data_type1, class data_type2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">access_order</span><span class="params">(data_type1 class_type::*mem1, data_type2 class_type::*mem2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span> (mem1 != mem2);</span><br><span class="line">    <span class="keyword">return</span> mem1 &lt; mem2 ? <span class="string">&quot;Member 1 occurs first&quot;</span> : <span class="string">&quot;member 2 occurs first&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line"><span class="built_in">access_order</span>(&amp;Point3d::z, &amp;Point3d::y);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-Data-Member的存取"><a href="#3-3-Data-Member的存取" class="headerlink" title="3.3 Data Member的存取"></a>3.3 Data Member的存取</h4><ul>
<li>已知这段代码：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point3d origin, *pt = &amp;origin;</span><br><span class="line"><span class="comment">// 存取data members， like this：</span></span><br><span class="line">origin.x = <span class="number">0.0</span>;</span><br><span class="line">pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
  通过origin存取和通过pt存取有什么重大差异吗？</li>
</ul>
<h5 id="Static-Data-Members"><a href="#Static-Data-Members" class="headerlink" title="Static Data Members"></a>Static Data Members</h5><ul>
<li><font color=red>Static data members</font>，按字面意义，被编译器提出class之外，并被视为global变量。每个member的存取许可，以及class的关联，都不会招致任何空间上或执行时间上的额外负担。每个static data member只有一个实例。</li>
<li>但如果static data members是一个从<font color=red>复杂继承关系中继承</font>而来的，它仍然只有唯一一个实例，其存取路径仍然那么直接。如果static data member经由函数调用，或其他某些语法存取呢？例如：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foobar</span>().chunkSize = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能的转化</span></span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">foobar</span>();</span><br><span class="line">Point3d.chunkSize = <span class="number">250</span>;</span><br></pre></td></tr></table></figure>
  若取一个static data member的地址，会得到一个指向其数据类型的指针，而不是指向其class member的指针，因为static member并不内含在一个class object之中：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;Point3d::chunkSize;</span><br><span class="line"><span class="comment">// 会得到如下类型的内存地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>*</span><br></pre></td></tr></table></figure></li>
<li>如果有两个classes，每个都声明了一个static member freeList，那么当它们放在程序的data segment时，会导致<font color=red>名称冲突</font>。编译器的解决方式是暗中对每个<font color=green>static data member编码</font>（<font color=red><strong>name-mangling</strong></font>），以获得一个独一无二的程序识别代码。任何name-mangling做法都有两个重点：<ol>
<li>一个算法，<strong>推导出独一无二的名称</strong>。</li>
<li>万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易<strong>被推导回到原来的名称</strong>。 </li>
</ol>
</li>
</ul>
<h5 id="Nonstatic-Data-Members"><a href="#Nonstatic-Data-Members" class="headerlink" title="Nonstatic Data Members"></a>Nonstatic Data Members</h5><ul>
<li><font color=red>Nonstatic data members</font>直接放在每个class object中。除非经由<font color=red>显式</font>（<font color=green>explcit</font>）或<font color=red>隐式</font>的（<font color=green>implicit</font>），否则没有办法直接存取它们。只要在member funcion中直接处理一个nonstatic data member，implicit class object就会发生。例如：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point3d <span class="title">Point3d::translate</span><span class="params">(<span class="keyword">const</span> Point3d &amp;pt)</span> </span>&#123;</span><br><span class="line">    x += pt.x;</span><br><span class="line">    y += pt.y;</span><br><span class="line">    z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  表面上x、y、z直接存取，事实上是经由implicit class object（由this指针表述）完成的。这个函数的参数是：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// member function的内部转化</span></span><br><span class="line"><span class="function">Point3d <span class="title">Point3d::translate</span><span class="params">(Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x += pt.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y += pt.y;</span><br><span class="line">    <span class="keyword">this</span>-&gt;z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>欲对一个nonstatic data member进行存取操作，编译器需要把<strong>class object的起始地址加上data member的偏移位置（offset）</strong>。例如：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin._y = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">&amp;origin + (&amp;Point3d::_y - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
  每一个nonstatic data member的偏移位置（offset）在编译时期即可获知，甚至如果派生自单一或多重继承串链也是一样。</li>
<li>再来看看<font color=red>虚拟继承</font>。虚拟继承将为经由base class subobject存取class members导入一层间接性。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.x = <span class="number">0.0</span>;</span><br><span class="line">pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure>
  从origin存取和从pt存取有什么重大差异？答案是当Pointe3d是一个derived class，而其继承结构中有一个virtual base class，并且被存取member是一个从该virtual base class继承而来的member就会有重大差异。这时候，我们无法在编译时期直到member真正的offset位置。<font color=red>这个存取操作必须延迟到执行期</font>。如果使用origin就不会有这个问题。</li>
</ul>
<h4 id="3-4-“继承”于Data-Member"><a href="#3-4-“继承”于Data-Member" class="headerlink" title="3.4 “继承”于Data Member"></a>3.4 “继承”于Data Member</h4><ul>
<li>如果为2D和3D坐标点提供两个抽象数据类型：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Point2d</span><br><span class="line">Point3d</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// supporting abstract data types</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor(s)</span></span><br><span class="line">    <span class="comment">// operations</span></span><br><span class="line">    <span class="comment">// access functions</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor(s)</span></span><br><span class="line">    <span class="comment">// operations</span></span><br><span class="line">    <span class="comment">// access functions</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这和提供两层或三层继承结构，每一层（代表一个维度）是一个class，派生自较低维层次有什么不同？</li>
</ul>
<h5 id="只要继承不要多态（Inheritance-without-Polymorphism）"><a href="#只要继承不要多态（Inheritance-without-Polymorphism）" class="headerlink" title="只要继承不要多态（Inheritance without Polymorphism）"></a>只要继承不要多态（Inheritance without Polymorphism）</h5><ul>
<li>我们可能希望不论是2D或3D坐标点，能共享同一个实例，但又能继续使用于类型性质相关的实例。以上的设计策略。带来的影响则是可以共享数据本身以及数据处理方法，并将它局部化。一般而言，<font color=red>具体继承</font>（<font color=green>concrete inheritance</font>，相对于虚拟继承virtual inheritance）并不会增加空间或存取时间上的额外负担。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Point3d --- Point2d</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>) : _x(x), _y(y) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">y</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">x</span><span class="params">(<span class="keyword">float</span> newX)</span> </span>&#123; _x = newX; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">y</span><span class="params">(<span class="keyword">float</span> newY)</span> </span>&#123; _y = newY; &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Piont2d &amp;rhs) &#123;</span><br><span class="line">        _x += rhs.<span class="built_in">x</span>();</span><br><span class="line">        _y += rhs.<span class="built_in">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inheritance from concrete class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>, <span class="keyword">float</span> z = <span class="number">0.0</span>) : <span class="built_in">Point2d</span>(x, y), _z(z) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _z; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123; _z = newZ; &#125;</span><br><span class="line">    <span class="keyword">void</span> oeprator+=(<span class="keyword">const</span> Point3d &amp;rhs) &#123;</span><br><span class="line">        Point2d::<span class="keyword">operator</span>+=(rhs);</span><br><span class="line">        _z += rhs.<span class="built_in">z</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这样的设计的好处是可以把管理x和y坐标的程序代码局部化。也表现处两个类之间的紧密关系。但把原本两个独立不相干的classes凑成一堆”type/subtype“，并带有继承关系，会有什么易犯的错误呢？<ul>
<li>经验不足的人可能会重复设计一些相同操作的函数。以例子中的constructor和operator+=为例，它们并没有被做成inline函数。</li>
<li>第二是，把class分解成两层或更多层，可能会为了”表现class继承体系的抽象化“而膨胀所需的空间。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> c1;</span><br><span class="line">    <span class="keyword">char</span> c2;</span><br><span class="line">    <span class="keyword">char</span> c3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在32位机器中，每个Concrete class object大小是<strong>8bytes</strong>，细分如下:</li>
</ul>
<ol>
<li>val占用4bytes；</li>
<li>c1、c2和c3各占用1bytes；</li>
<li>alignment（调整到word边界）需要1bytes。</li>
</ol>
  现在把Concrete分裂为三层结构：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Concrete2 --- Concrete1</span><br><span class="line">Concrete3 --- Concrete2</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> bit1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span> :</span> <span class="keyword">public</span> Concrete1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> bit2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete3</span> :</span> <span class="keyword">public</span> Concrete2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">char</span> bit3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  现在Concrete3 object的大小是16bytes，比原先的设计多了100%。（p106）  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Concrete2 *pc2;</span><br><span class="line">Concrete1 *pc1_1, *pc1_2;</span><br><span class="line"><span class="comment">// 如果C++把derived class members和Concrete1 subobject捆绑在一起，去除填补空间</span></span><br><span class="line">pc1_1 = pc2;    <span class="comment">// pc1_1指向Concrete2对象</span></span><br><span class="line"><span class="comment">// derived class subobject被覆盖掉</span></span><br><span class="line"><span class="comment">// 于是bit2 member现在有了一个并非预期的数值</span></span><br><span class="line">*pc1_2 = *pc1_1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="加上多态（Adding-Polymorphism）"><a href="#加上多态（Adding-Polymorphism）" class="headerlink" title="加上多态（Adding Polymorphism）"></a>加上多态（Adding Polymorphism）</h5><ul>
<li>如果在继承关系中提供要给virtual function接口：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point2d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0.0</span>) : _x(x), _y(y) &#123;&#125;;</span><br><span class="line">    <span class="comment">// 之前的存取操作</span></span><br><span class="line">    <span class="comment">// 加上z的保留空间（目前什么也不做）</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0.0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 谁当以下运算符为virtual</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="keyword">operator</span>+=(<span class="keyword">const</span> Point2d &amp;rhs) &#123;</span><br><span class="line">        _x += rhs.<span class="built_in">x</span>();</span><br><span class="line">        _y += rhs.<span class="built_in">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d &#123;</span><br><span class="line">pblic:</span><br><span class="line">    <span class="built_in">Point3d</span>(<span class="keyword">float</span> x = <span class="number">0.0</span>, <span class="keyword">float</span> y = <span class="number">0l</span>0, <span class="keyword">float</span> z = <span class="number">0.0</span>) : <span class="built_in">Ponit2d</span>(x, y), _z(z) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">z</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _z; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">z</span><span class="params">(<span class="keyword">float</span> newZ)</span> </span>&#123; _z = newZ; &#125;</span><br><span class="line">    vodi <span class="keyword">operator</span>+=(<span class="keyword">const</span> Piont2d &amp;rhs) &#123;</span><br><span class="line">        Point2d::oeprator+=(rhs);</span><br><span class="line">        _z += rhs.<span class="built_in">z</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... more members</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  这个设计有个好处是可以把operator+=运用在一个Pointe3d对象和一个Point2对象身上：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point2d <span class="title">p2d</span><span class="params">(<span class="number">2.1</span>, <span class="number">2.2</span>)</span></span>;</span><br><span class="line"><span class="function">Point3d <span class="title">p3d</span><span class="params">(<span class="number">3.1</span>,, <span class="number">3.2</span>, <span class="number">3.3</span>)</span></span>;</span><br><span class="line">p3d += p2d;</span><br></pre></td></tr></table></figure>
  虽然class的声明语法没变，但事情不一样了：z() member function和operator+=()运算符都成了虚函数；<font color=red><strong>每个Point3d class object内含一个额外的vptr member和一个Piont3d virtual table</strong></font>；此外每个virtual member function的调用也复杂了。</li>
<li>C++编辑器领域主要讨论的问题是把vptr放置在class object哪里最好？cfont编译器中，被放在class object的尾端：    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">no_virts</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">has_virts</span> :</span> <span class="keyword">public</span> no_virts &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">no_virts *p = <span class="keyword">new</span> has_virts;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">struct no_virts nv;</th>
<th align="center">class has_virts : <br>public no_virts hv;</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int d1</td>
<td align="center"><strong>int d1</strong></td>
</tr>
<tr>
<td align="center">int d2</td>
<td align="center"><strong>int d2</strong></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center">int d3</td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center">__vptr__has_virts</td>
</tr>
<tr>
<td align="center">把vptr放在object尾端，可以保留base class C struct的对象布局，因而允许C程序代码也能使用，这做法出现在C++问世时。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">到了C++2.0，开始支持<font color=red>虚继承</font>以及<font color=red>抽象基类</font>，某些编译器开始把vptr放到class object前端：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">struct no_virts nv;</td>
<td align="center">class has_virts : <br>public no_virts hv;</td>
</tr>
<tr>
<td align="center">:-:</td>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">int d1</td>
<td align="center">__vptr__has_virts</td>
</tr>
<tr>
<td align="center">int d2</td>
<td align="center"><strong>int d1</strong></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center"><strong>int d2</strong></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center">int d3</td>
</tr>
<tr>
<td align="center">vptr放在class object前端，对于多继承下通过指向class members的指针调用virtual function会有一些帮助。否则，<strong>不仅从class object起始点开始量起的offset必须在执行器备妥，class vptr之间的offset也必须备妥</strong>。</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">以下是Point2d和Point3d加上了virtual function之后的继承布局（单一继承）：</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">class Point2d p2d;</td>
<td align="center">class Point3d :<br>public Point2d pt3d;</td>
</tr>
<tr>
<td align="center">:-:</td>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">float _x</td>
<td align="center"><strong>float _x</strong></td>
</tr>
<tr>
<td align="center">float _y</td>
<td align="center"><strong>float _y</strong></td>
</tr>
<tr>
<td align="center">__vptr__Point2d</td>
<td align="center"><strong>__vptr__Point2d</strong></td>
</tr>
<tr>
<td align="center">&nbsp;</td>
<td align="center">float _z</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="多重继承（Multiple-Inheritance）"><a href="#多重继承（Multiple-Inheritance）" class="headerlink" title="多重继承（Multiple Inheritance）"></a>多重继承（Multiple Inheritance）</h5><ul>
<li>单一继承提供了一种<font color=red>自然多态</font>（<font color=green>natural polymorphism</font>）形式，是关于base type和derived type之间的转换。base 它们的object都是从相同的地址开始。差异只在<strong>derived object比较大，用以容纳它自己的nonstatic data members</strong>。一个derived class指定给base class的指针或reference。这个操作并不需要编译器调停或修改地址。可以很自然地发生，而且提供了最佳执行效率。</li>
<li>多重继承不像单一继承，也不容易模塑处模型。它的复杂度在于derived class和其base class之间的非自然关系：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Point3d --- Point2d </span><br><span class="line">Vertex3d --- Point3d</span><br><span class="line">Vertex3d --- Vertex</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...有virtual接口，会有vptr</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... vptr</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Vertex *next</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Point3d, <span class="keyword">public</span> Vertex &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  多重继承的问题主要发生在derived class objects和后继base class objects之间的转换，不论是：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">mumble</span><span class="params">(<span class="keyword">const</span> Vertex&amp;)</span></span>;</span><br><span class="line">Vertex3d v;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">mumble</span>(v); <span class="comment">// 不自然</span></span><br></pre></td></tr></table></figure>
  或是经由所支持的virtual function机制做转换。多继承对象符出的成本在于地址的指定操作而已：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vertex3d v3d;</span><br><span class="line">Vertex *pv;</span><br><span class="line">Point2d *p2d;</span><br><span class="line">Point3d *p3d;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定操作</span></span><br><span class="line">pv = &amp;v3d;</span><br><span class="line"><span class="comment">// 需要内部转化</span></span><br><span class="line">pv = (Vertex*)(((<span class="keyword">char</span>*)&amp;v3d) + <span class="built_in"><span class="keyword">sizeof</span></span>(Point3d));</span><br><span class="line"><span class="comment">// 如果v3d为指针类型，即pv3d，则:</span></span><br><span class="line">pv = pv3d ? (Vertex*)((<span class="keyword">char</span>*)pv3d) + <span class="built_in"><span class="keyword">sizeof</span></span>(Point3d) : <span class="number">0</span>; <span class="comment">// 防止pv3d为0</span></span><br></pre></td></tr></table></figure>
  以下为<font color=red>多重继承</font>（<font color=green>Multiple Inheritance</font>)：<table>
<thead>
<tr>
<th align="center">class Point2d pt2d;</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float _x</td>
</tr>
<tr>
<td align="center">float _y</td>
</tr>
<tr>
<td align="center">__vptr__Point2d</td>
</tr>
<tr>
<td align="center"></td>
</tr>
<tr>
<td align="center">class Point3d :<br>public Point2d pt3d;</td>
</tr>
<tr>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">float _x</td>
</tr>
<tr>
<td align="center">float _y</td>
</tr>
<tr>
<td align="center">__vptr__Point2d</td>
</tr>
<tr>
<td align="center">float _z</td>
</tr>
<tr>
<td align="center"></td>
</tr>
<tr>
<td align="center">Vertex v;</td>
</tr>
<tr>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">Vertex *next</td>
</tr>
<tr>
<td align="center">__vptr__Vertex</td>
</tr>
<tr>
<td align="center"></td>
</tr>
<tr>
<td align="center">class Vertex3d :<br> public Point3d,<br>public Vertex<br>{}v3d;</td>
</tr>
<tr>
<td align="center">:-:</td>
</tr>
<tr>
<td align="center">float _x</td>
</tr>
<tr>
<td align="center">float _y</td>
</tr>
<tr>
<td align="center">__vptr__Point2d</td>
</tr>
<tr>
<td align="center">float _z</td>
</tr>
<tr>
<td align="center">Vertex *next</td>
</tr>
<tr>
<td align="center">__vptr__Vertex</td>
</tr>
<tr>
<td align="center">float mumble</td>
</tr>
</tbody></table>
</li>
</ul>
<h5 id="虚拟继承（Virtual-Inheritance）"><a href="#虚拟继承（Virtual-Inheritance）" class="headerlink" title="虚拟继承（Virtual Inheritance）"></a>虚拟继承（Virtual Inheritance）</h5><ul>
<li>多重继承的一个语意上的副作用是，<font color=red><strong>必须支持某种形式上的”shared subobject继承“</strong></font>。如早期的iostream library：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pre-standard iostream implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span> :</span> <span class="keyword">public</span> ios &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> :</span> <span class="keyword">public</span> ios &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span> :</span> <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
  下图可表现iostream的继承体系图。第一个为多重继承，第二个为虚拟多重继承：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">istream --- ios1[ios]</span><br><span class="line">ostream --- ios2[ios]</span><br><span class="line">iostream --- istream</span><br><span class="line">iostream --- ostream</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">istream --- ios</span><br><span class="line">ostream --- ios</span><br><span class="line">iostream --- istream</span><br><span class="line">iostream --- ostream</span><br></pre></td></tr></table></figure>
  在iostream对象布局中，只需要一份就好：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ios</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">istream</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ios &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ostream</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ios &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iostream</span> :</span> <span class="keyword">public</span> istream, <span class="keyword">public</span> ostream &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
  上述iostream的实现挑战在于：**一个有效的方法，将istream和ostream各自维护ios subobjet，折叠成由iostream维护的单一ios subobject，并且保存base class和derived class的指针（reference）之间的<font color=red>多态指定操作</font>（<font color=green>polymorphism assignments</font>)**。</li>
<li>一般的实现方法是。Class如果内含一个或多个virtual base class subobjects，像istream那样，将被分割两部分：<font color=red><strong>一个不变区域</strong></font>和<font color=red><strong>一个共享区域</strong></font>。不变区域中的数据，总是有<strong>固定的offset</strong>，所以这里可以直接存取。而共享区域，就是virtual base class subobject。它们只能被间接存取。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _x, _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Vertex *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2d &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> _z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vertex3d</span> :</span> <span class="keyword">public</span> Vertex, <span class="keyword">public</span> Point3d &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">float</span> mumble;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">Vertex -- _x,_y--- Point2d</span><br><span class="line">Point3d -- _z --- Point2d</span><br><span class="line">Vertex3d -- next --- Vertex</span><br><span class="line">Vertex3d -- _z --- Point3d</span><br><span class="line">none[ ] -- mumble --- Vertex3d</span><br></pre></td></tr></table></figure>
  这中间存在一个问题：如何能够存取class共享部分呢？cfont编译器是在derived class object中插指针，每个指向virtual base class。需要完成操作都是通过指针间接完成的。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Point3d::<span class="keyword">operator</span>+=(<span class="keyword">const</span> Point3d &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    _X += rhs._x;</span><br><span class="line">    _y += rhs._y;</span><br><span class="line">    _z += rhs._z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化为虚构代码vbc为virtual base class</span></span><br><span class="line">__vbcPoint2d-&gt;_x += rhs.__vbcPoint2d-&gt;_x;</span><br><span class="line">__vbcPoint2d-&gt;_y += rhs.__vbcPoint2d-&gt;_y;</span><br><span class="line">_z += rhs._z;</span><br></pre></td></tr></table></figure>
  这样实现模型有两个主要缺点：<ol>
<li><strong>每个对象针对其每个virtual base class背负一个额外的指针</strong>。而我们希望class object负担是稳定的。</li>
<li><strong>虚继承链加长会导致存取层次增加</strong>。我们呢希望有着固定的存取时间。</li>
</ol>
</li>
<li>对于第二个问题。MetaWare和其他编译器到今天还是用cfont原始模型：它们经由拷贝操作取得所有nested virtual base class指针，放到derived class object中，虽然有空间代价。</li>
<li>至于第一个问题，有两个解决方法。Microsoft编译器引入virtual base class table。每个class object如果有一个以上virual base classes，编译器就安插指针，指向virtual base class table，真正的vptr则被放在该表格中。第二个解决方法，是在virtual function table中放置virtual base class的offset（而非地址）。<table>
<thead>
<tr>
<th align="center">class Vertex3d :<br>public Vertex,<br>public Point3d<br>{…} v3d;</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Vertex *next</td>
</tr>
<tr>
<td align="center"><strong>Point2d *pPoint2d</strong></td>
</tr>
<tr>
<td align="center">__vptr__Vertex</td>
</tr>
<tr>
<td align="center">float _z</td>
</tr>
<tr>
<td align="center"><strong>Point2d *pPoint2d</strong></td>
</tr>
<tr>
<td align="center">__vptr__Point3d</td>
</tr>
<tr>
<td align="center">float mumble</td>
</tr>
<tr>
<td align="center">float _x</td>
</tr>
<tr>
<td align="center">float _y</td>
</tr>
<tr>
<td align="center">__vptr__Point2d</td>
</tr>
<tr>
<td align="center">该方法把<font color=red>virtual base class offset</font>和<font color=red>virtual function entires</font>混杂在一起。Sum编译器中，virtual function table由正值或负值来索引。正值则索引到virtual functions；负值则索引到virtual base class offsets。</td>
</tr>
<tr>
<td align="center"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">this</span> + __vptr__Point3d[<span class="number">-1</span>])-&gt;_x +=</span><br><span class="line">    (&amp;rhs + rhs.__vptr__Point3d[<span class="number">-1</span>])-&gt;_x;</span><br><span class="line">(<span class="keyword">this</span> + __vptr__Point3d[<span class="number">-1</span>])-&gt;_y += </span><br><span class="line">    (&amp;rhs + rhs.__vptr__Point3d[<span class="number">-1</span>])-&gt;_y;</span><br><span class="line">_ += rhs._z;</span><br></pre></td></tr></table></figure></td>
</tr>
<tr>
<td align="center">因此Derived class实例和base class实例之间的转换操作为：</td>
</tr>
<tr>
<td align="center"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point2d *p2d = pv3d;</span><br><span class="line"><span class="comment">// translation</span></span><br><span class="line">Point2d *pt2 = pv3d ? pv3d + pv3d-&gt;__vptr__Point3d[<span class="number">-1</span>] : <span class="number">0</span>;</span><br></pre></td></tr></table></figure></td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="3-5-对象成员的效率（Object-Member-Efficiency）"><a href="#3-5-对象成员的效率（Object-Member-Efficiency）" class="headerlink" title="3.5 对象成员的效率（Object Member Efficiency）"></a>3.5 对象成员的效率（Object Member Efficiency）</h4><ul>
<li>下面测试旨在测试<font color=red>聚合</font>（<font color=green>aggregation</font>）、<font color=red>封装</font>（<font color=green>encapsulation</font>）以及<font color=red>继承</font>（<font color=green>inheritance</font>）所引发的额外负荷程序。跳过。</li>
</ul>
<h4 id="3-6-指向Data-Members的指针（Poniter-to-Data-Members）"><a href="#3-6-指向Data-Members的指针（Poniter-to-Data-Members）" class="headerlink" title="3.6 指向Data Members的指针（Poniter to Data Members）"></a>3.6 指向Data Members的指针（Poniter to Data Members）</h4><ul>
<li>考虑下面Point3d声明。有一个virtual function，一个static data member，以及三个坐标：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Point3d</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">static</span> Point3d origin;</span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  每个Point3d object含有三个坐标值，依序为x、y、z，以及vptr。static data member origin放在class object之外。vptr的位置根据编译器不同而不同。不是放头就是尾。<code>&amp;Point3d::z;</code>取得某个坐标成员的地址代表什么呢？<strong>代表着z坐标在class object中偏移位置（offset）</strong>。</li>
<li>一台32位机器上，每一个float是4bytes，所以期望获取地址偏移位置要么是8要么是12。然而获取的总是多1，也就是9和13（我的输出并没有+1）。</li>
<li>在多继承下，要将第二个或后继base class的指针，和一个与derived class object绑定的member结合起来，那么将会因为需要加入offset值而变得复杂。例如:  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span> &#123;</span> <span class="keyword">int</span> val1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span> &#123;</span> <span class="keyword">int</span> val2; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2 &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> Derived::*dmp, Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 期望第一个参数是一个derived class的member指针，结果是base class的会怎样。</span></span><br><span class="line">    pd-&gt;*dmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// bmp将成为1</span></span><br><span class="line">    <span class="keyword">int</span> Base2::*bmp = &amp;Base2::val2;</span><br><span class="line">    <span class="comment">// bmp == 1但在Derived中val2 == 5</span></span><br><span class="line">    <span class="built_in">func1</span>(bmp, pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  要解决这个问题，必须：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经由编译器内部转换</span></span><br><span class="line"><span class="built_in">func1</span>(bmp ? bmp + <span class="built_in"><span class="keyword">sizeof</span></span>(Base1) : <span class="number">0</span>, pd);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="“指向Members的指针”的效率问题"><a href="#“指向Members的指针”的效率问题" class="headerlink" title="“指向Members的指针”的效率问题"></a>“指向Members的指针”的效率问题</h5><ul>
<li>下面是测试数据。了解在3D坐标点的不同class表现方式下指向members的指针所带来的影响。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ichheit</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">51</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ichheit</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
